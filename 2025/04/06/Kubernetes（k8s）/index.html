<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>k8s学习记录 | cy77cc</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="有状态和无状态  会保存数据的是有状态 不保存数据的是无状态  一、环境准备3台虚拟机，至少是2C2G，互相能ping通 1.1 下载RockyLinux91https:&#x2F;&#x2F;rockylinux.org&#x2F;download  1.2 环境初始化三个node的配置差不多，ip地址换一下就行 12345678910111213141516171819202122232425262728293031323">
<meta property="og:type" content="article">
<meta property="og:title" content="k8s学习记录">
<meta property="og:url" content="https://cy77cc.github.io/2025/04/06/Kubernetes%EF%BC%88k8s%EF%BC%89/index.html">
<meta property="og:site_name" content="cy77cc">
<meta property="og:description" content="有状态和无状态  会保存数据的是有状态 不保存数据的是无状态  一、环境准备3台虚拟机，至少是2C2G，互相能ping通 1.1 下载RockyLinux91https:&#x2F;&#x2F;rockylinux.org&#x2F;download  1.2 环境初始化三个node的配置差不多，ip地址换一下就行 12345678910111213141516171819202122232425262728293031323">
<meta property="og:locale">
<meta property="og:image" content="https://raw.githubusercontent.com/cy77cc/pic-md/master/image-20250407094704165.png">
<meta property="og:image" content="https://raw.githubusercontent.com/cy77cc/pic-md/master/image-20250408145217802.png">
<meta property="og:image" content="https://raw.githubusercontent.com/cy77cc/pic-md/master/image-20250410164840969.png">
<meta property="og:image" content="https://raw.githubusercontent.com/cy77cc/pic-md/master/image-20250411104731185.png">
<meta property="og:image" content="https://raw.githubusercontent.com/cy77cc/pic-md/master/image-20250412143958462.png">
<meta property="og:image" content="https://raw.githubusercontent.com/cy77cc/pic-md/master/image-20250412155644138.png">
<meta property="og:image" content="https://raw.githubusercontent.com/cy77cc/pic-md/master/image-20250412190857131.png">
<meta property="og:image" content="https://raw.githubusercontent.com/cy77cc/pic-md/master/image-20250412201807387.png">
<meta property="og:image" content="https://raw.githubusercontent.com/cy77cc/pic-md/master/image-20250412211511314.png">
<meta property="og:image" content="https://raw.githubusercontent.com/cy77cc/pic-md/master/image-20250413123107109.png">
<meta property="og:image" content="https://raw.githubusercontent.com/cy77cc/pic-md/master/image-20250406163615248.png">
<meta property="article:published_time" content="2025-04-06T01:21:00.000Z">
<meta property="article:modified_time" content="2025-04-15T06:32:44.358Z">
<meta property="article:author" content="Mr. Zhang">
<meta property="article:tag" content="中间件,docker,kubernetes">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/cy77cc/pic-md/master/image-20250407094704165.png">
  
    <link rel="alternate" href="/atom.xml" title="cy77cc" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/fork-awesome@1.2.0/css/fork-awesome.min.css">

<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">cy77cc</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Suche"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Suche"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://cy77cc.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-Kubernetes（k8s）" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/04/06/Kubernetes%EF%BC%88k8s%EF%BC%89/" class="article-date">
  <time class="dt-published" datetime="2025-04-06T01:21:00.000Z" itemprop="datePublished">2025-04-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      k8s学习记录
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>有状态和无状态</p>
<ul>
<li>会保存数据的是有状态</li>
<li>不保存数据的是无状态</li>
</ul>
<h2 id="一、环境准备"><a href="#一、环境准备" class="headerlink" title="一、环境准备"></a>一、环境准备</h2><p>3台虚拟机，至少是2C2G，互相能ping通</p>
<h3 id="1-1-下载RockyLinux9"><a href="#1-1-下载RockyLinux9" class="headerlink" title="1.1 下载RockyLinux9"></a>1.1 下载RockyLinux9</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://rockylinux.org/download</span><br></pre></td></tr></table></figure>

<h3 id="1-2-环境初始化"><a href="#1-2-环境初始化" class="headerlink" title="1.2 环境初始化"></a>1.2 环境初始化</h3><p>三个node的配置差不多，ip地址换一下就行</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">网卡配置</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">cat</span> /etc/NetworkManager/system-connections/ens160.nmconnection</span></span><br><span class="line">[ipv4]</span><br><span class="line">address1=192.168.66.11/24</span><br><span class="line">method=manual</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">调用 nmcli 重启设备和连接配置</span></span><br><span class="line">nmcli d r ens160 </span><br><span class="line">nmcli c r ens160</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">更换yum源</span></span><br><span class="line">sed -e &#x27;s|^mirrorlist=|#mirrorlist=|g&#x27; \</span><br><span class="line">    -e &#x27;s|^#baseurl=http://dl.rockylinux.org/$contentdir|baseurl=https://mirrors.aliyun.com/rockylinux|g&#x27; \</span><br><span class="line">    -i.bak \</span><br><span class="line">    /etc/yum.repos.d/Rocky-*.repo</span><br><span class="line"></span><br><span class="line">dnf makecache</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">防火墙修改 firewalld 为 iptables</span></span><br><span class="line">systemctl stop firewalld</span><br><span class="line">systemctl disable firewalld</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">可选</span></span><br><span class="line">yum -y install iptables-services</span><br><span class="line">systemctl start iptables</span><br><span class="line">iptables -F</span><br><span class="line">systemctl enable iptables</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">禁用 Selinux</span></span><br><span class="line">setenforce 0</span><br><span class="line">sed -i &quot;s/SELINUX=enforcing/SELINUX=disabled/g&quot; /etc/selinux/config</span><br><span class="line">grubby --update-kernel ALL --args selinux=0</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置时区</span></span><br><span class="line">timedatectl set-timezone Asia/Shanghai</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">关闭 swap 分区</span></span><br><span class="line">swapoff -a</span><br><span class="line">sed -i &#x27;s:/dev/mapper/rl-swap:#/dev/mapper/rl-swap:g&#x27; /etc/fstab</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">修改主机名</span></span><br><span class="line">hostnamectl  set-hostname k8s-node01</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装 ipvs</span></span><br><span class="line">yum install -y ipvsadm</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">开启路由转发</span></span><br><span class="line">echo &#x27;net.ipv4.ip_forward=1&#x27; &gt;&gt; /etc/sysctl.conf</span><br><span class="line">sysctl -p</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">加载 bridge</span></span><br><span class="line">yum install -y epel-release</span><br><span class="line">yum install -y bridge-utils</span><br><span class="line"></span><br><span class="line">modprobe br_netfilter</span><br><span class="line">echo &#x27;br_netfilter&#x27; &gt;&gt; /etc/modules-load.d/bridge.conf</span><br><span class="line">echo &#x27;net.bridge.bridge-nf-call-iptables=1&#x27; &gt;&gt; /etc/sysctl.conf</span><br><span class="line">echo &#x27;net.bridge.bridge-nf-call-ip6tables=1&#x27; &gt;&gt; /etc/sysctl.conf</span><br><span class="line">sysctl -p</span><br></pre></td></tr></table></figure>

<h3 id="1-3-安装docker"><a href="#1-3-安装docker" class="headerlink" title="1.3 安装docker"></a>1.3 安装docker</h3><p>k8s也不一定要用docker作为容器运行时，可以直接使用containerd，k8s好像默认的也是containerd，使用docker作为容器运行起还需要安装cir-dockerd。参考链接 <a target="_blank" rel="noopener" href="https://docs.docker.com/engine/install/rhel/">https://docs.docker.com/engine/install/rhel/</a></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">移除旧版本</span></span><br><span class="line">sudo dnf remove docker \</span><br><span class="line">                  docker-client \</span><br><span class="line">                  docker-client-latest \</span><br><span class="line">                  docker-common \</span><br><span class="line">                  docker-latest \</span><br><span class="line">                  docker-latest-logrotate \</span><br><span class="line">                  docker-logrotate \</span><br><span class="line">                  docker-engine \</span><br><span class="line">                  podman \</span><br><span class="line">                  runc</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">添加仓库</span>                  </span><br><span class="line">sudo dnf -y install dnf-plugins-core</span><br><span class="line">sudo dnf config-manager --add-repo https://download.docker.com/linux/rhel/docker-ce.repo</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">下载最新版本的docker</span></span><br><span class="line">sudo dnf install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置开启自启动</span></span><br><span class="line">sudo systemctl enable --now docker</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">这里还需要配置docker的镜像，阿里云的镜像加速已经没用了，需要另外找</span></span><br><span class="line">sudo mkdir -p /etc/docker</span><br><span class="line">sudo tee /etc/docker/daemon.json &lt;&lt;-&#x27;EOF&#x27;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [&quot;https://xxxx.mirror.aliyuncs.com&quot;]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure>

<h3 id="1-4-安装cri-dockerd"><a href="#1-4-安装cri-dockerd" class="headerlink" title="1.4 安装cri-dockerd"></a>1.4 安装cri-dockerd</h3><p>docker之前的运行时在k8s v1.24移除了，所以现在要额外安装cri-dockerd才能用docker作为k8s的容器运行时。参考链接（<a target="_blank" rel="noopener" href="https://mirantis.github.io/cri-dockerd/usage/install-manually/%EF%BC%89">https://mirantis.github.io/cri-dockerd/usage/install-manually/）</a></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在github下载cri-dockerd</span></span><br><span class="line">wget https://github.com/Mirantis/cri-dockerd/releases/download/v0.3.17/cri-dockerd-0.3.17.amd64.tgz</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">解压</span></span><br><span class="line">tar -zxvf cri-dockerd-0.3.17.amd64.tgz</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装</span></span><br><span class="line">install -o root -g root -m 0755 cri-dockerd 解压的cri-dcokerd路径/bin/cri-dockerd</span><br><span class="line">install packaging/systemd/* /etc/systemd/system</span><br><span class="line">sed -i -e &#x27;s,/usr/bin/cri-dockerd,/usr/local/bin/cri-dockerd,&#x27; /etc/systemd/system/cri-docker.service</span><br><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl enable --now cri-docker.socket</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果要在k8s中使用添加一些配置</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">需要追加--network-plugin=cni，通过该配置告诉容器，使用kubernetes的网络接口</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">覆盖沙盒 (pause) 镜像，正常情况下，国内你是拉取不到k8s.gcr.io/pause:3.8镜像的，可以换成国内的registry.aliyuncs.com/google_containers/pause:3.10，这个镜像是一切的 Pod 的基础，要么自己手动导入进来，要么改成国内的镜像，通过设置以下配置来覆盖默认的沙盒镜像</span></span><br><span class="line">ExecStart=/usr/bin/cri-dockerd --container-runtime-endpoint fd:// --network-plugin=cni --pod-infra-container-image=registry.aliyuncs.com/google_containers/pause:3.10</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重新启动cri-dockers服务</span></span><br><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl enable cri-docker.service</span><br><span class="line">systemctl enable --now cri-docker.socket</span><br><span class="line">systemctl restart cri-dockerd</span><br></pre></td></tr></table></figure>

<h3 id="1-5-安装kubernetes"><a href="#1-5-安装kubernetes" class="headerlink" title="1.5 安装kubernetes"></a>1.5 安装kubernetes</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">此操作会覆盖 /etc/yum.repos.d/kubernetes.repo 中现存的所有配置</span></span><br><span class="line">cat &lt;&lt;EOF | sudo tee /etc/yum.repos.d/kubernetes.repo</span><br><span class="line">[kubernetes]</span><br><span class="line">name=Kubernetes</span><br><span class="line">baseurl=https://pkgs.k8s.io/core:/stable:/v1.31/rpm/</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=1</span><br><span class="line">gpgkey=https://pkgs.k8s.io/core:/stable:/v1.31/rpm/repodata/repomd.xml.key</span><br><span class="line">exclude=kubelet kubeadm kubectl cri-tools kubernetes-cni</span><br><span class="line">EOF</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装软件</span></span><br><span class="line">sudo yum install -y kubelet kubeadm kubectl --disableexcludes=kubernetes</span><br><span class="line">sudo systemctl enable --now kubelet</span><br></pre></td></tr></table></figure>

<h3 id="1-6-搭建集群"><a href="#1-6-搭建集群" class="headerlink" title="1.6 搭建集群"></a>1.6 搭建集群</h3><p>上面的操作需要在三个节点都执行一遍，也可以执行完后克隆虚拟机，修改ip地址</p>
<h4 id="1-6-1-修改三个虚拟机的hostname"><a href="#1-6-1-修改三个虚拟机的hostname" class="headerlink" title="1.6.1 修改三个虚拟机的hostname"></a>1.6.1 修改三个虚拟机的hostname</h4><p>修改节点的hostname，这样就可以直接知识honstname访问node，添加到host</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">分别在不同虚拟机执行</span></span><br><span class="line">hostnamectl  set-hostname k8s-node1</span><br><span class="line">hostnamectl  set-hostname k8s-master</span><br><span class="line">hostnamectl  set-hostname k8s-node2</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">添加到host文件</span></span><br><span class="line">vim /etc/hosts</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">添加解析</span></span><br><span class="line">192.168.66.11 k8s-master</span><br><span class="line">192.168.66.22 k8s-node1</span><br><span class="line">192.168.66.33 k8s-node2</span><br></pre></td></tr></table></figure>

<h4 id="1-6-2-初始化主节点"><a href="#1-6-2-初始化主节点" class="headerlink" title="1.6.2 初始化主节点"></a>1.6.2 初始化主节点</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">kubeadm init </span><br><span class="line">--apiserver-advertise-address=192.168.66.11    # apiserver地址</span><br><span class="line">--image-repository registry.aliyuncs.com/google_containers # 镜像仓库</span><br><span class="line">--kubernetes-version 1.32.3 # k8s的版本，使用kubectl version 查看，要和自己的版本对应 </span><br><span class="line">--service-cidr=10.10.0.0/12 </span><br><span class="line">--pod-network-cidr=10.244.0.0/16 # pod的地址</span><br><span class="line">--ignore-preflight-errors=all </span><br><span class="line">--cri-socket unix:///var/run/cri-dockerd.sock # 使用docker作为容器运行时，如果使用containerd可以不加</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">上面命令执行完后会提示执行三条命令，已经从节点怎么加入集群的命令，记得注意结尾的命令</span></span><br></pre></td></tr></table></figure>

<h4 id="1-6-3-从节点加入集群"><a href="#1-6-3-从节点加入集群" class="headerlink" title="1.6.3 从节点加入集群"></a>1.6.3 从节点加入集群</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">这里的token是在上面初始化主节点后输出的，拷贝过来，添加cri-dockerd的socket套接字执行</span></span><br><span class="line">kubeadm join 192.168.10.11:6443 --token a6xh07.yg9wh2vru2grluwb         --discovery-token-ca-cert-hash sha256:7cd8499abae48c8403800152cc0f655ac704ea00ae30a549acd9bbac7b26dca4 --cri-socket unix:///var/run/cri-dockerd.sock</span><br></pre></td></tr></table></figure>

<h3 id="1-7-部署网络插件"><a href="#1-7-部署网络插件" class="headerlink" title="1.7 部署网络插件"></a>1.7 部署网络插件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">下载配置文件</span></span><br><span class="line">curl https://raw.githubusercontent.com/projectcalico/calico/v3.29.3/manifests/calico.yaml -O</span><br><span class="line"></span><br><span class="line">vim calico.yaml</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">修改ipv4的地址为上面初始化主节点时的pod地址</span></span><br><span class="line">- name: CALICO_IPV4POOL_CIDR</span><br><span class="line">  value: &quot;10.244.0.0/16&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">修改为 BGP 模式</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Enable IPIP</span></span><br><span class="line">- name: CALICO_IPV4POOL_IPIP</span><br><span class="line">  value: &quot;Always&quot;  #改成Off</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">把配置文件里面的所有docker.io都删除，不然下载不到容器</span></span><br><span class="line">sed -i &#x27;s|docker.io/||g&#x27; calico.yaml</span><br><span class="line"></span><br><span class="line">kubectl apply -f calico.yaml  #等待容器安装完成即可</span><br></pre></td></tr></table></figure>

<h3 id="1-8-修改kube-proxy模式为ipvs"><a href="#1-8-修改kube-proxy模式为ipvs" class="headerlink" title="1.8 修改kube-proxy模式为ipvs"></a>1.8 修改kube-proxy模式为ipvs</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">kubectl edit configmap kube-proxy -n kube-system</span></span><br><span class="line">mode: ipvs</span><br><span class="line"></span><br><span class="line">kubectl delete pod -n kube-system -l k8s-app=kube-proxy</span><br></pre></td></tr></table></figure>



<h2 id="二、概念"><a href="#二、概念" class="headerlink" title="二、概念"></a>二、概念</h2><p>Kubernetes 主要由以下几个核心组件组成：</p>
<ul>
<li>etcd 保存了整个集群的状态；</li>
<li>apiserver 提供了资源操作的唯一入口，并提供认证、授权、访问控制、API 注册和发现等机制；</li>
<li>controller manager 负责维护集群的状态，比如故障检测、自动扩展、滚动更新等；</li>
<li>scheduler 负责资源的调度，按照预定的调度策略将 Pod 调度到相应的机器上；</li>
<li>kubelet 负责维护容器的生命周期，同时也负责 Volume（CSI）和网络（CNI）的管理；</li>
<li>Container runtime 负责镜像管理以及 Pod 和容器的真正运行（CRI）；</li>
<li>kube-proxy 负责为 Service 提供 cluster 内部的服务发现和负载均衡；</li>
</ul>
<p>除了核心组件，还有一些推荐的插件，其中有的已经成为 CNCF 中的托管项目：</p>
<ul>
<li>CoreDNS 负责为整个集群提供 DNS 服务</li>
<li>Ingress Controller 为服务提供外网入口</li>
<li>Prometheus 提供资源监控</li>
<li>Dashboard 提供 GUI</li>
<li>Federation 提供跨可用区的集群</li>
</ul>
<h2 id="三、资源"><a href="#三、资源" class="headerlink" title="三、资源"></a>三、资源</h2><p> k8s中所有的内容都抽象为资源，资源实例化之后叫做对象。</p>
<h3 id="2-1-资源类别"><a href="#2-1-资源类别" class="headerlink" title="2.1 资源类别"></a>2.1 资源类别</h3><ol>
<li>命名空间级别<ul>
<li>工作负载型资源：Pod、ReplicaSet、Deployment ……</li>
<li>服务发现及负载均衡型资源类型：Service、Ingress ……</li>
<li>配置与存储型资源：Volume、CSI ……</li>
<li>特殊类型的存储卷：ConfigMap、Secre ……</li>
</ul>
</li>
<li>集群级资源<ul>
<li>Namespace、Node、ClusterRole、ClusterRoleBinding</li>
</ul>
</li>
<li>元数据型资源<ul>
<li>HPA、PodTemplate、LimitRange</li>
</ul>
</li>
</ol>
<h3 id="2-2-资源清单的编写"><a href="#2-2-资源清单的编写" class="headerlink" title="2.2 资源清单的编写"></a>2.2 资源清单的编写</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl api-versions  # 获取api版本</span><br></pre></td></tr></table></figure>

<p>几乎每个 Kubernetes 对象包含两个嵌套的对象字段，它们负责管理对象的配置： 对象 <strong><code>spec</code>（规约）</strong> 和对象 <strong><code>status</code>（状态）</strong>。 对于具有 <code>spec</code> 的对象，你必须在创建对象时设置其内容，描述你希望对象所具有的特征： <strong>期望状态（Desired State）</strong>。</p>
<p><code>status</code> 描述了对象的<strong>当前状态（Current State）</strong>，它是由 Kubernetes 系统和组件设置并更新的。在任何时刻，Kubernetes <a target="_blank" rel="noopener" href="https://kubernetes.io/zh-cn/docs/reference/glossary/?all=true#term-control-plane">控制平面</a> 都一直在积极地管理着对象的实际状态，以使之达成期望状态。</p>
<p>例如，Kubernetes 中的 Deployment 对象能够表示运行在集群中的应用。 当创建 Deployment 时，你可能会设置 Deployment 的 <code>spec</code>，指定该应用要有 3 个副本运行。 Kubernetes 系统读取 Deployment 的 <code>spec</code>， 并启动我们所期望的应用的 3 个实例 —— 更新状态以与规约相匹配。 如果这些实例中有的失败了（一种状态变更），Kubernetes 系统会通过执行修正操作来响应 <code>spec</code> 和 <code>status</code> 间的不一致 —— 意味着它会启动一个新的实例来替换。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/kubernetes/examples/blob/master/guestbook/all-in-one/guestbook-all-in-one.yaml">https://github.com/kubernetes/examples/blob/master/guestbook/all-in-one/guestbook-all-in-one.yaml</a></p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span> <span class="comment"># 接口组/版本  没有写接口组就是core，根据资源类型来写</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span>  <span class="comment"># 类别</span></span><br><span class="line"><span class="attr">metadata:</span>  <span class="comment"># 元数据</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-demo</span>  <span class="comment"># 名字</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span>  <span class="comment"># 归属于哪个命名空间</span></span><br><span class="line">  <span class="attr">labels:</span>  <span class="comment"># 标签</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">myapp</span></span><br><span class="line"><span class="attr">spec:</span>  <span class="comment"># 对象规约</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">myapp-1</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">myapp:v1.0</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">busybox-1</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">tools:busybox</span></span><br><span class="line">    <span class="attr">command:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;/bin/sh&quot;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;-c&quot;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;sleep 3600&quot;</span></span><br><span class="line"><span class="attr">status:</span>  <span class="comment"># 状态</span></span><br><span class="line">  <span class="attr">conditions:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">lastProbeTime:</span> <span class="literal">null</span></span><br><span class="line">    <span class="attr">lastTransitionTime:</span> <span class="string">&quot;2023-11-21T08:49:07z&quot;</span></span><br><span class="line">    <span class="attr">status:</span> <span class="string">&quot;True&quot;</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">Initialized</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">lastProbeTime:</span> <span class="literal">null</span></span><br></pre></td></tr></table></figure>



<h2 id="四、容器的生命周期"><a href="#四、容器的生命周期" class="headerlink" title="四、容器的生命周期"></a>四、容器的生命周期</h2><p><img src="https://raw.githubusercontent.com/cy77cc/pic-md/master/image-20250407094704165.png" alt="image-20250407094704165"></p>
<h3 id="4-1-initC"><a href="#4-1-initC" class="headerlink" title="4.1. initC"></a>4.1. initC</h3><p>init容器与普通的容器相似，除了如下两点：</p>
<ul>
<li>init 容器总是运行到成功完成为止，返回码为成功。</li>
<li>每个init 容器都必须在下一个init容器启动之前成功完成</li>
</ul>
<p>如果Pod的init容器失败，Kubernetes会不断地重启该Pod，直到init容器成功为止。然而，如果Pod对应的restartPolicy为Never，它不会重新启动。</p>
<ul>
<li>initC与应用容器具备不同的镜像，可以把一些危险的工具放置在initC中进行使用。</li>
<li>initC多个之间是线性启动（串行执行）的，所以可以做一些延迟性操作。</li>
<li>initC无法定义readinessProbe（就绪探测），其他以外同应用容器定义无异。</li>
</ul>
<h3 id="4-2-探针"><a href="#4-2-探针" class="headerlink" title="4.2. 探针"></a>4.2. 探针</h3><p>探针是由kubelet对容器执行的定期诊断。要执行诊断，kubelet调用由容器实现的Handler。有三种类型的处理程序：</p>
<ul>
<li>ExecAction：在容器内执行指定命令。如果命令退出时返回码为0则认为诊断成功</li>
<li>TCPSocketAction：对指定端口上的容器的IP地址进行TCP检查。如果端口打开，则诊断被认为是成功的</li>
<li>HTTPGetAction：对指定的端口和路径上的容器的IP地址执行HTTP Get请求。如果响应的状态码大于等于200且小于400，则诊断被认为是成功的</li>
</ul>
<p>每次探测都将获得以下三种结果之一：</p>
<ul>
<li>成功：容器通过了诊断。</li>
<li>失败：容器未通过诊断。</li>
<li>未知：诊断失败，因此不会采取任何行动。</li>
</ul>
<h4 id="4-2-1-探针分类"><a href="#4-2-1-探针分类" class="headerlink" title="4.2.1 探针分类"></a>4.2.1 探针分类</h4><ul>
<li>startupProbe：启动探测，开始检测吗？</li>
<li>livenessProbe：存活探测，还活着吗</li>
<li>readinessProbe：就绪探测，准备提供服务了吗？</li>
</ul>
<h4 id="readinessProbe-就绪探针"><a href="#readinessProbe-就绪探针" class="headerlink" title="readinessProbe 就绪探针"></a>readinessProbe 就绪探针</h4><p>k8s通过添加就绪探针，解决尤其是在扩容时保证提供给用户的服务都是可用的。在进行pod扩容时，如果新建的pod还没准备就绪，那么它就不应该提供给用户访问，就绪探测可以让pod就绪后才加入到service中。</p>
<p>选项说明：</p>
<ul>
<li>initialDelaySeconds：容器启动后要等待多少秒后探针开始工作，单位“秒”，默认是0秒，最小值是0</li>
<li>periodSeconds：执行探测的时间间隔（单位是秒），默认为10s，单位“秒”，最小值1</li>
<li>timeoutSeconds：探针执行检测请求后，等待响应的超时时间，默认为1s，单位“秒”，最小值是1</li>
<li>successThreshold：探针检测失败后认为成功的最小连接成功次数，默认值为1。必须为1才能激活和启动。最小值为1</li>
<li>failurethreshold：探测失败的额重试次数，重试一定次数后将认为失败，默认值为3，最小值为1</li>
</ul>
<p>如果pod内部的容器不添加就绪探测，默认就绪。如果添加了就绪探测，只有通过就绪探测成功以后，才标记修改为就许状态。当前pod内的所有容器都就绪，才标记当前pod就绪。</p>
<ul>
<li>探测成功：将当前的容器标记为就绪</li>
<li>探测失败：静默</li>
<li>探测未知：静默</li>
</ul>
<h4 id="livenessProbe存活探针"><a href="#livenessProbe存活探针" class="headerlink" title="livenessProbe存活探针"></a>livenessProbe存活探针</h4><p>k8s通过添加存活探针，解决虽然活着但是已经死了的问题。</p>
<p>选项说明：</p>
<ul>
<li>initialDelaySeconds：容器启动后要等待多少秒后探针开始工作，单位“秒”，默认是0秒，最小值0</li>
<li>periodSeconds：执行探测的时间间隔（单位是秒），默认为10s，单位“秒”，最小值是1</li>
<li>timeoutSeconds：探针执行检测请求后，等待响应的超时时间，默认为1s，单位“秒”，最小值是1</li>
<li>successThreshold：探针检测失败后认为成功的最小连接成功次数，默认值为1。必须为1才能激活行业启动。最小值为1</li>
<li>failureThreshold：探测失败的重试次数，重试一定次数后将认为失败，默认值为3，最小值为1</li>
</ul>
<p>如果pod内部不指定存活探测，可能你会发送容器运行但是无法提供服务的情况</p>
<ul>
<li>成功：静默</li>
<li>失败：根据重启的策略进行重启的动作（重建）</li>
<li>未知：静默</li>
</ul>
<h4 id="startupProbe启动探针"><a href="#startupProbe启动探针" class="headerlink" title="startupProbe启动探针"></a>startupProbe启动探针</h4><p>k8s在1.16版本后增加startupProbe探针，主要解决在复杂的程序中readinessProbe、livenessProbe探针无法更好的判断程序是否启动、是否存活。</p>
<p>选项说明：</p>
<ul>
<li>initialDelaySeconds：容器启动后要等待多少秒后探针开始工作，单位“秒”，默认是0秒，最小值0</li>
<li>periodSeconds：执行探测的时间间隔（单位是秒），默认为10s，单位“秒”，最小值是1</li>
<li>timeoutSeconds：探针执行检测请求后，等待响应的超时时间，默认为1s，单位“秒”，最小值是1</li>
<li>successThreshold：探针检测失败后认为成功的最小连接成功次数，默认值为1。必须为1才能激活行业启动。最小值为1</li>
<li>failureThreshold：探测失败的重试次数，重试一定次数后将认为失败，默认值为3，最小值为1</li>
</ul>
<p>启动探针保障存活探针在执行的时候不会因为时间设定问题导致无限死亡或者延迟很长的情况</p>
<ul>
<li>成功：开始允许存活探测，就绪探测开始执行</li>
<li>失败：静默</li>
<li>未知：静默</li>
</ul>
<h3 id="4-3-钩子"><a href="#4-3-钩子" class="headerlink" title="4.3 钩子"></a>4.3 钩子</h3><p>Pod hook（钩子）是由k8s管理的kubelet发起的，当容器中的进程启动前或者容器中的进程终止之前运行，这是包含在容器的生命周期之中。可以同时为Pod中的所有容器都配置hook。启动后钩子，关闭前钩子</p>
<p>Hook的类型包括两种：</p>
<ul>
<li>exec：执行一段命令</li>
<li>HTTP：发送HTTP请求</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1  </span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line"> name: lifecycle-pod</span><br><span class="line"> labels:</span><br><span class="line">   app: lifecycle-pod</span><br><span class="line">spec:</span><br><span class="line"> containers:</span><br><span class="line"> - name: busybox-container</span><br><span class="line">   image: wangyanglinux/tools:busybox</span><br><span class="line">   command: [&quot;/bin/sh&quot;,&quot;-c&quot;,&quot;touch /tmp/live ; sleep 600; rm -rf /tmp/live; sleep 3600&quot;]</span><br><span class="line">   livenessProbe:</span><br><span class="line">     exec:</span><br><span class="line">       command: [&quot;test&quot;,&quot;-e&quot;,&quot;/tmp/live&quot;]</span><br><span class="line">     initialDelaySeconds: 1</span><br><span class="line">     periodSeconds: 3</span><br><span class="line">   lifecycle:</span><br><span class="line">     postStart:</span><br><span class="line">       httpGet:</span><br><span class="line">         host: 192.168.66.11</span><br><span class="line">         path: index.html</span><br><span class="line">         port: 1234</span><br><span class="line">     preStop:</span><br><span class="line">       httpGet:</span><br><span class="line">         host: 192.168.66.11</span><br><span class="line">         path: hostname.html</span><br><span class="line">         port: 1234</span><br><span class="line"> - name: myapp-container</span><br><span class="line">   image: wangyanglinux/myapp:v1.0</span><br><span class="line">   livenessProbe:</span><br><span class="line">     httpGet:</span><br><span class="line">       port: 80</span><br><span class="line">       path: /index.html</span><br><span class="line">     initialDelaySeconds: 1</span><br><span class="line">     periodSeconds: 3</span><br><span class="line">     timeoutSeconds: 3</span><br><span class="line">   readinessProbe:</span><br><span class="line">     httpGet:</span><br><span class="line">       port: 80</span><br><span class="line">       path: /index1.html</span><br><span class="line">     initialDelaySeconds: 1</span><br><span class="line">     periodSeconds: 3</span><br><span class="line"> initContainers:</span><br><span class="line"> - name: init-myservice</span><br><span class="line">   image: wangyanglinux/tools:busybox</span><br><span class="line">   command: [&#x27;sh&#x27;, &#x27;-c&#x27;, &#x27;until nslookup myservice; do echo waiting for myservice; sleep 2; done;&#x27;]</span><br><span class="line"> - name: init-mydb</span><br><span class="line">   image: wangyanglinux/tools:busybox</span><br><span class="line">   command: [&#x27;sh&#x27;, &#x27;-c&#x27;, &#x27;until nslookup mydb; do echo waiting for mydb; sleep 2; done;&#x27;]</span><br></pre></td></tr></table></figure>



<h2 id="五、Pod的控制器"><a href="#五、Pod的控制器" class="headerlink" title="五、Pod的控制器"></a>五、Pod的控制器</h2><p>在Kubernetes中运行了一系列控制器来确保集群的当前状态与期望状态保持一致，它们就是Kubernetes集群内部的管理控制中心或者说是“中心大脑”。例如，ReplicaSet控制器负责维护集群中运行的Pod数量；Node控制器负责监控节点的状态，并在节点出现故障时，执行自动化修复流程，确保集群始终处于预期的工作状态。</p>
<ul>
<li>ReplicationController、ReplicaSet</li>
<li>Deployment</li>
<li>DaemonSet</li>
<li>StateFulSet</li>
<li>Job&#x2F;CronJob</li>
<li>Horizontal Pod Autoscaling</li>
</ul>
<h3 id="5-1-ReplicationController和ReplicaSet"><a href="#5-1-ReplicationController和ReplicaSet" class="headerlink" title="5.1 ReplicationController和ReplicaSet"></a>5.1 ReplicationController和ReplicaSet</h3><p>ReplicationController（rc）用来确保容器应用的副本数始终保持在用户定义的副本数，即如果有容器异常退出，会自动创建新的Pod来替代；而如果异常多出来的容器也会自动回收；</p>
<p>在新版本的Kubernetes中建议使用ReplicaSet(rs)来取代ReplicationController。ReplicaSet和ReplicationController没有本质的不同，只是名字不一样，并且ReplicaSet支持集合式的selector；</p>
<p>RC控制器，保障当前的Pod数量与期望值一致</p>
<p>RS控制器，功能与RC控制器类似，但是多了标签选择的运算方式</p>
<h3 id="5-2-Deployment"><a href="#5-2-Deployment" class="headerlink" title="5.2 Deployment"></a>5.2 Deployment</h3><p>原理：通过 Deployment 控制器控制不同的 RS 再去创建 Pod</p>
<p>Deployment为Pod和ReplicaSet提供了一个声明式定义（declarative）方法，用来替代以前的ReplicationController来方便的管理应用。典型的应用场景包括：</p>
<ul>
<li>定义Deployment来创建Pod和ReplicaSet</li>
<li>滚动升级和回滚应用</li>
</ul>
<p><img src="https://raw.githubusercontent.com/cy77cc/pic-md/master/image-20250408145217802.png" alt="Deployment和RS的关系"></p>
<ul>
<li>扩容和缩容</li>
<li>暂停和继续Deployment</li>
</ul>
<h4 id="5-2-1-声明式和命令式"><a href="#5-2-1-声明式和命令式" class="headerlink" title="5.2.1 声明式和命令式"></a>5.2.1 声明式和命令式</h4><p>声明性的东西是对结果的陈述，表明意图而不是实现它的过程。在Kubernetes中，这就说“应该有一个包含三个Pod的ReplicaSet”。</p>
<p>命令式充当命令。声明式是被动的，而命令式是主动且直接的：“创建一个包含三个Pod的ReplicaSet”。</p>
<h4 id="5-2-2-replace与apply对比"><a href="#5-2-2-replace与apply对比" class="headerlink" title="5.2.2 replace与apply对比"></a>5.2.2 replace与apply对比</h4><h5 id="替换方式"><a href="#替换方式" class="headerlink" title="替换方式"></a>替换方式</h5><ul>
<li>kubectl replace：使用新的配置完全替换掉现有资源的配置。这意味着新配置将覆盖现有资源的所有字段和属性，包含未指定的字段，会导致整个资源的替换。</li>
<li>kubectl apply：使用新的配置部分地更新现有资源的配置。它会根据提供的配置文件或参数，只更新与新配置中不同的部分，而不会覆盖整个资源的配置。</li>
</ul>
<h5 id="字段级别的更新"><a href="#字段级别的更新" class="headerlink" title="字段级别的更新"></a>字段级别的更新</h5><ul>
<li>kubectl replace：由于是完全替换，所以会覆盖所有字段和属性，无论是否在新配置中指定。</li>
<li>kubectl apply：只更新与新配置中不同的字段和属性，保留未指定的字段不受影响。</li>
</ul>
<h5 id="部分更新"><a href="#部分更新" class="headerlink" title="部分更新"></a>部分更新</h5><ul>
<li>kubectl replace：不支持部分更新，它会替换整个资源的配置</li>
<li>kubectl apply：支持部分更新，只会更新新配置中发生变化的部分，保留未指定的部分不受影响</li>
</ul>
<h5 id="与其他配置的影响"><a href="#与其他配置的影响" class="headerlink" title="与其他配置的影响"></a>与其他配置的影响</h5><ul>
<li>kubectl replace：不考虑其他资源配置的状态，直接替换资源的配置。</li>
<li>kubectl apply：可以结合使用 -f 或 -k 参数，从文件或目录中读取多个资源配置，并根据当前集群中的资源状态进行更新。</li>
</ul>
<h4 id="5-2-3-常用命令"><a href="#5-2-3-常用命令" class="headerlink" title="5.2.3 常用命令"></a>5.2.3 常用命令</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">kubectl create -f deployment.yaml --record</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">根据yaml创建一个Deployment，--record参数可以记录命令，可以很方便的查看每次revision的变化</span></span><br><span class="line">-f 通过基于文件的创建，但是如果此文件描述的对象存在，即使文件描述的信息发生了改变，再次提交时也不会应用</span><br><span class="line"></span><br><span class="line">apply</span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">创建资源对象、修改资源对象</span></span><br><span class="line">	-f 基于文件创建，如果目标对象与文件本身发生改变，那么会根据文件的内容一一修改目标对象的属性（部分更新）</span><br><span class="line">replace</span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">创建资源对象、修改资源对象</span></span><br><span class="line">	-f 基于文件创建，如果目标对象与文件本身发生改变，那么会重建此对象（替代替换）</span><br><span class="line"></span><br><span class="line">kubectl scale deployment nginx-deployment --replicas 10 # 扩容，缩容都可以</span><br><span class="line">kubectl autoscale deployment nginx-deployment --min=10 --max=15 --cpu-percent=80  # 扩展缩容阈值</span><br><span class="line">kubectl set image deployment/nginx-deployment nginx-deployment-container=wangyanglinux/myapp:v2.0</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">回滚到上一个版本</span></span><br><span class="line">kubectl rollout undo deployment/nginx-deployment</span><br></pre></td></tr></table></figure>

<h4 id="5-2-4-更新策略"><a href="#5-2-4-更新策略" class="headerlink" title="5.2.4 更新策略"></a>5.2.4 更新策略</h4><p>Deployment 可以保证在升级时只有一定数量的 Pod 是 down 的。默认的，它会确保至少有比期望的 Pod 数量少一个是 up 状态（最多一个不可用）</p>
<p>Deployment 同时也可以确保只创建出超过期望数量一定数量的 Pod。默认的，他会确保最多比期望的 Pod 数量多一个的 Pod 是 up 的（最多 1 个 surge）</p>
<p>最多多25%，最多少25%（通过apps&#x2F;v1接口组创建的）</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">kubectl explain deploy.spec.strategy.type</span><br><span class="line">	Recreate  # 重建</span><br><span class="line">    RollingUpdate # 滚动更新</span><br><span class="line">    	maxSurge: # 指定超出副本数有几个，两种方式：1、指定数量 2、百分比</span><br><span class="line">    	maxUnavailable: # 最多有几个不可用</span><br></pre></td></tr></table></figure>

<h4 id="5-2-5-金丝雀部署"><a href="#5-2-5-金丝雀部署" class="headerlink" title="5.2.5 金丝雀部署"></a>5.2.5 金丝雀部署</h4><p>创建少量的新版本 Pod 给用户访问，如果没有问题再将所有的 Pod 都更新到新版本。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kubectl patch deploy deployment-demo -p &#x27;&#123;&quot;spec&quot;: &#123;&quot;strategy&quot;: &#123;&quot;rollingUpdate&quot;: &#123;&quot;maxSurge&quot;: 1, &quot;maxUnavailable&quot;: 0&#125;&#125;&#125;&#125;&#x27;</span><br><span class="line"></span><br><span class="line">kubectl patch deploy deployment-demo --patch &#x27;&#123;&quot;spec&quot;: &#123;&quot;template&quot;: &#123;&quot;spec&quot;: &#123;&quot;containers&quot;: [&#123;&quot;name&quot;: &quot;deployment-demo-container&quot;, &quot;image&quot;: &quot;wangyanglinux/myapp:v2.0&quot;&#125;]&#125;&#125;&#125;&#125;&#x27; &amp;&amp; kubectl rollout pause deploy deployment-demo</span><br></pre></td></tr></table></figure>

<h4 id="5-2-6-回滚命令"><a href="#5-2-6-回滚命令" class="headerlink" title="5.2.6 回滚命令"></a>5.2.6 回滚命令</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看的当前deployment的滚动更新状态</span></span><br><span class="line">kubectl rollout status deploy nginx-deployment</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看的当前deployment的滚动更新历史</span></span><br><span class="line">kubectl rollout history deployment/nginx-deployment</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">回滚到指定的revision版本</span></span><br><span class="line">kubectl rollout undo deployment/nginx-deployment --to-revision=2</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">暂停滚动更新</span></span><br><span class="line">kubectl rollout pause deployment/nginx-deployment</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">恢复滚动更新</span></span><br><span class="line">kubectl rollout resume deploy deployment-demo</span><br></pre></td></tr></table></figure>

<h4 id="5-2-7-清理策略"><a href="#5-2-7-清理策略" class="headerlink" title="5.2.7 清理策略"></a>5.2.7 清理策略</h4><p>可以通过设置<code>.spec.revisionHistoryLimit</code>项来指定 Deployment 最多保留多少 revision 历史记录。默认的会保留所有的 revision；如果将该项设置为0，Deployment 就不允许回滚了。</p>
<h3 id="5-3-DaemonSet"><a href="#5-3-DaemonSet" class="headerlink" title="5.3 DaemonSet"></a>5.3 DaemonSet</h3><p>DaemonSet 确保全部（或者一些）Node 上运行一个 Pod 的副本。当有 Node 加入集群时，也会为他们新增一个 Pod。当有 Node 从集群移除时，这些 Pod 也会被回收。删除 DaemonSet 将会删除它创建的所有 Pod。</p>
<p>使用 DaemonSet 的一些典型用法：</p>
<ul>
<li>运行集群存储 daemon，例如在每个 Node 上运行 glusterd、ceph</li>
<li>在每个 Node 上运行日志收集 daemon，例如 fluentd、logstash</li>
<li>在每个 Node 上运行监控 daemon，例如 Prometheus Node Exporter、collectd、Datadog 代理、New Relic 代理，或 Ganglia gmond</li>
</ul>
<h3 id="5-4-Job"><a href="#5-4-Job" class="headerlink" title="5.4 Job"></a>5.4 Job</h3><p>Job 负责批处理任务，即仅执行一次的任务，它保证批处理任务的一个或多个 Pod 成功结束，保障批处理任务一个或多个成功为止。</p>
<p>特殊说明：</p>
<ul>
<li>spec.template 格式同 Pod</li>
<li>RestartPolicy 仅支持 Never 或 OnFailure</li>
<li>单个 Pod 时，默认 Pod 成功运行后 Job即结束</li>
<li><code>.spec.completions</code> 标志 Job结束需要成功运行的 Pod 个数，默认为 1</li>
<li><code>.spec.parallelism</code> 标志并行运行的 Pod 的个数，默认为 1</li>
<li><code>.spec.activeDeadlineSeconds</code> 标志失败 Pod 的重试最大时间，超过这个时间不会继续重试</li>
</ul>
<h3 id="5-5-CronJob"><a href="#5-5-CronJob" class="headerlink" title="5.5 CronJob"></a>5.5 CronJob</h3><p>Cron Job管理基于时间的 Job，即：</p>
<ul>
<li>在给定时间点只运行一次</li>
<li>周期性地在给定时间点运行</li>
</ul>
<p>典型用法：</p>
<ul>
<li>在给定的时间点调度 Job 运行</li>
<li>创建周期性运行的 Job，例如：数据库备份、发送邮件</li>
</ul>
<p>spec下面的参数</p>
<ul>
<li><code>.spec.schedule</code>：调度，必需字段，指定任务运行周期，格式通 Cron</li>
<li><code>.spec.jobTemplate</code>：Job 模板，必需字段，指定需要运行的任务，格式同 Job</li>
<li><code>.spec.startingDeadlineSeconds</code>：启动 Job 的期限（秒级别），该字段是可选的。如果因为任何原因而错过了被调度的时间，那么错过执行时间的 Job 将被认为是失败的。如果没有指定，则没有期限。</li>
<li><code>.spec.concurrencyPolicy</code>：并发策略，该字段也是可选的。它制定了如何处理被 Cron Job创建的 Job 的并发执行。只允许指定下面策略中的一种：<ul>
<li><code>Allow</code>（默认）：允许并发运行 Job</li>
<li><code>Forbid</code>：禁止并发运行，如果前一个还没有完成，则直接跳过下一个</li>
<li><code>Replace</code>：取消当前正在运行的 Job，用一个新的来替换</li>
<li>注意，当前策略只能应用于同一个 Cron Job 创建的 Job。如果存在多个 Cron Job，它们创建的 Job 之间总是运行并发执行。</li>
</ul>
</li>
<li><code>.spec.suspend</code>：挂起，该字段也是可选的。如果设置为 <code>true</code>，后续所有执行都会被挂起。它对已经执行的 Job 不起作用。默认值为 <code>false</code></li>
<li><code>.spec.successfulJobsHistoryLimit</code> 和 <code>.spec.failedJobsHistoryLimit</code>：历史限制，是可选的字段。它们制定了可以保留多少完成和失败的 Job。默认情况下，它们分别设置为 3 和 1。设置限制的值为 0，相关类型的 Job 完成后将不会被保留</li>
</ul>
<p><strong>周期性的创建 Job，典型的场景：数据库的周期性备份。。。</strong></p>
<p>创建 Job 操作应该是幂等的</p>
<h3 id="5-6-StatefulSet"><a href="#5-6-StatefulSet" class="headerlink" title="5.6 StatefulSet"></a>5.6 StatefulSet</h3><p>有序创建有序回收</p>
<p>数据持久化 Pod 级别 &gt; Pod绑定 pvc &gt; pvc 绑定 pv &gt; pv 绑定 nfs</p>
<p>稳定的网络访问方式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PodName.headlessSvcName.nsName.svc.domainName.</span><br><span class="line">statefulSetName-num.headlessSvcName.nsName.svc.domainName.</span><br></pre></td></tr></table></figure>





<h2 id="六、Service"><a href="#六、Service" class="headerlink" title="六、Service"></a>六、Service</h2><p>Kubernetes <code>Service</code> 定义了这样一种很抽象：一个 Pod 的逻辑分组，一种可以访问它们的策略 ——通过称为微服务。这一组 Pod 能够被 Service 访问到，通常是通过 Label Selector</p>
<p>在 Kubernetes 集群中，每个 Node 运行一个 <code>kube-proxy</code> 进程。<code>kube-proxy</code> 负责为 <code>Service</code> 实现了一种VIP（虚拟IP）的形式</p>
<p>在Kubernetes v1.0 版本，代理完全在userspace。在v1.1版本，新增了 iptables 代理，但并不是默认的运行模式。从v1.2起，默认即使 iptables 代理。在v1.8中添加了ipvs代理。</p>
<h3 id="6-1-Service-类型"><a href="#6-1-Service-类型" class="headerlink" title="6.1 Service 类型"></a>6.1 Service 类型</h3><ul>
<li>ClusterIP：默认类型，自动分配一个仅 Cluster 内部可以访问的虚拟IP（集群内部使用）</li>
<li>NodePort：在 ClusterIP 基础上为 Service 在每台机器上绑定一个端口，这样就可以通过 &lt;NodeIP&gt;:&lt;NodePort&gt; 来访问服务（暴露到集群外部）</li>
<li>LoadBalancer：在 NodePort 的基础上，借助 cloud provider 创建一个外部负载均衡器，并将请求转发到 &lt;NodeIP&gt;:&lt;NodePort&gt;</li>
<li>ExternalName：把集群外部的服务引入到集群内部来，在集群内部直接使用。没有任何类型代理被创建，这只有 Kubernetes 1.7 或更高版本的 kube-dns 才支持。（别名）</li>
</ul>
<h4 id="6-1-1-ClusterIP"><a href="#6-1-1-ClusterIP" class="headerlink" title="6.1.1 ClusterIP"></a>6.1.1 ClusterIP</h4><p>svc DNS 域名</p>
<p>svcName.nsName.svc.domainName.</p>
<p>​	domainName cluster.local</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">internalTrafficPolicy 参数：</span><br><span class="line">	Cluster: 访问集群内的所有pod</span><br><span class="line">	Local: 仅限访问本机内的Pod</span><br></pre></td></tr></table></figure>

<h4 id="6-1-2-NodePort"><a href="#6-1-2-NodePort" class="headerlink" title="6.1.2 NodePort"></a>6.1.2 NodePort</h4><p>暴露集群内部的服务给外部访问</p>
<h4 id="6-1-3-ExternalName"><a href="#6-1-3-ExternalName" class="headerlink" title="6.1.3 ExternalName"></a>6.1.3 ExternalName</h4><p>ExternalName Service 是 Service 的特例，它没有 selector，也没有定义任何的端口和 Endpoint。相反的，对于运行在集群外部的服务，它通过返回该外部服务的别名这种方式来提供服务。</p>
<h3 id="6-3-Endpoint"><a href="#6-3-Endpoint" class="headerlink" title="6.3 Endpoint"></a>6.3 Endpoint</h3><p>Kubernetes 中的 Service，它定义了一组 Pods 的逻辑集合和一个用于访问它们的策略。一个 Service 的目标 Pod 集合通常是由 Label Selector 来决定的 。</p>
<p>Endpoints 是一组实际服务的端点集合。一个 Endpoint 是一个可被访问的服务端点，即一个状态为 running 的 Pod 的可访问端点。一般 Pod 都不是一个独立存在，所以一组 Pod 的端点何在一起称为 Endpoints。只有被 Service Selector 匹配选中并且状态为 Running 的才会被加入到和 Service 同名的 Endpoints 中。</p>
<ul>
<li>自动关联体系：配置 selector</li>
<li>手动关联体系：无配置 selector</li>
</ul>
<h2 id="七、存储"><a href="#七、存储" class="headerlink" title="七、存储"></a>七、存储</h2><h3 id="7-1-存储各类特性"><a href="#7-1-存储各类特性" class="headerlink" title="7.1 存储各类特性"></a>7.1 存储各类特性</h3><ul>
<li>元数据<ul>
<li>configMap：用于保存配置数据（明文）</li>
<li>Secret：用于保存敏感性数据（编码）</li>
<li>Downward API：容器在运行时从 Kubernetes API 服务器获取有关它们自身的信息</li>
</ul>
</li>
<li>真实数据<ul>
<li>Volume：用于存储临时或者持久性数据</li>
<li>PersistentVolume：申请制的持久化存储</li>
</ul>
</li>
</ul>
<h3 id="7-2-configMap"><a href="#7-2-configMap" class="headerlink" title="7.2 configMap"></a>7.2 configMap</h3><p>configMap 功能在Kubernetes 1.2 版本中引入，许多应用程序会从配置文件、命令行参数或环境变量中读取配置信息。configMap API 给我们提供了向容器中注入配置信息的机制，configMap 可以被用来保存单个属性，也可以用来保存整个配置文件或者 JSON 二进制等对象。</p>
<h4 id="7-2-1-创建"><a href="#7-2-1-创建" class="headerlink" title="7.2.1 创建"></a>7.2.1 创建</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl create configmap game-config --from-file=hongfu.file</span><br><span class="line">kubectl create configmap literal-config --from-literal=name=dave --from-literal=password=pass</span><br></pre></td></tr></table></figure>

<h4 id="7-2-2-热更新"><a href="#7-2-2-热更新" class="headerlink" title="7.2.2 热更新"></a>7.2.2 热更新</h4><p>更新 configMap 可以更改挂载到 Pod 上的文件，方式是注入，在很多应用中配置文件的更改并不一定会使得 Pod 内部应用的更新，因此可以利用滚动更新的策略重新创建 Pod，达到更新的效果。</p>
<p>更新 configMap 后：</p>
<ul>
<li>使用该 configMap 挂载的 Env 不会同步更新</li>
<li>使用该 configMap 挂载的 volume 中的数据需要一段时间才能同步更新</li>
</ul>
<h4 id="7-2-3-不可改变-immutable"><a href="#7-2-3-不可改变-immutable" class="headerlink" title="7.2.3 不可改变 immutable"></a>7.2.3 不可改变 immutable</h4><p>Kubernetes 给不可改变的 configMap 和 Secret 提供了一种可选配置，可以设置各个 Secret 和 configMap 为不可变的。对于大量使用 configMap 的集群，禁止变更它们的数据有下列好处：</p>
<ul>
<li>防止以外（或非预期的）更新导致应用程序中断</li>
<li>通过将 configMap 标记为不可变来关闭 kube-apiserver 对其的监视，从而显著降低 kube-apiserver 的负载，提升集群性能。</li>
</ul>
<p>configMap 如果修改为不可改变的状态，是不允许回退的，是不可逆的。可以删除此 configMap，然后重新创建一个没有不可改变字段的 configMap，防止出现一些错误的修改。</p>
<h3 id="7-3-Secret"><a href="#7-3-Secret" class="headerlink" title="7.3 Secret"></a>7.3 Secret</h3><p>编码而来的安全</p>
<p>Secret 对象类型用来保存敏感信息，例如密码，OAuth 令牌和 SSH 密钥。将这些信息放在 Secret 中比放在 Pod 的定义或者 容器镜像 中来说更加安全和灵活。</p>
<p><img src="https://raw.githubusercontent.com/cy77cc/pic-md/master/image-20250410164840969.png" alt="Secret分类"></p>
<h4 id="7-3-1-特性"><a href="#7-3-1-特性" class="headerlink" title="7.3.1 特性"></a>7.3.1 特性</h4><ul>
<li>Kubernetes 通过仅仅将 Secret 分发到需要访问 Secret 的 Pod 所在的机器节点来保障其安全性</li>
<li>Secret 只会存储在节点的内存中，永不写入物理存储，这样从节点删除 Secret 时就不需要擦除磁盘数据</li>
<li>从 Kubernetes 1.7 版本开始，etcd 会以加密形式存储 Secret，一定程度的保证了 Secret 安全性</li>
</ul>
<h4 id="7-3-2-Opaque"><a href="#7-3-2-Opaque" class="headerlink" title="7.3.2 Opaque"></a>7.3.2 Opaque</h4><p>当 Secret 配置文件中未作显式设定时，默认的 Secret 类型是 Opaque。当你使用 kubectl 来创建一个 Secret 时，会使用 generic 子命令来表明要创建的是一个 Opaque 类型的 Secret</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Secret</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">mysecret</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">Opaque</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="attr">password:</span> <span class="string">cGFzc3dk</span></span><br><span class="line">  <span class="attr">username:</span> <span class="string">YWRtaW4=</span></span><br></pre></td></tr></table></figure>



<h3 id="7-4-Downward-API"><a href="#7-4-Downward-API" class="headerlink" title="7.4 Downward API"></a>7.4 Downward API</h3><p>Downward API 是 Kubernetes 中的一个功能，它允许容器在运行时 从 Kubernetes API 服务器获取有关它们自身的信息。这些信息可以作为容器内部的环境变量或文件注入到容器中，以便可以获取有关其运行环境的各种信息，如 Pod 名称、命名空间、标签等。</p>
<ul>
<li>提供容器元数据</li>
<li>动态配置</li>
<li>与 Kubernetes 环境集成</li>
</ul>
<p>Downward API 提供了一种简单的方式，将 Pod 和容器的元数据传递他给它们内部运行的进程。但这种方式其实仅仅暴露了一个 Pod 自身的元数据传递给在它们内部运行的进程。但是这种方式其实仅仅可以暴露一个 Pod 自身的元数据，而且只可以暴露部分元数据。</p>
<h3 id="7-5-volume"><a href="#7-5-volume" class="headerlink" title="7.5 volume"></a>7.5 volume</h3><p>容器磁盘上的文件的生命周期是短暂的，这就使得在容器中运行重要应用时会出现一些问题。首先，当容器崩溃时，kubelet 会重启（重建）它，但是容器中的文件将丢失——容器以干净的状态（镜像最初的状态）重新启动。其次，在 Pod 中同时运行多个容器时，这些容器之间通常需要共享文件。Kubernetes 中的 Volume 抽象就很好地解决了这些问题。</p>
<h4 id="7-5-1-emptyDir"><a href="#7-5-1-emptyDir" class="headerlink" title="7.5.1 emptyDir"></a>7.5.1 emptyDir</h4><p>当 Pod 被分配给节点时，首先创建 emptyDir 卷，并且只要该 Pod 在该节点上运行，该卷就会存在。正如卷的名字所述，它最初是空的。Pod 中的容器可以读取和写入 emptyDir 卷中的相同文件，尽管改卷可以挂载到每个容器中的相同或不同路径上。当出于任何原因从节点中删除 Pod 时，emptyDir 中的数据将被永久删除</p>
<p>容器崩溃不会从节点中移除 Pod，因此 emptydir 卷中的数据在容器崩溃时是安全的</p>
<p>emptyDir 的用法有：</p>
<ul>
<li>暂存空间，例如用于磁盘的合并排序、用作长时间计算崩溃恢复时的检查点</li>
<li>Web 服务器容器提供数据时，保存内容管理器容器提取的文件</li>
</ul>
<p>在 kubelet 的工作目录（root-dir 参数控制），默认为 <code>/var/lib/kubelet</code>，会为每个使用了 <code>emptyDir: &#123;&#125;</code> 的 Pod 创建一个目录，格式如 <code>/var/lib/kubelet/pods/&#123;podid&#125;/volumes/kubernetes.io~empty-dir/</code>，所有放在 emptyDir 中的数据，最终都是落在了 node 的上述路径中</p>
<h4 id="7-5-2-hostPath"><a href="#7-5-2-hostPath" class="headerlink" title="7.5.2 hostPath"></a>7.5.2 hostPath</h4><p>hostPath 卷将主机节点的文件系统中的文件或目录挂载到集群中</p>
<p>hostPath 用途如下：</p>
<ul>
<li>运行需要访问 Docker 内部的容器；使用 <code>/var/lib/docker</code> 的 <code>hostPath</code></li>
<li>在容器中运行 cAdvisor；使用 <code>/dev/cgroups</code> 的 <code>hostPath</code></li>
<li>允许 Pod 指定给定的 hostPath 是否应该在 Pod 运行之前存在，是否应该创建，以及它应该以什么形式存在</li>
</ul>
<p>除了所需的 <code>path</code> 属性之外，用户还可以为 <code>hostPath</code> 卷指定 <code>type</code></p>
<p><strong>类型</strong></p>
<table>
<thead>
<tr>
<th>值</th>
<th>行为</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>空字符串（默认）用于向后兼容，意味着在挂载 hostPath 卷之前不会执行任何检查</td>
</tr>
<tr>
<td>DirectoryOrCreate</td>
<td>如果在给定的路径上没有任何东西存在，那么将根据需要在那么创建一个空目录，权限设置为 0755，与 Kubelet 具有相同的组合所有权</td>
</tr>
<tr>
<td>Directory</td>
<td>给定的路径下必须存在目录</td>
</tr>
<tr>
<td>FileOrCreate</td>
<td>如果在给定的路径上没有任何东西存在，那么会根据需要创建一个空文件，权限设置为 0644，与 Kubelet 具有相同的组合所有权</td>
</tr>
<tr>
<td>File</td>
<td>给定的路径下必须存在文件</td>
</tr>
<tr>
<td>Socket</td>
<td>给定的路径下必须存在 UNIX 套接字</td>
</tr>
<tr>
<td>CharDevice</td>
<td>给定的路径下必须存在字符设备</td>
</tr>
<tr>
<td>BlockDevice</td>
<td>给定的路径下必须存在块设备</td>
</tr>
</tbody></table>
<h3 id="7-6-PV-PVC"><a href="#7-6-PV-PVC" class="headerlink" title="7.6 PV&#x2F;PVC"></a>7.6 PV&#x2F;PVC</h3><img src="https://raw.githubusercontent.com/cy77cc/pic-md/master/image-20250411104731185.png" alt="PV/PVC之间的关系" style="zoom: 50%;" />

<p>PV&#x2F;PVC 关联条件</p>
<ul>
<li>容量：PV 的值不小于 PVC 要求，可以大于最好一致</li>
<li>读写策略：完全匹配<ul>
<li>单节点读写 - ReadWriteOnce - RWO</li>
<li>多节点只读 - ReadOnlyMany - ROX</li>
<li>多借点读写 - ReadWriteMany - RWX</li>
</ul>
</li>
<li>存储类：PV 的类与 PVC 的类必须一致，不存在包容降级关系</li>
</ul>
<h4 id="PV-PVC-回收策略"><a href="#PV-PVC-回收策略" class="headerlink" title="PV&#x2F;PVC - 回收策略"></a>PV&#x2F;PVC - 回收策略</h4><ul>
<li>Retain（保留）：手动回收</li>
<li>Recycle（回收）：基本擦除（<code>rm -rf /thevolume/*</code>）</li>
<li>Delete（删除）：关联的存储资产（例如 AWS EBS、GCE PD、Azure Dis 和 OpenStack Cinder 卷）将被删除</li>
</ul>
<p>当前，只有 NFS 和 HostPath 支持回收策略。AWS EBS、GCE PD、Azure Disk 和 Cinder 卷支持删除策略</p>
<h4 id="PV-PVC-状态"><a href="#PV-PVC-状态" class="headerlink" title="PV&#x2F;PVC - 状态"></a>PV&#x2F;PVC - 状态</h4><ul>
<li>Available（可用）：一块空闲资源还没有被任何声明所绑定</li>
<li>Bound（已绑定）：卷已经被声明绑定</li>
<li>Released（已释放）：声明被删除，但是资源还未被集群重新声明</li>
<li>Failed（失败）：该卷的自动回收失败</li>
</ul>
<p>命令行会显示绑定到 PV 的 PVC 的名称</p>
<h3 id="7-7-storageClass"><a href="#7-7-storageClass" class="headerlink" title="7.7 storageClass"></a>7.7 storageClass</h3><p>一种动态的申请存储的机制</p>
<p>StorageClass 是一种资源对象，用于定义持久卷（Persistent Volumes）的动态供给（Dynamic Provisioning）策略。StorageClass 允许管理员定义不同类型的存储，并指定如何动态创建持久卷以供应程序使用。这使得 Kubernetes 集群中的存储管理更加灵活和自动化</p>
<h2 id="八、调度器"><a href="#八、调度器" class="headerlink" title="八、调度器"></a>八、调度器</h2><h3 id="8-1-概念"><a href="#8-1-概念" class="headerlink" title="8.1 概念"></a>8.1 概念</h3><p>scheduler 是作为单独的程序运行的，启动之后会一直监听 API Server，获取 <code>PodSpec.NodeName</code> 为空的 Pod，对每个 Pod 都会创建一个 binding，表明该 Pod 应该放到哪个节点上。</p>
<p>概念听起来是非常简单的，但有很多要考虑的问题：</p>
<ul>
<li>公平：如何保证每个节点都能被分配资源</li>
<li>资源高效利用：集群所有资源最大化被使用</li>
<li>效率：调度的性能要好，能够尽快地对大批量的 Pod 完成调度工作</li>
<li>灵活：允许用户根据自己的需求控制调度的逻辑</li>
</ul>
<p>除了 Kubernetes 自带的调度器，也可以编写自己的调度器。通过 <code>spec.schedulername</code> 参数指定调度器的名字，可以为 Pod 选择某个调度器进行调度。</p>
<p><strong>过程</strong></p>
<p>调度分为几个部分：首先是过滤掉不满足条件的节点，这个过程称为<code>预选</code>，然后对通过预选的节点按照优先级排序，这个是<code>优选</code>；最后从中选择优先级最高的节点。如果中间任何一步骤有错误，就直接返回错误。</p>
<h3 id="8-2-亲和性"><a href="#8-2-亲和性" class="headerlink" title="8.2 亲和性"></a>8.2 亲和性</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 软亲和性，偏好满足条件的节点</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">node-affinity-preferred</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">node-affinity-preferred</span></span><br><span class="line"><span class="attr">spec:</span> </span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">node-affinity-preferred-pod</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">wangyanglinux/myapp:v1.0</span></span><br><span class="line">  <span class="comment"># 亲和性</span></span><br><span class="line">  <span class="attr">affinity:</span></span><br><span class="line">  <span class="comment"># 节点亲和性</span></span><br><span class="line">    <span class="attr">nodeAffinity:</span></span><br><span class="line">    <span class="comment"># 软策略</span></span><br><span class="line">      <span class="attr">preferredDuringSchedulingIgnoreDuringExecution:</span></span><br><span class="line">      <span class="comment"># 权重</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">weight:</span> <span class="number">1</span></span><br><span class="line">      <span class="comment"># 偏好</span></span><br><span class="line">        <span class="attr">preference:</span></span><br><span class="line">          <span class="attr">matchExpressions:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">domain</span></span><br><span class="line">            <span class="attr">operator:</span> <span class="string">In</span></span><br><span class="line">            <span class="attr">values:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">xinxianghf</span></span><br><span class="line"><span class="comment"># 硬亲和性，必须满足条件</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">node-affinity-required</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">node-affinity-required</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">node-affinity-required-pod</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">wangyanglinux/myapp:v1.0</span></span><br><span class="line">  <span class="attr">affinity:</span></span><br><span class="line">    <span class="attr">nodeAffinity:</span></span><br><span class="line">      <span class="attr">requiredDuringSchedulingIgnoredDuringExecution:</span></span><br><span class="line">        <span class="attr">nodeSelectorTerms:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">matchExpressions:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">kubernetes.io/hostname</span></span><br><span class="line">            <span class="attr">operator:</span> <span class="string">In</span></span><br><span class="line">            <span class="attr">values:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">k8s-node4</span></span><br></pre></td></tr></table></figure>

<p>pod亲和性&#x2F;反亲和性，希望和哪个 Pod 在（不在）同一个节点</p>
<p>希望创建的 Pod 和目标 Pod 在同一个拓扑域下，匹配顺序是，首先查找目标 Pod 的拓扑域，然后通过调度策略调度到目标 Pod 拓扑域下的任一节点</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-aff-prefer</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">pod-aff</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">myapp</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">wangyanglinux/myapp:v1.0</span></span><br><span class="line">  <span class="attr">affinity:</span></span><br><span class="line">    <span class="attr">podAffinity:</span></span><br><span class="line">      <span class="attr">preferredDuringSchedulingIgnoredDuringExecution:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">weight:</span> <span class="number">1</span></span><br><span class="line">        <span class="attr">podAffinityTerm:</span></span><br><span class="line">          <span class="attr">labelSelector:</span></span><br><span class="line">            <span class="attr">matchExpressions:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">app</span></span><br><span class="line">              <span class="attr">operator:</span> <span class="string">In</span></span><br><span class="line">              <span class="attr">values:</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">pod-1</span></span><br><span class="line">          <span class="attr">topologyKey:</span> <span class="string">kubernetes.io/hostname</span></span><br><span class="line">          </span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-aff-required</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">pod-aff</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">myapp</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">wangyanglinux/myapp:v1.0</span></span><br><span class="line">  <span class="attr">affinity:</span></span><br><span class="line">    <span class="attr">podAffinity:</span></span><br><span class="line">      <span class="attr">requiredDuringSchedulingIgnoredDuringExecution:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">labelSelector:</span></span><br><span class="line">          <span class="attr">matchExpressions:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">app</span></span><br><span class="line">            <span class="attr">operator:</span> <span class="string">In</span></span><br><span class="line">            <span class="attr">values:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">pod-1</span></span><br><span class="line">        <span class="attr">topologyKey:</span> <span class="string">kubernetes.io/hostname</span></span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/cy77cc/pic-md/master/image-20250412143958462.png" alt="image-20250412143958462"></p>
<h3 id="8-3-污点和容忍"><a href="#8-3-污点和容忍" class="headerlink" title="8.3 污点和容忍"></a>8.3 污点和容忍</h3><h4 id="8-3-1-污点"><a href="#8-3-1-污点" class="headerlink" title="8.3.1 污点"></a>8.3.1 污点</h4><p>Taint 和 toleration 相互配合，可以用来避免 Pod 被分配到不合适的节点上。每个节点上都可以应用一个或多个 taint，这表示对于那些不能容忍这些 taint 的 Pod，是不会被该节点接受的。如果将 toleration 应用于 Pod 上，则表示这些 Pod 可以（但不要求）被调度到具有匹配 taint 的节点上。</p>
<p>每个污点有一个 key 和 value 作为污点的标签，其中 value 可以为空，effect 描述污点的作用。当前 taint effect 支持如下三个选项：</p>
<ul>
<li>NoSchedule：表示 k8s 不会将 Pod 调度到具有该污点的 Node 上。</li>
<li>PreferNoSchedule：表示 k8s 会尽量避免将 Pod 调度到具有该污点的 Node 上</li>
<li>NoExecute：表示 k8s 不会将 Pod 调度到具有该污点的 Node 上，同时会将 Node 上已经存在的 Pod 驱逐出去。（节点更新、物理机更新损坏等情况）</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">添加污点</span></span><br><span class="line">kubectl taint node k8s-master computeengine=gpu:NoSchedule（key=value:effect）</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除污点</span></span><br><span class="line">kubectl taint node k8s-master computeengine=gpu:NoSchedule-</span><br></pre></td></tr></table></figure>

<h4 id="8-3-2-容忍"><a href="#8-3-2-容忍" class="headerlink" title="8.3.2 容忍"></a>8.3.2 容忍</h4><p>设置了污点的 Node 将根据 taint 的 effect：NoSchedule、PreferNoSchedule、NoExecute 和 Pod 之间产生互斥的关系，Pod 将在一定程度上不会被调度到 Node 上。但我们可以在 Pod 上设置容忍（toleration），意思是设置了容忍的 Pod 将可以容忍污点的存在，可以被调度到存在污点的 Node 上</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">tolerations:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">key:</span> <span class="string">key1</span></span><br><span class="line">  <span class="attr">operator:</span> <span class="string">Equal</span></span><br><span class="line">  <span class="attr">value:</span> <span class="string">value1</span></span><br><span class="line">  <span class="attr">effect:</span> <span class="string">NoSchedule</span></span><br><span class="line">  </span><br><span class="line"><span class="attr">tolerations:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">key:</span> <span class="string">key1</span></span><br><span class="line">  <span class="attr">operator:</span> <span class="string">Equal</span></span><br><span class="line">  <span class="attr">value:</span> <span class="string">value1</span></span><br><span class="line">  <span class="attr">effect:</span> <span class="string">NoExecute</span></span><br><span class="line">  <span class="attr">tolerationSeconds:</span> <span class="number">3600</span></span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<p>1、当不指定 value 时，表示容忍所有的污点 value</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">key:</span> <span class="string">key2</span></span><br><span class="line">  <span class="attr">operator:</span> <span class="string">Exists</span></span><br><span class="line">  <span class="attr">effect:</span> <span class="string">NoSchedule</span></span><br></pre></td></tr></table></figure>

<p>2、当不指定 key 值时，表示容忍所有的污点 key</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">tolerations:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">operator:</span> <span class="string">Exists</span></span><br></pre></td></tr></table></figure>

<p>3、当不指定 effect 值时，表示容忍所有的污点作用</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">tolerations:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">key:</span> <span class="string">key</span></span><br><span class="line">  <span class="attr">operator:</span> <span class="string">Exists</span></span><br></pre></td></tr></table></figure>

<p>4、有多个 Master 存在时，防止资源浪费，可以如下设置</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl taint nodes NodeName node-role.kubernetes.io/master=:PreferNoSchedule</span><br></pre></td></tr></table></figure>

<h3 id="8-4-固定节点调度"><a href="#8-4-固定节点调度" class="headerlink" title="8.4 固定节点调度"></a>8.4 固定节点调度</h3><p>通过设置 <code>pod.spec.nodeName</code>将 Pod 直接调度到指定的 Node 节点上，会跳过 Scheduler 的调度策略，该匹配规则是强制匹配，可以跳过污点</p>
<p>通过<code>pod.spec.nodeSelector</code> 标签选择机制，有调度器调度策略匹配 label，而后调度 Pod 到目标节点，该匹配规则属于强制约束，不能跳过污点</p>
<h2 id="九、安全机制"><a href="#九、安全机制" class="headerlink" title="九、安全机制"></a>九、安全机制</h2><p>Kubernetes 作为一个分布式集群的管理工具，保证集群的安全性是其一个重要的任务。API Server 是集群内部各个组件通信的中间，也是外部控制的入口。所以 Kubernetes 的安全机制基本就是围绕保护 API Server 来设计的。</p>
<img src="https://raw.githubusercontent.com/cy77cc/pic-md/master/image-20250412155644138.png" alt="image-20250412155644138" style="zoom: 50%;" />

<h3 id="9-1-认证"><a href="#9-1-认证" class="headerlink" title="9.1 认证"></a>9.1 认证</h3><h4 id="9-1-1-类型"><a href="#9-1-1-类型" class="headerlink" title="9.1.1 类型"></a>9.1.1 类型</h4><ul>
<li>HTTP Token 认证：通过一个 Token 来识别合法用户<ul>
<li>HTTP Token 的认证是用一个很长的特殊编码方式并且难以被模仿的字符串 - Token 来表达客户的一种方式。Token 是一个很长并且很复杂的字符串，每一个 Token 对应一个用户名存储在 API Server 能访问的文件中。当客户端发起 API 调用请求时，需要在 HTTP Header 里放入 Token。</li>
</ul>
</li>
<li>HTTP Base 认证：通过 用户名+密码 的方式认证<ul>
<li>用户名+密码：用 BASE64 算法进行编码后的字符串放在 HTTP Request 中的 Heather Authorization 域里发送给服务端，服务端收到后进行编码，获取用户名及密码</li>
</ul>
</li>
<li>最严格的 HTTPS 证书认证：基于 CA 根证书签名的客户端身份认证方式</li>
</ul>
<p><img src="https://raw.githubusercontent.com/cy77cc/pic-md/master/image-20250412190857131.png" alt="image-20250412190857131"></p>
<p>apiserver 需要认证的类型</p>
<p>组件</p>
<ul>
<li>无需加密，基于 kubeadm 部署与 ApiServer 处于同一台机器，通过 <code>127.0.0.1</code> 访问<ul>
<li>Controller Manager、Scheduler</li>
</ul>
</li>
<li>需要加密的<ul>
<li>kubelet（证书自动颁发）、kube-proxy、kubectl（证书手动颁发）</li>
</ul>
</li>
</ul>
<p>Pod，通过 SA 认证</p>
<h4 id="9-1-2-ServiceAccount"><a href="#9-1-2-ServiceAccount" class="headerlink" title="9.1.2 ServiceAccount"></a>9.1.2 ServiceAccount</h4><p>Pod 中的容器访问 API server。因为 Pod 的创建、销毁是动态的，所以要为它手动生成证书就不可行了，Kubernetes 使用 ServiceAccount 解决 Pod 访问 API Server 的认证问题。</p>
<p>Kubernetes 设计了一种资源对象叫做 Secret，分为两类，一种是用于 ServiceAccount 的 service-account-token，另一种是用于保存用户自定义保密信息的 Opaque。ServiceAccount 中用到包含三个部分：Token、ca.crt、namespace</p>
<ul>
<li>Token 是使用 API Server 私钥签名的 JWT 。用于访问 API Server 时，Server 端认证。</li>
<li>ca.crt，根证书。用于 Client 端验证 API Server 发送的证书</li>
<li>namespace，表示这个 service-account-token 的作用域命名空间</li>
</ul>
<p>默认情况下，每个 namespace 都会有一个 ServiceAccount，如果 Pod 在创建时没有指明 ServiceAccount，就会使用 Pod 所属 namespace 的 ServiceAccount</p>
<h3 id="9-2-鉴权"><a href="#9-2-鉴权" class="headerlink" title="9.2 鉴权"></a>9.2 鉴权</h3><h4 id="9-2-1-类型"><a href="#9-2-1-类型" class="headerlink" title="9.2.1 类型"></a>9.2.1 类型</h4><p>认证的过程只是用于通信的双方相互确认对方是可信的，可以相互通信。而鉴权是确定请求方有哪些资源的权限。API Server 目前支持以下几种授权策略（通过 API Server 的启动参数“–authorization-mode”设置）</p>
<ul>
<li>AlwaysDeny：表示拒绝所有的请求，一般用户测试</li>
<li>AlwaysAllow：允许接受所有请求，如果集群不需要授权流程，则可以采用该策略</li>
<li>ABAC（Attribute-Based Access Control）：基于属性的访问控制，表示使用用户配置的授权规则对用户请求进行匹配和控制</li>
<li>Webhook：通过调用外部 REST 服务对用户进行授权</li>
<li>RBAC（Role-Based Access Control）：基于角色的访问控制，现行默认规则</li>
</ul>
<h4 id="9-2-2-RBAC"><a href="#9-2-2-RBAC" class="headerlink" title="9.2.2 RBAC"></a>9.2.2 RBAC</h4><p>RBAC（Role-Based Access Control）基于角色的访问控制，相对于其它访问控制方式，拥有一下优势：</p>
<ul>
<li>对集群中的资源和非资源均拥有完整的覆盖</li>
<li>整个 RBAC 完全由几个 API 对象完成，同其它 API 对象一样，可以用 kubectl 或 API 进行操作</li>
<li>可以在运行时进行调整，无需重启 API Server</li>
</ul>
<p>RBAC 引入了 4 个新的顶级资源对象：Role、ClusterRole、RoleBinding、ClusterRoleBinding，4 种对象类型均可以通过 kubectl 与 API 操作</p>
<img src="https://raw.githubusercontent.com/cy77cc/pic-md/master/image-20250412201807387.png" alt="image-20250412201807387" style="zoom:67%;" />

<p>有三种绑定关系：</p>
<ul>
<li>Role + RoleBinding</li>
<li>ClusterRole + ClusterRoleBinding</li>
<li>ClusterRole + RoleBinding (降维，作用域限制)</li>
</ul>
<p>在 RBAC API 中，Role 表示一组规则权限，权限只会增加（累加权限），不存在一个资源一开始就有很多权限而通过 RBAC 对其进行减少的操作；Role 可以定义在一个 namespace 中，如果想要跨 namespace 则可以创建 ClusterRole</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">kind:</span> <span class="string">Role</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"> <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line"> <span class="attr">name:</span> <span class="string">pod-reader</span></span><br><span class="line"><span class="attr">rules:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">apiGroups:</span> [<span class="string">&quot;&quot;</span>] <span class="comment"># &quot;&quot; 表示core组</span></span><br><span class="line">  <span class="attr">resources:</span> [<span class="string">&quot;pods&quot;</span>]</span><br><span class="line">  <span class="attr">verbs:</span> [<span class="string">&quot;get&quot;</span>, <span class="string">&quot;watch&quot;</span>, <span class="string">&quot;list&quot;</span>]</span><br></pre></td></tr></table></figure>

<p>ClusterRole 具有与 Role 相同的权限角色控制能力，不同的是 ClusterRole 是集群级别的，ClusterRole 可以用于：</p>
<ul>
<li>集群级别的资源控制（如 Node 访问权限）</li>
<li>非资源型 endpoints （例如 <code>/health</code> 访问）</li>
<li>所有命名空间资源控制（例如 Pods）</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">kind:</span> <span class="string">ClusterRole</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"> <span class="attr">name:</span> <span class="string">secret-reader</span></span><br><span class="line"><span class="attr">rules:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">apiGroups:</span> [<span class="string">&quot;&quot;</span>]</span><br><span class="line">  <span class="attr">resources:</span> [<span class="string">&quot;secrets&quot;</span>]</span><br><span class="line">  <span class="attr">verbs:</span> [<span class="string">&quot;get&quot;</span>, <span class="string">&quot;watch&quot;</span>, <span class="string">&quot;list&quot;</span>]</span><br></pre></td></tr></table></figure>

<p>RoleBinding + Role 可以将 Role 中定义的权限授予用于或用户组，RoleBinding 包含一组权限列表（subjects），权限列表中包含有不同形式的待授予权限资源类型（users, groups, service accounts）；RoleBinding 同样包含对被 Bind 的 Role 引用；RoleBinding 适用于某个命名空间内授权，而 ClusterRoleBinding 适用于集群范围内的授权。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">kind:</span> <span class="string">RoleBinding</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"> <span class="attr">name:</span> <span class="string">read-pods</span></span><br><span class="line"> <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">subjects:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">User</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">jane</span></span><br><span class="line">  <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br><span class="line"><span class="attr">roleRef:</span></span><br><span class="line"> <span class="attr">kind:</span> <span class="string">Role</span></span><br><span class="line"> <span class="attr">name:</span> <span class="string">pod-reader</span></span><br><span class="line"> <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br></pre></td></tr></table></figure>

<p>RoleBinding + ClusterRole 同样可以引用 ClusterRole 来对当前 namespace 内用户、用户组或 ServiceAccount 进行授权，这种操作允许集群管理员在整个集群内定义一些通用的 ClusterRole，然后在不同的 namespace 中使用 RoleBinding 来引用</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这个角色绑定只允许dave在dev命名空间内读取Secret</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">RoleBinding</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"> <span class="attr">name:</span> <span class="string">read-secrets</span></span><br><span class="line"> <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">subjects:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">User</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">dave</span></span><br><span class="line">  <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br><span class="line"><span class="attr">roleRef:</span></span><br><span class="line"> <span class="attr">kind:</span> <span class="string">ClusterRole</span></span><br><span class="line"> <span class="attr">name:</span> <span class="string">secret-reader</span></span><br><span class="line"> <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br></pre></td></tr></table></figure>

<p>ClusterRoleBinding 可以对整个集群中的所有命名空间资源权限进行授权；一下 ClusterRoleBinding 样例展示了授权 manager 组内所有用户在全部命名空间中对 secrets 进行访问</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">kind:</span> <span class="string">ClusterRoleBinding</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"> <span class="attr">name:</span> <span class="string">read-secrets-global</span></span><br><span class="line"><span class="attr">subjects:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">Group</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">manager</span></span><br><span class="line">  <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br><span class="line"><span class="attr">roleRef:</span></span><br><span class="line"> <span class="attr">kind:</span> <span class="string">ClusterRole</span></span><br><span class="line"> <span class="attr">name:</span> <span class="string">secret-reader</span></span><br><span class="line"> <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br></pre></td></tr></table></figure>

<p><strong>Resources</strong>：Kubernetes 集群内一些资源一般以其名称字符串来表示，这些字符串一般会在 API 的 URL 地址中出现；同时某些资源也会包含子资源，例如 logs 资源就属于 pods 的子资源，API 中 URL 样例如下</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /api/v1/namespace/&#123;namespace&#125;/pods/&#123;name&#125;/log</span><br></pre></td></tr></table></figure>

<p>如果要在 RBAC 授权模型中控制这些子资源的访问权限，可以通过 &#x2F; 分隔符来实现，以下是一个定义 pods 资源 logs 访问权限的 Role 定义样例</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">...</span></span><br><span class="line"><span class="attr">rules:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">apiGroups:</span> [<span class="string">&quot;&quot;</span>]</span><br><span class="line">  <span class="attr">resources:</span> [<span class="string">&quot;pods/log&quot;</span>]</span><br><span class="line">  <span class="attr">verbs:</span> [<span class="string">&quot;get&quot;</span>, <span class="string">&quot;list&quot;</span>]</span><br></pre></td></tr></table></figure>

<p>subjects</p>
<p><img src="https://raw.githubusercontent.com/cy77cc/pic-md/master/image-20250412211511314.png" alt="image-20250412211511314"></p>
<h4 id="9-2-3-实操"><a href="#9-2-3-实操" class="headerlink" title="9.2.3 实操"></a>9.2.3 实操</h4><p>需求：创建一个用户只能管理 dev 命名空间</p>
<p>实现：创建证书 &gt; 转换为 kubeconfig 文件 &gt; 创建命名空间 &gt; 角色绑定</p>
<ol>
<li>创建 devuser 的证书</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /etc/kubernetes/pki</span><br><span class="line">cfssl gencert -ca=ca.crt -ca-key=ca.key -profile=kubernetes /root/devuser.json | cfssljson -bare devuser</span><br></pre></td></tr></table></figure>

<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// /root/devuser.json</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;CN&quot;</span><span class="punctuation">:</span> <span class="string">&quot;devuser&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;hosts&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;key&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;algo&quot;</span><span class="punctuation">:</span> <span class="string">&quot;rsa&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;size&quot;</span><span class="punctuation">:</span> <span class="number">2048</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;C&quot;</span><span class="punctuation">:</span> <span class="string">&quot;CN&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;ST&quot;</span><span class="punctuation">:</span> <span class="string">&quot;BeiJing&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;L&quot;</span><span class="punctuation">:</span> <span class="string">&quot;BeiJing&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;O&quot;</span><span class="punctuation">:</span> <span class="string">&quot;k8s&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;OU&quot;</span><span class="punctuation">:</span> <span class="string">&quot;system&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置集群参数</span></span><br><span class="line">kubectl config set-cluster kubernetes \</span><br><span class="line">--certificate-authority=ca.crt \</span><br><span class="line">--embed-certs=true \</span><br><span class="line">--server=$&#123;KUBE_APISERVER&#125; \</span><br><span class="line">--kubeconfig=devuser.kubeconfig</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置客户端认证参数</span></span><br><span class="line">kubectl config set-credentials devuser \</span><br><span class="line">--client-certificate=devuser.pem \</span><br><span class="line">--client-key=devuser-key.pem \</span><br><span class="line">--embed-certs=true \</span><br><span class="line">--kubeconfig=devuser.kubeconfig</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置上下文参数</span></span><br><span class="line">kubectl config set-context kubernetes \</span><br><span class="line">--cluster=kubernetes \</span><br><span class="line">--user=devuser \</span><br><span class="line">--namespace=dev \</span><br><span class="line">--kubeconfig=devuser.kubeconfig</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">devuser 绑定到 admin 集群角色上</span></span><br><span class="line">kubectl create rolebinding devuser-admin-binding \</span><br><span class="line">--clusterrole=admin \</span><br><span class="line">--user=devuser --namespace=dev</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置默认上下文</span></span><br><span class="line">kubectl config use-context kubernetes --kubeconfig=devuser.kubeconfig</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建对应的用户放到home目录下</span></span><br><span class="line">useradd dev</span><br><span class="line">passwd dev</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">把配置文件放到用户home目录下，用户只能访问dev命名空间，</span></span><br><span class="line">mv devuser.kubeconfig /home/dev/.kube/config</span><br></pre></td></tr></table></figure>

<h4 id="9-2-4-资源与角色类型的匹配"><a href="#9-2-4-资源与角色类型的匹配" class="headerlink" title="9.2.4 资源与角色类型的匹配"></a>9.2.4 资源与角色类型的匹配</h4><p><img src="https://raw.githubusercontent.com/cy77cc/pic-md/master/image-20250413123107109.png" alt="image-20250413123107109"></p>
<h4 id="9-2-5-常见的预定义角色"><a href="#9-2-5-常见的预定义角色" class="headerlink" title="9.2.5 常见的预定义角色"></a>9.2.5 常见的预定义角色</h4><p><strong>view ClusterRole</strong></p>
<ul>
<li>允许读取一个命名空间中的大多数资源，除了 Role、RoleBinding 和 Secret</li>
</ul>
<p><strong>edit ClusterRole</strong></p>
<ul>
<li>允许读取和修改 Secret。但是，它不允许查看或修改 Role 和 RoleBinding，这是为了防止权限扩散</li>
</ul>
<p><strong>admin ClusterRole</strong></p>
<ul>
<li>一个命名空间中的资源的完全控制权是由 admin ClusterRole 赋予的。有这个 ClusterRole 的主体可以读取和修改命名空间中的任何资源，除了 ResourceQuota 和命名空间资源本身。edit 和 adminClusterRole 之间的主要区别是能否在命名空间中查看和修改 Role 和 RoleBinding</li>
</ul>
<p><strong>cluster-adminCluterRole</strong></p>
<ul>
<li>通过将cluster-adminCluterRole 赋给主体，主体可以获得 Kubernetes 集群完全控制的权限</li>
</ul>
<h3 id="9-3-准入控制"><a href="#9-3-准入控制" class="headerlink" title="9.3 准入控制"></a>9.3 准入控制</h3><p>准入控制是 API Server 的插件集合，通过添加不同的插件，实现额外的准入控制规则。甚至与 API Server 的一些主要的功能都需要通过 Admission Controllers 实现，比如 ServiceAccount。</p>
<ul>
<li>NamespaceLifecycle：防止在不存在的 namespace 上创建对象，防止删除系统预置 namespace，删除 namespace 是，连带删除它的所有资源对象。</li>
<li>LimitRanger：确保请求的资源不会超过资源所在 namespace 和 LimitRanger 的限制</li>
<li>ServiceAccount：实现了自动化添加 SA</li>
<li>ResourceQuota：确保请求的资源不会超过资源的 ResourceQuota 限制</li>
</ul>
<h2 id="十、HELM"><a href="#十、HELM" class="headerlink" title="十、HELM"></a>十、HELM</h2><p> 在没有使用 helm 之前，向 Kubernetes 部署应用，我们需要依次部署 deployment、service 等，步骤较繁琐。况且随着很多项目微服务化，复杂的应用在容器中部署以及管理显得较为复杂，helm 通过打包的方式，支持发布的版本管理和控制，很大程度上简化了 Kubernetes 应用的部署和管理</p>
<p>helm 本质就是让 Kubernetes 的应用管理（deployment、service等）可配置，能<strong>动态生成</strong>。通过动态生成资源清单文件。然后调用 kubectl 自动执行 Kubernetes 资源部署。</p>
<p>helm 是官方提供的类似于 yum 的包管理器，是部署环境的流程封装。helm 有两个重要的概念：chart 和 release</p>
<ul>
<li>chart：是创建一个应用的信息集合，包括各种 Kubernetes 对象的配置模板、参数定义、依赖关系、文档说明等。chart 是应用部署的自包含逻辑单元。可以将 chart 想象成 apt、yum 中的软件安装包</li>
<li>release：是 chart 的运行实例，代表了一个正在运行的应用。当 chart 被安装到 Kubernetes 集群，就生成一个 release。chart 能够多次安装到同一个集群，每次安装都是一个 release</li>
<li>helm cli：helm 客户端组件，负责和 Kubernetes API Server 通信</li>
<li>repository： 用于发布和存储 chart 的仓库</li>
</ul>
<h2 id="十一、k8s运维"><a href="#十一、k8s运维" class="headerlink" title="十一、k8s运维"></a>十一、k8s运维</h2><h3 id="11-1-Harbor"><a href="#11-1-Harbor" class="headerlink" title="11.1 Harbor"></a>11.1 Harbor</h3><p>Harbor 的目标是帮助用户迅速搭建一个企业级的 Docker registry 服务。它以 Docker 公司开源的 registry 为基础，额外提供了如下功能：</p>
<ul>
<li>基于角色的访问控制</li>
<li>基于策略的镜像复制</li>
<li>镜像的漏洞扫描</li>
<li>AD&#x2F;LDAP集成</li>
<li>镜像的删除和空间清理</li>
<li>友好的管理 UI</li>
<li>审计日志</li>
<li>RESTful API</li>
<li>部署简单</li>
</ul>
<h2 id="kubectl操作"><a href="#kubectl操作" class="headerlink" title="kubectl操作"></a>kubectl操作</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">kubectl get ns(namespace) # 获取命名空间</span><br><span class="line">kubectl get po(pod) # 获取默认命名空间下的pod</span><br><span class="line">kubectl get nodes # 获取节点信息</span><br><span class="line">kubectl scale deploy --replicas=3 nginx # 设置deploy副本数为3</span><br><span class="line">kubectl create -f pod.yaml   # 基于pod.yaml文件创建pod资源</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">获取当前资源，pod、node、namespace</span></span><br><span class="line">kubectl get pod</span><br><span class="line">	-A,--all-namespaces   	查看当前所有命名空间的资源</span><br><span class="line">	-n						指定命名空间，默认值default，kube-system空间存放的时当前组件资源</span><br><span class="line">	-l 						筛选资源，key  key=value</span><br><span class="line">	-o wide 				详细信息包括IP、分配的节点等</span><br><span class="line">	-w						监控资源的变化状态</span><br><span class="line"><span class="meta prompt_">	</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">示例</span></span><br><span class="line">kubectl get pod --show-labels # 查看标签</span><br><span class="line">kubectl get pod -l app(app=nginx) # 通过标签筛选pod   app是key</span><br><span class="line">	</span><br><span class="line"><span class="meta prompt_">	</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">进入Pod内部的容器执行命令</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">当一个pod内部就一个容器时，可以省略ContainerName(不包括pause)</span></span><br><span class="line">kubectl exec -it PodName -c ContainerName -- command</span><br><span class="line">	-c 						可以省略，默认进入唯一的容器内部</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">示例</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">进入pod容器内部</span></span><br><span class="line">kubectl exec -it pod名称 -c 容器名称 -- /bin/bash</span><br><span class="line">kubectl exec -it nginx-5869d7778c-5wwcd -c nginx -- /bin/bash</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看资源的描述</span></span><br><span class="line">kubectl explain pod.spec</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看Pod内部容器的日志</span></span><br><span class="line">kubectl logs PodName -c ContainerName</span><br><span class="line">kubectl logs app=nginx -c nginx # 查看日志</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看资源的详细信息</span></span><br><span class="line">kubectl describe pod PodName (node NodeName)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除pod</span></span><br><span class="line">kubectl delete pod PodName</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除所有pod</span></span><br><span class="line">kubectl delete pod --all</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除由k8s.ymal创建的资源</span></span><br><span class="line">kubectl delete -f k8s.yaml</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建service，service会匹配myapp标签的pod</span></span><br><span class="line">kubectl create svc clusterip myapp --tcp=80:80</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">标签操作</span></span><br><span class="line">kubectl label pod PodName key=value  # 想PodName添加key=value的标签</span><br><span class="line">	--overwrite</span><br><span class="line"><span class="meta prompt_">	</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">扩容操作</span></span><br><span class="line">kubectl scale rc rcName --replicas=5</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">--dry-run 只测试不运行，在不记得怎么写资源清单的时候可以用这个得到模板</span></span><br><span class="line">kubectl create deploy myapp --image=wangyanglinux/myapp:v1.0 --dry-run -o yaml</span><br></pre></td></tr></table></figure>



<p>每个Pod都有一个pause容器，Pod内的其他容器共享pause容器的Pid，Uid等信息</p>
<p><img src="https://raw.githubusercontent.com/cy77cc/pic-md/master/image-20250406163615248.png" alt="image-20250406163615248"></p>
<p>高可用集群，如果一个节点挂了会发生哪些事情 <a target="_blank" rel="noopener" href="https://developer.aliyun.com/article/785311">https://developer.aliyun.com/article/785311</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://cy77cc.github.io/2025/04/06/Kubernetes%EF%BC%88k8s%EF%BC%89/" data-id="cm8wiyf4t0000qslza6gj3g58" data-title="k8s学习记录" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6-docker-kubernetes/" rel="tag">中间件,docker,kubernetes</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2025/04/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Älter</strong>
      <div class="article-nav-title">Go设计模式</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/docker/" rel="tag">docker</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/go/" rel="tag">go</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/golang/" rel="tag">golang</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mq/" rel="tag">mq</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/nginx/" rel="tag">nginx</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/tool/" rel="tag">tool</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6-docker-kubernetes/" rel="tag">中间件,docker,kubernetes</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F/" rel="tag">分布式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="tag">数据库</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/docker/" style="font-size: 10px;">docker</a> <a href="/tags/go/" style="font-size: 10px;">go</a> <a href="/tags/golang/" style="font-size: 20px;">golang</a> <a href="/tags/mq/" style="font-size: 10px;">mq</a> <a href="/tags/nginx/" style="font-size: 10px;">nginx</a> <a href="/tags/tool/" style="font-size: 10px;">tool</a> <a href="/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6-docker-kubernetes/" style="font-size: 10px;">中间件,docker,kubernetes</a> <a href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F/" style="font-size: 10px;">分布式</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" style="font-size: 20px;">数据库</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archiv</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/04/">April 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/03/">March 2025</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">letzter Beitrag</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2025/04/06/Kubernetes%EF%BC%88k8s%EF%BC%89/">k8s学习记录</a>
          </li>
        
          <li>
            <a href="/2025/04/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">Go设计模式</a>
          </li>
        
          <li>
            <a href="/2025/04/04/nginx/">Nginx</a>
          </li>
        
          <li>
            <a href="/2025/04/04/Git/">Git</a>
          </li>
        
          <li>
            <a href="/2025/04/04/docker/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2025 Mr. Zhang<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>