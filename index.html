<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>cy77cc</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="cy77cc">
<meta property="og:url" content="https://cy77cc.github.io/index.html">
<meta property="og:site_name" content="cy77cc">
<meta property="og:locale">
<meta property="article:author" content="Mr. Zhang">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="cy77cc" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/fork-awesome@1.2.0/css/fork-awesome.min.css">

<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">cy77cc</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Suche"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Suche"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://cy77cc.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-Kubernetes（k8s）" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/04/06/Kubernetes%EF%BC%88k8s%EF%BC%89/" class="article-date">
  <time class="dt-published" datetime="2025-04-06T01:21:00.000Z" itemprop="datePublished">2025-04-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/04/06/Kubernetes%EF%BC%88k8s%EF%BC%89/">k8s学习记录</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>有状态和无状态</p>
<ul>
<li>会保存数据的是有状态</li>
<li>不保存数据的是无状态</li>
</ul>
<h2 id="一、环境准备"><a href="#一、环境准备" class="headerlink" title="一、环境准备"></a>一、环境准备</h2><p>3台虚拟机，至少是2C2G，互相能ping通</p>
<h3 id="1-1-下载RockyLinux9"><a href="#1-1-下载RockyLinux9" class="headerlink" title="1.1 下载RockyLinux9"></a>1.1 下载RockyLinux9</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://rockylinux.org/download</span><br></pre></td></tr></table></figure>

<h3 id="1-2-环境初始化"><a href="#1-2-环境初始化" class="headerlink" title="1.2 环境初始化"></a>1.2 环境初始化</h3><p>三个node的配置差不多，ip地址换一下就行</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">网卡配置</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">cat</span> /etc/NetworkManager/system-connections/ens160.nmconnection</span></span><br><span class="line">[ipv4]</span><br><span class="line">address1=192.168.66.11/24</span><br><span class="line">method=manual</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">调用 nmcli 重启设备和连接配置</span></span><br><span class="line">nmcli d d ens192</span><br><span class="line">nmcli d r ens160 </span><br><span class="line">nmcli c r ens160</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">更换yum源</span></span><br><span class="line">sed -e &#x27;s|^mirrorlist=|#mirrorlist=|g&#x27; \</span><br><span class="line">    -e &#x27;s|^#baseurl=http://dl.rockylinux.org/$contentdir|baseurl=https://mirrors.aliyun.com/rockylinux|g&#x27; \</span><br><span class="line">    -i.bak \</span><br><span class="line">    /etc/yum.repos.d/Rocky-*.repo</span><br><span class="line"></span><br><span class="line">dnf makecache</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">防火墙修改 firewalld 为 iptables</span></span><br><span class="line">systemctl stop firewalld</span><br><span class="line">systemctl disable firewalld</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">可选</span></span><br><span class="line">yum -y install iptables-services</span><br><span class="line">systemctl start iptables</span><br><span class="line">iptables -F</span><br><span class="line">systemctl enable iptables</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">禁用 Selinux</span></span><br><span class="line">setenforce 0</span><br><span class="line">sed -i &quot;s/SELINUX=enforcing/SELINUX=disabled/g&quot; /etc/selinux/config</span><br><span class="line">grubby --update-kernel ALL --args selinux=0</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置时区</span></span><br><span class="line">timedatectl set-timezone Asia/Shanghai</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">关闭 swap 分区</span></span><br><span class="line">swapoff -a</span><br><span class="line">sed -i &#x27;s:/dev/mapper/rl-swap:#/dev/mapper/rl-swap:g&#x27; /etc/fstab</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">修改主机名</span></span><br><span class="line">hostnamectl  set-hostname k8s-node01</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装 ipvs</span></span><br><span class="line">yum install -y ipvsadm</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">开启路由转发</span></span><br><span class="line">echo &#x27;net.ipv4.ip_forward=1&#x27; &gt;&gt; /etc/sysctl.conf</span><br><span class="line">sysctl -p</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">加载 bridge</span></span><br><span class="line">yum install -y epel-release</span><br><span class="line">yum install -y bridge-utils</span><br><span class="line"></span><br><span class="line">modprobe br_netfilter</span><br><span class="line">echo &#x27;br_netfilter&#x27; &gt;&gt; /etc/modules-load.d/bridge.conf</span><br><span class="line">echo &#x27;net.bridge.bridge-nf-call-iptables=1&#x27; &gt;&gt; /etc/sysctl.conf</span><br><span class="line">echo &#x27;net.bridge.bridge-nf-call-ip6tables=1&#x27; &gt;&gt; /etc/sysctl.conf</span><br><span class="line">sysctl -p</span><br></pre></td></tr></table></figure>

<h3 id="1-3-安装docker"><a href="#1-3-安装docker" class="headerlink" title="1.3 安装docker"></a>1.3 安装docker</h3><p>k8s也不一定要用docker作为容器运行时，可以直接使用containerd，k8s好像默认的也是containerd，使用docker作为容器运行起还需要安装cir-dockerd。参考链接 <a target="_blank" rel="noopener" href="https://docs.docker.com/engine/install/rhel/">https://docs.docker.com/engine/install/rhel/</a></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">移除旧版本</span></span><br><span class="line">sudo dnf remove docker \</span><br><span class="line">                  docker-client \</span><br><span class="line">                  docker-client-latest \</span><br><span class="line">                  docker-common \</span><br><span class="line">                  docker-latest \</span><br><span class="line">                  docker-latest-logrotate \</span><br><span class="line">                  docker-logrotate \</span><br><span class="line">                  docker-engine \</span><br><span class="line">                  podman \</span><br><span class="line">                  runc</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">添加仓库</span>                  </span><br><span class="line">sudo dnf -y install dnf-plugins-core</span><br><span class="line">sudo dnf config-manager --add-repo https://download.docker.com/linux/rhel/docker-ce.repo</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">下载最新版本的docker</span></span><br><span class="line">sudo dnf install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置开启自启动</span></span><br><span class="line">sudo systemctl enable --now docker</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">这里还需要配置docker的镜像，阿里云的镜像加速已经没用了，需要另外找</span></span><br><span class="line">sudo mkdir -p /etc/docker</span><br><span class="line">sudo tee /etc/docker/daemon.json &lt;&lt;-&#x27;EOF&#x27;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [&quot;https://xxxx.mirror.aliyuncs.com&quot;]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure>

<h3 id="1-4-安装cri-dockerd"><a href="#1-4-安装cri-dockerd" class="headerlink" title="1.4 安装cri-dockerd"></a>1.4 安装cri-dockerd</h3><p>docker之前的运行时在k8s v1.24移除了，所以现在要额外安装cri-dockerd才能用docker作为k8s的容器运行时。参考链接（<a target="_blank" rel="noopener" href="https://mirantis.github.io/cri-dockerd/usage/install-manually/%EF%BC%89">https://mirantis.github.io/cri-dockerd/usage/install-manually/）</a></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在github下载cri-dockerd</span></span><br><span class="line">wget https://github.com/Mirantis/cri-dockerd/releases/download/v0.3.17/cri-dockerd-0.3.17.amd64.tgz</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">解压</span></span><br><span class="line">tar -zxvf cri-dockerd-0.3.17.amd64.tgz</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装</span></span><br><span class="line">install -o root -g root -m 0755 cri-dockerd 解压的cri-dcokerd路径/bin/cri-dockerd</span><br><span class="line">install packaging/systemd/* /etc/systemd/system</span><br><span class="line">sed -i -e &#x27;s,/usr/bin/cri-dockerd,/usr/local/bin/cri-dockerd,&#x27; /etc/systemd/system/cri-docker.service</span><br><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl enable --now cri-docker.socket</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果要在k8s中使用添加一些配置</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">需要追加--network-plugin=cni，通过该配置告诉容器，使用kubernetes的网络接口</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">覆盖沙盒 (pause) 镜像，正常情况下，国内你是拉取不到k8s.gcr.io/pause:3.8镜像的，可以换成国内的registry.aliyuncs.com/google_containers/pause:3.10，这个镜像是一切的 Pod 的基础，要么自己手动导入进来，要么改成国内的镜像，通过设置以下配置来覆盖默认的沙盒镜像</span></span><br><span class="line">ExecStart=/usr/bin/cri-dockerd --container-runtime-endpoint fd:// --network-plugin=cni --pod-infra-container-image=registry.aliyuncs.com/google_containers/pause:3.10</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重新启动cri-dockers服务</span></span><br><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl enable cri-docker.service</span><br><span class="line">systemctl enable --now cri-docker.socket</span><br><span class="line">systemctl restart cri-dockerd</span><br></pre></td></tr></table></figure>

<h3 id="1-5-安装kubernetes"><a href="#1-5-安装kubernetes" class="headerlink" title="1.5 安装kubernetes"></a>1.5 安装kubernetes</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">此操作会覆盖 /etc/yum.repos.d/kubernetes.repo 中现存的所有配置</span></span><br><span class="line">cat &lt;&lt;EOF | sudo tee /etc/yum.repos.d/kubernetes.repo</span><br><span class="line">[kubernetes]</span><br><span class="line">name=Kubernetes</span><br><span class="line">baseurl=https://pkgs.k8s.io/core:/stable:/v1.31/rpm/</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=1</span><br><span class="line">gpgkey=https://pkgs.k8s.io/core:/stable:/v1.31/rpm/repodata/repomd.xml.key</span><br><span class="line">exclude=kubelet kubeadm kubectl cri-tools kubernetes-cni</span><br><span class="line">EOF</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装软件</span></span><br><span class="line">sudo yum install -y kubelet kubeadm kubectl --disableexcludes=kubernetes</span><br><span class="line">sudo systemctl enable --now kubelet</span><br></pre></td></tr></table></figure>

<h3 id="1-6-搭建集群"><a href="#1-6-搭建集群" class="headerlink" title="1.6 搭建集群"></a>1.6 搭建集群</h3><p>上面的操作需要在三个节点都执行一遍，也可以执行完后克隆虚拟机，修改ip地址</p>
<h4 id="1-6-1-修改三个虚拟机的hostname"><a href="#1-6-1-修改三个虚拟机的hostname" class="headerlink" title="1.6.1 修改三个虚拟机的hostname"></a>1.6.1 修改三个虚拟机的hostname</h4><p>修改节点的hostname，这样就可以直接知识honstname访问node，添加到host</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">分别在不同虚拟机执行</span></span><br><span class="line">hostnamectl  set-hostname k8s-node1</span><br><span class="line">hostnamectl  set-hostname k8s-master</span><br><span class="line">hostnamectl  set-hostname k8s-node2</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">添加到host文件</span></span><br><span class="line">vim /etc/hosts</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">添加解析</span></span><br><span class="line">192.168.66.11 k8s-master</span><br><span class="line">192.168.66.22 k8s-node1</span><br><span class="line">192.168.66.33 k8s-node2</span><br></pre></td></tr></table></figure>

<h4 id="1-6-2-初始化主节点"><a href="#1-6-2-初始化主节点" class="headerlink" title="1.6.2 初始化主节点"></a>1.6.2 初始化主节点</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">kubeadm init </span><br><span class="line">--apiserver-advertise-address=192.168.66.11    # apiserver地址</span><br><span class="line">--image-repository registry.aliyuncs.com/google_containers # 镜像仓库</span><br><span class="line">--kubernetes-version 1.32.3 # k8s的版本，使用kubectl version 查看，要和自己的版本对应 </span><br><span class="line">--service-cidr=10.10.0.0/12 </span><br><span class="line">--pod-network-cidr=10.244.0.0/16 # pod的地址</span><br><span class="line">--ignore-preflight-errors=all </span><br><span class="line">--cri-socket unix:///var/run/cri-dockerd.sock # 使用docker作为容器运行时，如果使用containerd可以不加</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">上面命令执行完后会提示执行三条命令，已经从节点怎么加入集群的命令，记得注意结尾的命令</span></span><br></pre></td></tr></table></figure>

<h4 id="1-6-3-从节点加入集群"><a href="#1-6-3-从节点加入集群" class="headerlink" title="1.6.3 从节点加入集群"></a>1.6.3 从节点加入集群</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">这里的token是在上面初始化主节点后输出的，拷贝过来，添加cri-dockerd的socket套接字执行</span></span><br><span class="line">kubeadm join 192.168.10.11:6443 --token a6xh07.yg9wh2vru2grluwb         --discovery-token-ca-cert-hash sha256:7cd8499abae48c8403800152cc0f655ac704ea00ae30a549acd9bbac7b26dca4 --cri-socket unix:///var/run/cri-dockerd.sock</span><br></pre></td></tr></table></figure>

<h3 id="1-7-部署网络插件"><a href="#1-7-部署网络插件" class="headerlink" title="1.7 部署网络插件"></a>1.7 部署网络插件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">下载配置文件</span></span><br><span class="line">curl https://raw.githubusercontent.com/projectcalico/calico/v3.29.3/manifests/calico.yaml -O</span><br><span class="line"></span><br><span class="line">vim calico.yaml</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">修改ipv4的地址为上面初始化主节点时的pod地址</span></span><br><span class="line">- name: CALICO_IPV4POOL_CIDR</span><br><span class="line">  value: &quot;10.244.0.0/16&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">修改为 BGP 模式</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Enable IPIP</span></span><br><span class="line">- name: CALICO_IPV4POOL_IPIP</span><br><span class="line">  value: &quot;Always&quot;  #改成Off</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">把配置文件里面的所有docker.io都删除，不然下载不到容器</span></span><br><span class="line">sed -i &#x27;s|docker.io/||g&#x27; calico.yaml</span><br><span class="line"></span><br><span class="line">kubectl apply -f calico.yaml  #等待容器安装完成即可</span><br></pre></td></tr></table></figure>

<h3 id="1-8-修改kube-proxy模式为ipvs"><a href="#1-8-修改kube-proxy模式为ipvs" class="headerlink" title="1.8 修改kube-proxy模式为ipvs"></a>1.8 修改kube-proxy模式为ipvs</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">kubectl edit configmap kube-proxy -n kube-system</span></span><br><span class="line">mode: ipvs</span><br><span class="line"></span><br><span class="line">kubectl delete pod -n kube-system -l k8s-app=kube-proxy</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="https://cy77cc.github.io/2025/04/06/Kubernetes%EF%BC%88k8s%EF%BC%89/" data-id="cm8wiyf4t0000qslza6gj3g58" data-title="k8s学习记录" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6-docker-kubernetes/" rel="tag">中间件,docker,kubernetes</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-设计模式" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/04/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" class="article-date">
  <time class="dt-published" datetime="2025-04-05T08:48:00.000Z" itemprop="datePublished">2025-04-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/04/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">Go设计模式</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="一、创建型设计模式"><a href="#一、创建型设计模式" class="headerlink" title="一、创建型设计模式"></a>一、创建型设计模式</h2><h3 id="1-单例模式"><a href="#1-单例模式" class="headerlink" title="1. 单例模式"></a>1. 单例模式</h3><p>单例模式（Singleton Pattern）是一种常用的软件设计模式。单例模式的类提供了一种访问其唯一对象的方法，该对象可以直接被访问，无须实例化。单例模式保证了一个类的对象只存在一个，同时维护了一个对其对象的全局访问点。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="keyword">type</span> Singleton <span class="keyword">struct</span> &#123;</span><br><span class="line">	Value <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance *Singleton</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> mutex *sync.Mutex</span><br></pre></td></tr></table></figure>

<h4 id="1-1-懒汉式单例模式"><a href="#1-1-懒汉式单例模式" class="headerlink" title="1.1 懒汉式单例模式"></a>1.1 懒汉式单例模式</h4><p>懒汉式单例模式是指，在创建对象时，不直接创建对象，在加载配置文件时才创建对象。需要加锁保证并发安全。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LazyGetInstance</span><span class="params">()</span></span> *Singleton &#123;</span><br><span class="line">	mutex.Lock()</span><br><span class="line">	<span class="keyword">defer</span> mutex.Unlock()</span><br><span class="line">	<span class="keyword">if</span> instance == <span class="literal">nil</span> &#123;</span><br><span class="line">		instance = <span class="built_in">new</span>(Singleton)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> instance</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-2-饿汉式单例模式"><a href="#1-2-饿汉式单例模式" class="headerlink" title="1.2 饿汉式单例模式"></a>1.2 饿汉式单例模式</h4><p>在创建对象时，不判断创建的对象是否为空，直接创建对象。时并发安全的，唯一的缺点时在导入包的同时会创建对象，并且创建的对象会持续存在与内存中。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入包时创建</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> instance == <span class="literal">nil</span> &#123;</span><br><span class="line">		instance = <span class="built_in">new</span>(Singleton)</span><br><span class="line">		fmt.Println(<span class="string">&quot;创建单个实例&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HungryGetInstance</span><span class="params">()</span></span> *Singleton &#123;</span><br><span class="line">	<span class="keyword">return</span> instance</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-3-双重检查单例模式"><a href="#1-3-双重检查单例模式" class="headerlink" title="1.3 双重检查单例模式"></a>1.3 双重检查单例模式</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DoubleCheckGetInstance</span><span class="params">()</span></span> *Singleton &#123;</span><br><span class="line">	<span class="keyword">if</span> instance == <span class="literal">nil</span> &#123;</span><br><span class="line">		mutex.Lock()</span><br><span class="line">		<span class="keyword">if</span> instance == <span class="literal">nil</span> &#123;</span><br><span class="line">			instance = <span class="built_in">new</span>(Singleton)</span><br><span class="line">			fmt.Println(<span class="string">&quot;创建单个实例&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		mutex.Unlock()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> instance</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-4-sync-Once单例模式"><a href="#1-4-sync-Once单例模式" class="headerlink" title="1.4 sync.Once单例模式"></a>1.4 sync.Once单例模式</h4><p>init()函数会在包被首次加载的时候执行，如果被加载的包不立即使用，会浪费内存空间和程序加载时间。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> once sync.Once</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">OnceGetInstance</span><span class="params">()</span></span> *Singleton &#123;</span><br><span class="line">	once.Do(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		instance = <span class="built_in">new</span>(Singleton)</span><br><span class="line">		fmt.Println(<span class="string">&quot;创建单个实例&quot;</span>)</span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="keyword">return</span> instance</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><ol>
<li>优点<ul>
<li>单例模式可以拓展为工厂模式</li>
<li>对于需要频繁创建和销毁对象的系统，使用单例模式可以提升系统的性能。</li>
</ul>
</li>
<li>缺点<ul>
<li>可拓展性差</li>
<li>如果实例化的对象长时间没有被使用，会被GC，导致对象缺失。</li>
</ul>
</li>
</ol>
<h3 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h3><h4 id="1-1-使用场景"><a href="#1-1-使用场景" class="headerlink" title="1.1 使用场景"></a>1.1 使用场景</h4>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://cy77cc.github.io/2025/04/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" data-id="cm93zwe9b0000uklz81mc6pux" data-title="Go设计模式" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/go/" rel="tag">go</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-nginx" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/04/04/nginx/" class="article-date">
  <time class="dt-published" datetime="2025-04-04T11:02:00.000Z" itemprop="datePublished">2025-04-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/04/04/nginx/">Nginx</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="Nginx服务的启动和暂停"><a href="#Nginx服务的启动和暂停" class="headerlink" title="Nginx服务的启动和暂停"></a>Nginx服务的启动和暂停</h2><ul>
<li>启动：直接运行nginx软件</li>
<li>暂停</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">nginx -s stop       快速关闭Nginx，可能不保存相关信息，并迅速终止web服务。</span><br><span class="line">nginx -s quit       平稳关闭Nginx，保存相关信息，有安排的结束web服务。</span><br><span class="line">nginx -s reload     因改变了Nginx相关配置，需要重新加载配置而重载。</span><br><span class="line">nginx -s reopen     重新打开日志文件。</span><br><span class="line">nginx -c filename   为 Nginx 指定一个配置文件，来代替缺省的。</span><br><span class="line">nginx -t            不运行，仅仅测试配置文件。nginx 将检查配置文件的语法的正确性，并尝试打开配置文件中所引用到的文件。</span><br><span class="line">nginx -v            显示 nginx 的版本。</span><br><span class="line">nginx -V            显示 nginx 的版本，编译器版本和配置参数。</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="https://cy77cc.github.io/2025/04/04/nginx/" data-id="cm92oesh50006mclzbelj1pbo" data-title="Nginx" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/nginx/" rel="tag">nginx</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Git" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/04/04/Git/" class="article-date">
  <time class="dt-published" datetime="2025-04-04T05:01:00.000Z" itemprop="datePublished">2025-04-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/04/04/Git/">Git</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="Git的一些知识"><a href="#Git的一些知识" class="headerlink" title="Git的一些知识"></a>Git的一些知识</h2><ul>
<li>工作区：.git所在的目录</li>
<li>暂存区：.git&#x2F;index</li>
<li>本地仓库：.git&#x2F;objects</li>
</ul>
<p><img src="https://raw.githubusercontent.com/cy77cc/pic-md/master/image-20250404130234654.png" alt="image-20250404130234654"></p>
<ul>
<li>文件一共有四种状态<ul>
<li>未跟踪（Untrack）</li>
<li>未修改（Unmodified）</li>
<li>已修改（Modified）</li>
<li>已暂存（Staged）</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/cy77cc/pic-md/master/image-20250404130531714.png" alt="image-20250404130531714"></p>
<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">git init 				创建仓库</span><br><span class="line">git status 				查看仓库的状态</span><br><span class="line">git add 				添加到暂存区</span><br><span class="line">git rm --cached &lt;file&gt; 	将文件从暂存区移除</span><br><span class="line">git restore 			撤销修改</span><br><span class="line">git commit 				提交</span><br><span class="line">git log 				查看仓库提交历史记录，可以使用--oneline参数来查看简洁的提交记录</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">git reset 				恢复到之前的版本</span><br><span class="line">	git reset --soft  	回到之前的某一个版本，并且保存工作区和暂存区的所有修改内容</span><br><span class="line">	git reset --hard  	回到之前的某一个版本，并且丢弃工作区和暂存区的所有修改内容</span><br><span class="line">	git reset --mixed 	回到之前的某一个版本，并且只保存工作区的内容，丢弃暂存区的修改内容</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">git reflog 				操作记录</span><br><span class="line">git ls-files			查看暂存区中的内容 </span><br><span class="line"></span><br><span class="line">git diff  				查看文件在工作区、暂存区、本地仓库之间的差异，</span><br><span class="line">						查看不同版本之间的差异，</span><br><span class="line">						查看不同分支之间的差异</span><br><span class="line">	git diff HEAD~3 HEAD [filename]							和当前最新提交的前第三个版本进行比较（或者只对比某个文件）</span><br><span class="line"></span><br><span class="line">git rm 					删除一个文件，把文件从工作区和暂存区同时删除</span><br><span class="line">git fetch 				从远程仓库中拉取代码</span><br><span class="line">git pull				从远程仓库中拉取代码，并合并分支，如果有冲突会合并失败</span><br><span class="line"></span><br><span class="line">git remote add &lt;远程仓库别名&gt; &lt;远程仓库地址&gt;  添加远程仓库</span><br><span class="line">git push -u &lt;远程仓库别名&gt; &lt;分支名&gt;    上传本地仓库的代码到远程仓库</span><br><span class="line">git remote -v 			查看远程仓库</span><br><span class="line"></span><br><span class="line">git branch dev 			创建dev分支</span><br><span class="line">git checkout dev 		切换到dev分支，恢复文件</span><br><span class="line">git switch main			切换分支</span><br><span class="line">git checkout -b dev 	创建并切换到dev分支</span><br><span class="line"></span><br><span class="line">合并分支</span><br><span class="line">git switch main			先切换到main分支</span><br><span class="line">git merge dev			将dev分支合并到main分支上</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">git log --graph --oneline --decorate --all  查看历史</span><br><span class="line"></span><br><span class="line">git branch -d dev		删除dev分支</span><br><span class="line">git branch -D dev 		强制删除dev分支</span><br><span class="line"></span><br><span class="line">git rebase dev			找到main分支和dev分支的最近公共祖先，将最近公共祖先后面的dev分支合并到main的后面</span><br><span class="line">						在哪个分支上执行就是合并到哪个分支的后面</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/cy77cc/pic-md/master/image-20250404134558888.png" alt="image-20250404134558888"></p>
<p><img src="https://raw.githubusercontent.com/cy77cc/pic-md/master/image-20250404134930219.png" alt="image-20250404134930219"></p>
<p><img src="https://raw.githubusercontent.com/cy77cc/pic-md/master/image-20250404154758934.png" alt="image-20250404154758934"></p>
<p><img src="https://raw.githubusercontent.com/cy77cc/pic-md/master/image-20250404161550825.png" alt="image-20250404161550825"></p>
<h2 id="什么时候会发生冲突"><a href="#什么时候会发生冲突" class="headerlink" title="什么时候会发生冲突"></a>什么时候会发生冲突</h2><p>不同分支对相同的文件进行了更改，在合并分支时就会发生冲突。需要手动处理冲突后，添加文件到暂存区，提交。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge --abort		冲突发生后中断合并</span><br></pre></td></tr></table></figure>

<h2 id="工作流模型"><a href="#工作流模型" class="headerlink" title="工作流模型"></a>工作流模型</h2><h3 id="版本号规则"><a href="#版本号规则" class="headerlink" title="版本号规则"></a>版本号规则</h3><p>主版本.次版本.修订版本1.0.0</p>
<ul>
<li>主版本（Major Version）：主要的功能变化或重大更新；</li>
<li>次版本（Minor Version）：一些新的功能、改进和更新，通常不会影响现有功能；</li>
<li>修订版本（Patch Version）：一些小的bug修复，安全漏洞补丁等。通常不会更改现有功能和接口；</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://cy77cc.github.io/2025/04/04/Git/" data-id="cm92oesgv0000mclzbznz5sn4" data-title="Git" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/tool/" rel="tag">tool</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-docker" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/04/04/docker/" class="article-date">
  <time class="dt-published" datetime="2025-04-04T02:47:00.000Z" itemprop="datePublished">2025-04-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="https://cy77cc.github.io/2025/04/04/docker/" data-id="cm92oesh20003mclz9sew588g" data-title="" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/docker/" rel="tag">docker</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-RocketMQ" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/04/04/RocketMQ/" class="article-date">
  <time class="dt-published" datetime="2025-04-04T02:22:00.000Z" itemprop="datePublished">2025-04-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/04/04/RocketMQ/">RocketMQ</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="https://cy77cc.github.io/2025/04/04/RocketMQ/" data-id="cm92oesgz0001mclz3usadz74" data-title="RocketMQ" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/mq/" rel="tag">mq</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-消息队列" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/03/25/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/" class="article-date">
  <time class="dt-published" datetime="2025-03-25T05:21:00.000Z" itemprop="datePublished">2025-03-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/03/25/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/">各种消息队列MQ的学习记录</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="一、MQ介绍"><a href="#一、MQ介绍" class="headerlink" title="一、MQ介绍"></a>一、MQ介绍</h1><h2 id="1、什么时MQ，有什么用"><a href="#1、什么时MQ，有什么用" class="headerlink" title="1、什么时MQ，有什么用"></a>1、什么时MQ，有什么用</h2><p>MQ（message queue），消息队列。<strong>message是在不同应用程序实践传递的数据，queue将消息以队列的形式存储起来，并且在不同的应用程序之间进行传递。生产者（producer）发送消息，消费者（consumer）接收消息。</strong></p>
<img src="https://raw.githubusercontent.com/cy77cc/pic-md/master/image-20250325163831883.png" alt="image-20250325163831883" style="zoom:80%;" />

<p>在上面这个例子中，订单服务在生成订单后，发送消息到MQ，短信服务、积分服务、通知服务在监听到MQ变化后接收消息，进行下一步的处理。</p>
<p>在这个业务中，MQ中间件应该要起到什么作用呢？</p>
<ul>
<li><strong>解耦</strong>：Producer和Consumer都只跟中间件进行交互，而不需要互相进行交互。这意味着，在Producer发送消息时，不需要考虑有没有Consumer或者有多少个Consumer。反之亦然。甚至，即便Producer和Consumer是用不同语言开发的，只要都能够与MQ中间件正常交互，那么他们就可以通过MQ中间件进行消息传递。</li>
<li><strong>异步</strong>：消息并不是从Producer发送出来后，就立即交由Consumer处理，而是在MQ中间件中暂存下来。等到Consumer启动后，自行去MQ中间件上处理。也就是说，错开了Producer发送消息和Consumer消费消息的时间。</li>
<li><strong>削峰</strong>：有了MQ做消息暂存，那么当Producer发送消息的速度与Consumer处理消息的速度不一致时，MQ就能起到削峰填谷的作用。</li>
</ul>
<h2 id="2、主流MQ产品对比"><a href="#2、主流MQ产品对比" class="headerlink" title="2、主流MQ产品对比"></a>2、主流MQ产品对比</h2><table>
<thead>
<tr>
<th></th>
<th>优点</th>
<th>缺点</th>
<th>使用场景</th>
</tr>
</thead>
<tbody><tr>
<td>Kafka</td>
<td>吞吐量非常大，性能非常好，技术生态完整</td>
<td>功能比较单一</td>
<td>分布式日志收集，大数据采集</td>
</tr>
<tr>
<td>RabbitMQ</td>
<td>消息可靠性高，功能全面</td>
<td>吞吐量较低。消息积压会影响性能。</td>
<td>企业内部系统调用</td>
</tr>
<tr>
<td>RocketMQ</td>
<td>高吞吐、高性能、高可用，高级功能非常齐全</td>
<td>技术生态相对没有那么完整</td>
<td>几乎全场景。尤其适合金融</td>
</tr>
</tbody></table>
<h1 id="二、消息队列的流派"><a href="#二、消息队列的流派" class="headerlink" title="二、消息队列的流派"></a>二、消息队列的流派</h1><h2 id="1-有broker"><a href="#1-有broker" class="headerlink" title="1. 有broker"></a>1. 有broker</h2><ul>
<li><p>重topic：kafka、rocketMQ、activeMQ</p>
<p>整个broker，依据topic来进行消息的中转。在重topic的消息队列里必然需要topic的存在</p>
</li>
<li><p>轻topic：rabbitMQ</p>
<p>topic只是一种中转模式</p>
</li>
</ul>
<h2 id="2-无broker"><a href="#2-无broker" class="headerlink" title="2. 无broker"></a>2. 无broker</h2><p>在生产者和消费者之间没有使用broker，例如zeroMQ，直接使用socket进行通信。</p>
<h1 id="三、Kafka"><a href="#三、Kafka" class="headerlink" title="三、Kafka"></a>三、Kafka</h1><h2 id="1-Kafka的基本概念"><a href="#1-Kafka的基本概念" class="headerlink" title="1. Kafka的基本概念"></a>1. Kafka的基本概念</h2><p>kafka是一个分布式的，分区的消息服务。它提供了一个消息系统应该具备的功能，但是却有着独特的设计。可以这样来说，kafka借鉴了JMS（Java Message Service）规范的思想，但是并没有完全遵循JMS规范。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>Broker</td>
<td>消息中间件处理节点，一个Kafka节点就是一个broker，一个或者多个Broker组成一个kafka集群</td>
</tr>
<tr>
<td>Topic</td>
<td>kafka根据topic对消息进行归类，发布到kafka集群的每条消息都需要指定一个topic</td>
</tr>
<tr>
<td>Producer</td>
<td>消息生产者，向Broker发送消息的客户端</td>
</tr>
<tr>
<td>Consumer</td>
<td>消息消费者，从Broker读取消息的客户端</td>
</tr>
<tr>
<td>ConsumerGroup</td>
<td>每个Consumer属于一个特定的Consumer Group，一条消息可以被多个不同的Consumer Group消费，但是一个Consumer Group重智能有一个Consumer能够消费该消息</td>
</tr>
<tr>
<td>Partition</td>
<td>物理上的概念，一个topic可以分为多个partition，每个partition内部消息是有序的</td>
</tr>
</tbody></table>
<h2 id="2-创建topic"><a href="#2-创建topic" class="headerlink" title="2. 创建topic"></a>2. 创建topic</h2><p>kafka4.0</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动容器</span></span><br><span class="line">docker run -d --name broker apache/kafka:latest</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设定工作目录，进入容器内</span></span><br><span class="line">docker exec --workdir /opt/kafka/bin/ -it broker sh</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建topic，4.0不用zookeeper就这样启动</span></span><br><span class="line">./kafka-topics.sh --bootstrap-server localhost:9092 --create --topic test-topic</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">4.0之前</span></span><br><span class="line">./kafka-topics.sh --create --zookeeper zookeeper地址 --replication-factor 1 --partitions 1 --topic test</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看所有的topic</span></span><br><span class="line">./kafka-topics.sh --bootstrap-server localhost:9092 --list</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="3-发送消息"><a href="#3-发送消息" class="headerlink" title="3. 发送消息"></a>3. 发送消息</h2><p>kafka自带了一个producer命令客户端，可以从本地文件中读取内容，或者我们也可以命令行直接输入内容，并将这些内容以消息的形式发送到kafka集群中。在默认情况下，每一个行会被当做成一个独立的消息。使用kafka的发送消息的客户端，指定发送到kafka服务器地址和topic</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./kafka-console-producer.sh --bootstrap-server localhost:9092 --topic test-topic</span><br></pre></td></tr></table></figure>

<p>把消息发送给broker中的某个topic，打开一个kafka发送消息的客户端，然后开始用客户端向kafka服务器发送消息。</p>
<h2 id="4-消费消息"><a href="#4-消费消息" class="headerlink" title="4. 消费消息"></a>4. 消费消息</h2><p>对于consumer，kafka携带了一个命令行客户端，会将获取到的内容在命令中进行输出，<strong>默认是消费最新的消息</strong>。使用kafka的消费者消息客户端，从指定kafka服务器的指定topic中消费消息</p>
<p>打开一个消费消息的客户端，向kafka服务器的某个主题消费消息</p>
<ul>
<li>方式一：从最后一条消息的偏移量+1开始消费</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic test</span><br></pre></td></tr></table></figure>

<ul>
<li>方式二：从头开始消费</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">从开始消费消息</span></span><br><span class="line">./kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic test-topic --from-beginning</span><br></pre></td></tr></table></figure>

<h2 id="5-关于消息的细节"><a href="#5-关于消息的细节" class="headerlink" title="5. 关于消息的细节"></a>5. 关于消息的细节</h2><ul>
<li><p>生产者将消息发送给broker，broker会将消息保存在本地的日志文件中。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/tmp/kraft-combined-logs/test-0/00000000000000000000.log</span><br></pre></td></tr></table></figure>
</li>
<li><p>消息的保存是有序的，通过offset偏移量来描述消息的有序性。</p>
</li>
<li><p>消费者消费消息时也是通过offset来描述当前要消费的消息的位置。</p>
</li>
</ul>
<h2 id="6-单播消息"><a href="#6-单播消息" class="headerlink" title="6. 单播消息"></a>6. 单播消息</h2><p>在一个kafka的topic中，启动两个消费者，一个生产者，问：生产者发送消息，这条消息是否同时会被两个消费者消费？</p>
<p>如果多个消费者在同一个消费组，那么只有一个消费者可以收到订阅的topic中的消息，换言之，同一个消费组中只能有一个消费者收到一个topic中的消息。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./kafka-console-comsumer.sh --bootstrap-server localhost:9092 --consumer-property group.id=testGroup --topic test</span><br></pre></td></tr></table></figure>

<h2 id="7-多播消息"><a href="#7-多播消息" class="headerlink" title="7. 多播消息"></a>7. 多播消息</h2><p>不同的消费组订阅同一个topic，那么不同的消费组中只有一个消费者能收到消息。实际上也是多个消费组中的多个消费者收到了同一个消息。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./kafka-console-comsumer.sh --bootstrap-server localhost:9092 --consumer-property group.id=testGroup --topic test</span><br><span class="line">./kafka-console-comsumer.sh --bootstrap-server localhost:9092 --consumer-property group.id=testGroup1 --topic test</span><br></pre></td></tr></table></figure>

<h2 id="8-查看消费组及信息"><a href="#8-查看消费组及信息" class="headerlink" title="8. 查看消费组及信息"></a>8. 查看消费组及信息</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看当前主题下有哪些消费组，没有显式指定消费组<span class="built_in">id</span>会有默认的随机消费组</span></span><br><span class="line">./kafka-consumer-groups.sh --bootstrap-server localhost:9092 --list</span><br><span class="line">console-consumer-74284</span><br><span class="line">console-consumer-80820</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看消费组中的具体信息：比如当前偏移量、最后一条消息的偏移量、堆积的消息数量</span></span><br><span class="line">./kafka-consumer-groups.sh --bootstrap-server localhost:9092 --describe --group testGroup</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GROUP                  TOPIC           PARTITION  CURRENT-OFFSET  LOG-END-OFFSET  LAG             CONSUMER-ID                                           HOST            CLIENT-ID</span><br><span class="line">console-consumer-80820 test            0          -               7               -               console-consumer-b2f852a9-12c9-48ed-bcf0-e6fc97807524 /127.0.0.1      console-consumer</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>CURRENT-OFFSET：当前消费组的已消费偏移量，最后被消费的消息的偏移量</li>
<li>LOG_END_OFFSET：主题对应分区消息的结束偏移量（HW），最后一条消息的偏移量</li>
<li>LAG：当前消费组未消费的消息数，积压了多少条消息</li>
</ul>
<h1 id="四、kafka主题、分区的概念"><a href="#四、kafka主题、分区的概念" class="headerlink" title="四、kafka主题、分区的概念"></a>四、kafka主题、分区的概念</h1><h2 id="1-主题topic"><a href="#1-主题topic" class="headerlink" title="1. 主题topic"></a>1. 主题topic</h2><p>主题-topic在kafka中是一个逻辑的概念，kafka通过topic将消息进行分类。不同的topic会被订阅该topic的消费者消费。</p>
<p>如果说这个topic中的消息可能非常非常多，多到需要几个T来存，因为消息是会保存到log日志文件中。为了解决这个文件过大的问题，kafka提出了partition的概念。</p>
<h2 id="2-分区Partition"><a href="#2-分区Partition" class="headerlink" title="2. 分区Partition"></a>2. 分区Partition</h2><h3 id="1）分区的概念"><a href="#1）分区的概念" class="headerlink" title="1）分区的概念"></a>1）分区的概念</h3><p>一个主题中的消息量是非常大的，因此可以通过分区的设置，分布式存储这些消息。比如一个topic创建3个分区。那么topic中的消息就会分别存放在这三个分区中。 </p>
<ul>
<li>分区存储，可以解决同意存储文件过大的问题</li>
<li>提供了读写的吞吐量：读和写可以同时在多个分区中进行</li>
<li>可以分布式存储</li>
<li>可以并行写</li>
</ul>
<h3 id="2）创建多分区的主题"><a href="#2）创建多分区的主题" class="headerlink" title="2）创建多分区的主题"></a>2）创建多分区的主题</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建一个两个分区的主题test1</span></span><br><span class="line">./kafka-topics.sh --create --bootstrap-server localhost:9092 --replication-factor 1 --partitions 2 --topic test1</span><br></pre></td></tr></table></figure>

<h2 id="3-kafka中消息日志文件保存的内容"><a href="#3-kafka中消息日志文件保存的内容" class="headerlink" title="3.kafka中消息日志文件保存的内容"></a>3.kafka中消息日志文件保存的内容</h2><ul>
<li><p>000000000.log：这个文件保存的就是消息</p>
</li>
<li><p>__consumer_offsets-49：kafka内部创建了__consumer_offsets 主题包含了50个分区。这个主题用来存放消费者消费某个主题的偏移量。 </p>
<ul>
<li>存放数据内容是：key是consumerGroupId+topic+分区号，value就是当前offset的值，kafka会定期清理topic里的消息，最后就保留最新的那条数据。</li>
<li>kafka默认分配50个分区（可以通过offsets.topic.num.partitions设置），通过$hash(consumerGoupId) % __consumer_offsets主题的分区数$可以选出consumer消费的offset要提交到__consumer_offsets的哪个分区</li>
</ul>
</li>
<li><p>文件中保存的消息，默认保存七天。七天后消息会被删除。</p>
</li>
</ul>
<h1 id="五、kafka集群操作"><a href="#五、kafka集群操作" class="headerlink" title="五、kafka集群操作"></a>五、kafka集群操作</h1><h2 id="1-搭建kafka集群"><a href="#1-搭建kafka集群" class="headerlink" title="1. 搭建kafka集群"></a>1. 搭建kafka集群</h2><h2 id="2-副本的概念"><a href="#2-副本的概念" class="headerlink" title="2. 副本的概念"></a>2. 副本的概念</h2><p>在创建主题时，除了指明主题的分区数以外，还指明了副本数。副本是为了为主题中的分区创建多个副本，多个副本在kafka集群的多个broker中，会有一个副本作为leader，其他是follower。</p>
<ul>
<li>leader：kafka的写和读操作，都发生在leader上。leader负责把数据同步给followe。当leader挂了，经过主从选举，从多个follower中选举出一个新的leader（raft）。</li>
<li>follower：接收leader的同步数据</li>
<li>isr：可以同步和已同步的节点会被存入isr集合中。如果isr中的节点性能较差，会被踢出isr集合。</li>
</ul>
<p>集群中有多个broker，创建主题时可以指明主题有多个分区（把消息拆分到不同的分区中存储），可以为分区创建多个副本，不同的副本存放在不同的broker中。</p>
<h2 id="3-关于分区消费组消费者的细节"><a href="#3-关于分区消费组消费者的细节" class="headerlink" title="3. 关于分区消费组消费者的细节"></a>3. 关于分区消费组消费者的细节</h2><p>一个kafka集群有两个broker，每个broker中有多个partition。一个partition只能被一个消费组里的某一个消费者消费，从而保证消费顺序。kafka只在partition的范围内保证消息消费的局部顺序性，不能在同一个topic中的多个partition中保证总的消费顺序。一个消费者可以消费多个partition。</p>
<p>消费组中消费者的数量不能比一个topic中的partition数量多，否则多出来的消费者消费不到消息。</p>
<h1 id="六、Go操作kafka"><a href="#六、Go操作kafka" class="headerlink" title="六、Go操作kafka"></a>六、Go操作kafka</h1><h2 id="1-ack"><a href="#1-ack" class="headerlink" title="1. ack"></a>1. ack</h2><p>在同步发送的前提下，生产者在获得集群返回的ack之前会一直阻塞。分别有下面三种配置：</p>
<ul>
<li>ack&#x3D;0：kafka集群不需要任何的broker收到消息，就立即返回ack给生产者，最容易丢消息，效率最高。</li>
<li>ack&#x3D;1（默认）：多副本之间leader已经收到消息，并把消息写入到本地的log中，才会返回ack给生产者，性能和安全性最均衡的</li>
<li>ack&#x3D;-1&#x2F;all：等到集群内有超过配置的min.insync.replicas个broker写入本地消息才会返回ack，最安全，但性能最差</li>
</ul>
<h1 id="七、kafka集群controller、rebalance和HW"><a href="#七、kafka集群controller、rebalance和HW" class="headerlink" title="七、kafka集群controller、rebalance和HW"></a>七、kafka集群controller、rebalance和HW</h1><h2 id="1-Controller"><a href="#1-Controller" class="headerlink" title="1. Controller"></a>1. Controller</h2><p>集群的controller，负责管理整个集群中的所有分区和副本的状态：</p>
<ul>
<li>当某个分区的leader副本出现故障时，由控制器负责为该分区选举新的leader副本。</li>
<li>当检测到某个分区的ISR集合发生变化时，由控制器负责为该分区选举新的leader副本。</li>
<li>当使用kafka-topics.sh脚本为某个topic增加分区数量时，同样还是有controller负责让新分区被其他节点感知。</li>
</ul>
<h2 id="2-Rebalance机制"><a href="#2-Rebalance机制" class="headerlink" title="2. Rebalance机制"></a>2. Rebalance机制</h2><p>前提是：消费者没有指明分区消费。当消费组里消费者和分区的关系发送变化，就会出发rebalance机制。</p>
<p>这个机制会重新调整消费者消费哪个分区。</p>
<p>在触发rebalance机制之前，消费者消费哪个分区有三种策略：</p>
<ul>
<li>range：通过公式（总分区数&#x2F;消费组消费者总数）计算某个消费者消费哪个分区。</li>
<li>轮询：轮询消费</li>
<li>sticky：在触发rebalance后，在消费者消费的原分区不变的基础上进行调整。将挂掉的消费者所持有的分区分到剩下的消费者上。如果有消费者挂了，但是没用这种策略就需要重新分配。</li>
</ul>
<h2 id="3-HW和LEO"><a href="#3-HW和LEO" class="headerlink" title="3. HW和LEO"></a>3. HW和LEO</h2><p>LEO（log-end-offset）是某个副本最后消息的消息位置</p>
<p>HW俗称高水位，HighWatermark的缩写，取一个partition对应的ISR最小的LEO作为HW，consumer最多只能消费到HW所在的位置。另外每个replica都有HW，leader和follower各自负责更新自己的HW的状态。对于leader新写入的消息，consumer不能立刻消费，leader会等待该消息被所有ISR中的replicas同步后更新HW，此时消息才能被consumer消费。这样就保证了如果leader所在的broker失效，该消息仍然可以从新选举的leader中获取。</p>
<h1 id="八、kafka线上问题优化"><a href="#八、kafka线上问题优化" class="headerlink" title="八、kafka线上问题优化"></a>八、kafka线上问题优化</h1><h2 id="1-如何防止消息丢失"><a href="#1-如何防止消息丢失" class="headerlink" title="1. 如何防止消息丢失"></a>1. 如何防止消息丢失</h2><ul>
<li>发送方：1）使用同步发送 2）ack是1或者-1&#x2F;all可以防止消息丢失，如果要做到99.99999%，ack设为all，把min.insync.replicas配置成分区备份数。</li>
<li>消费方：把自动提交改为手动提交。</li>
</ul>
<h2 id="2-如何防止消息的重复消费"><a href="#2-如何防止消息的重复消费" class="headerlink" title="2. 如何防止消息的重复消费"></a>2. 如何防止消息的重复消费</h2><p>在防止消息丢失的方案中，如果生产者发送消息后，因为网络抖动，没有收到ack，但实际上broker已经收到了。此时生产者会进行重试，于是broker就会收到多条相同的消息，而造成消费者的重复消费。</p>
<p>解决方案：</p>
<ul>
<li><p>生产者关闭重试机制，但是容易造成消息丢失。</p>
</li>
<li><p>消费者解决幂等性消费问题：</p>
<p>幂等性：多次访问的结果是一样的。对于rest的请求（get（幂等），post（非幂等），put（幂等），delete（幂等））</p>
<p>解决方案：</p>
<ol>
<li>在数据库中创建联合主键，防止相同的主键创建多条记录</li>
<li>使用分布式锁，以业务id为锁，保证只有一条记录能够创建成功</li>
</ol>
</li>
</ul>
<h2 id="3-如何做到顺序消费"><a href="#3-如何做到顺序消费" class="headerlink" title="3. 如何做到顺序消费"></a>3. 如何做到顺序消费</h2><ul>
<li>发送方：在发送时将ack不能设置为0，d使用同步发送，等发送成功再发送下一条。确保消息是顺序发送的。</li>
<li>接收方：消息是发送到一个分区中，只能有一个消费组的消费者来接收消息。</li>
</ul>
<p>kafka的顺序消费使用场景不多，要想实现顺序消费会牺牲掉性能，可以使用rocketMQ。</p>
<h2 id="4-消息积压"><a href="#4-消息积压" class="headerlink" title="4. 消息积压"></a>4. 消息积压</h2><h3 id="1）消息积压问题的出现"><a href="#1）消息积压问题的出现" class="headerlink" title="1）消息积压问题的出现"></a>1）消息积压问题的出现</h3><p>消息的消费者的消费速度远赶不上生产者生产消息的速度，导致kafka中有大量的数据没有被消费。随着没有被消费的数据堆积越多，消费者寻址的性能会越来越差，最后导致整个kafka对外提供服务的性能很差，从而造成其他服务的访问速度变慢，造成服务雪崩。</p>
<h3 id="2）消息积压的解决法方案"><a href="#2）消息积压的解决法方案" class="headerlink" title="2）消息积压的解决法方案"></a>2）消息积压的解决法方案</h3><ul>
<li>在这个消费者中，使用多线程，充分利用机器的性能进行消费消息。</li>
<li>创建多个消费组，多个消费者，部署到其他机器上，一起消费，提高消费者的消费速度。</li>
<li>创建一个消费者，该消费者在kafka另建一个主题，配上多个分区，多个分区再配上多个消费者。该消费者将poll下来的消息，不进行消费，直接转发到新建的主题上。此时，新的主题的多个分区的多个消费者就开始一起消费了。</li>
</ul>
<h2 id="5-实现延迟队列的效果"><a href="#5-实现延迟队列的效果" class="headerlink" title="5. 实现延迟队列的效果"></a>5. 实现延迟队列的效果</h2><h3 id="1）应用场景"><a href="#1）应用场景" class="headerlink" title="1）应用场景"></a>1）应用场景</h3><p>订单创建后，超过30分钟没有支付，则需要取消订单，这种场景可以通过延时队列来实现</p>
<h3 id="2）具体方案"><a href="#2）具体方案" class="headerlink" title="2）具体方案"></a>2）具体方案</h3><ul>
<li>kafka中创建相应的主题</li>
<li>消费者消费该主题的消息（轮询）</li>
<li>消费者消费消息时判断消息的创建时间和当前时间是否超过30分钟（前提是订单没支付）<ul>
<li>如果是：去数据库中修改订单状态为已取消</li>
<li>如果否：记录当前消息的offset，并不再继续消费之后的消息。等待一段时间后，再次想kafka拉去该offset及之后的消息，继续进行判断，以此重复。</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://cy77cc.github.io/2025/03/25/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/" data-id="cm8s98nmj0009f8lzakov0adh" data-title="各种消息队列MQ的学习记录" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-我的golang面试总结" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/03/22/%E6%88%91%E7%9A%84golang%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/" class="article-date">
  <time class="dt-published" datetime="2025-03-22T01:11:00.000Z" itemprop="datePublished">2025-03-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/03/22/%E6%88%91%E7%9A%84golang%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/">golang学习笔记</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="函数传参的问题"><a href="#函数传参的问题" class="headerlink" title="函数传参的问题"></a>函数传参的问题</h1><p>在Go语言里面所有的函数传参都是值传递，无论是值类型（int、string、struct等等）还是引用类型（map、slice）等等</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://cy77cc.github.io/2025/03/22/%E6%88%91%E7%9A%84golang%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/" data-id="cm8s98nmf0001f8lz3vf5hknn" data-title="golang学习笔记" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/golang/" rel="tag">golang</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-MySQL" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/03/20/MySQL/" class="article-date">
  <time class="dt-published" datetime="2025-03-20T12:32:00.000Z" itemprop="datePublished">2025-03-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/03/20/MySQL/">MySQL是怎样运行的读书笔记</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="一、初识MySQL"><a href="#一、初识MySQL" class="headerlink" title="一、初识MySQL"></a>一、初识MySQL</h2><h3 id="1-1-MySQL的客户端-服务端架构"><a href="#1-1-MySQL的客户端-服务端架构" class="headerlink" title="1.1 MySQL的客户端&#x2F;服务端架构"></a>1.1 MySQL的客户端&#x2F;服务端架构</h3><p>MySQL采用C&#x2F;S的架构，在客户端程序中输入语句命令，并将其作为请求发送到服务器程序。服务器程序在收到这些请求后，根据请求的内容来操作具体的数据，并将结果返回给客户的。</p>
<h3 id="1-2-启动MySQL服务器程序"><a href="#1-2-启动MySQL服务器程序" class="headerlink" title="1.2 启动MySQL服务器程序"></a>1.2 启动MySQL服务器程序</h3><h4 id="1-2-1-MySQL的启动服务程序"><a href="#1-2-1-MySQL的启动服务程序" class="headerlink" title="1.2.1 MySQL的启动服务程序"></a>1.2.1 MySQL的启动服务程序</h4><ol>
<li>mysqld</li>
<li>mysqld_safe：mysqld_safe是一个启动脚本会间接调用mysqld，并监测mysql服务器的运行状态。当mysql服务器发送错误时，可以帮助重启服务器程序。在启动MySQL服务器程序时，它会将服务器程序的出错信息和其他诊断信息输出到错误日志。</li>
<li>mysql.server：也是一个启动脚本，会间接调用mysqld_safe。</li>
<li>mysqld_multi：可以在一台计算机上启动多个服务器程序。</li>
</ol>
<h4 id="1-2-2-windows启动MySQL服务"><a href="#1-2-2-windows启动MySQL服务" class="headerlink" title="1.2.2 windows启动MySQL服务"></a>1.2.2 windows启动MySQL服务</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">net <span class="built_in">start</span> MySQL   <span class="comment">#需要管理员权限</span></span><br><span class="line">net stop MySQL</span><br></pre></td></tr></table></figure>

<h3 id="1-3-启动MySQL客户端程序"><a href="#1-3-启动MySQL客户端程序" class="headerlink" title="1.3 启动MySQL客户端程序"></a>1.3 启动MySQL客户端程序</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql <span class="literal">-h</span> <span class="literal">-p</span> <span class="literal">-P</span> <span class="literal">-e</span></span><br><span class="line"><span class="literal">-h</span> 指定连接的地址</span><br><span class="line"><span class="literal">-p</span> 密码</span><br><span class="line"><span class="literal">-P</span> 连接的端口</span><br><span class="line"><span class="literal">-e</span> 执行MySQL语句</span><br><span class="line"><span class="literal">-u</span> 连接的用户</span><br></pre></td></tr></table></figure>

<h3 id="1-4-客户端与服务器连接的过程"><a href="#1-4-客户端与服务器连接的过程" class="headerlink" title="1.4 客户端与服务器连接的过程"></a>1.4 客户端与服务器连接的过程</h3><p>客户端进程向服务器进程发送请求并得到相应的过程本质上是一个进程间通信的过程。MySQL支持下面集中客户端进程和服务器进程的通信方式。</p>
<ol>
<li>TCP&#x2F;IP</li>
</ol>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql <span class="literal">-u</span> root <span class="literal">-p</span> <span class="literal">-h</span> <span class="number">127.0</span>.<span class="number">0.1</span> <span class="literal">-P</span> <span class="number">3306</span></span><br><span class="line">连接到本地的<span class="number">3306</span>端口，指定用户为root</span><br></pre></td></tr></table></figure>
<ol start="2">
<li><p>命令管道和共享内存</p>
<ul>
<li><p>使用命名管道进行进程间通信：需要在启动服务器程序的命令中加上–enable-named-pipe参数，然后在启动客户端程序的命令中加上–pipe或者–protocol&#x3D;pipe参数。</p>
</li>
<li><p>使用共享内存进行进程间通信：需要在启动服务器程序的命令中加上–shared-memory参数。在启动客户端程序的命令加上–protocol&#x3D;memory参数。</p>
</li>
</ul>
</li>
<li><p>unix套接字</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql <span class="literal">-h</span> localhost <span class="literal">-u</span> root <span class="literal">--socket</span>=/tmp/mysql.sock</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="1-5-服务器处理客户端请求"><a href="#1-5-服务器处理客户端请求" class="headerlink" title="1.5 服务器处理客户端请求"></a>1.5 服务器处理客户端请求</h3><ol>
<li>连接管理</li>
<li>解析与优化<ol>
<li>查询缓存</li>
<li>语法解析</li>
<li>查询优化</li>
</ol>
</li>
<li>存储引擎</li>
</ol>
<h3 id="1-6-常用存储引擎"><a href="#1-6-常用存储引擎" class="headerlink" title="1.6 常用存储引擎"></a>1.6 常用存储引擎</h3><table>
<thead>
<tr>
<th>存储引擎</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>ARCHIVE</td>
<td>用户数据存档（记录插入后不能再修改）</td>
</tr>
<tr>
<td>BLACKHOLE</td>
<td>丢弃写操作，读操作会返回空内容</td>
</tr>
<tr>
<td>CSV</td>
<td>在存储数据时，以逗号分隔各个数据项</td>
</tr>
<tr>
<td>FEDERATED</td>
<td>用来访问远程表</td>
</tr>
<tr>
<td>InnoDB</td>
<td>支持事务、行级锁、外键</td>
</tr>
<tr>
<td>MEMORY</td>
<td>数据只存储在内存，不存储在磁盘；多用于临时表</td>
</tr>
<tr>
<td>MERGE</td>
<td>用来管理多个MyISAM表构成的表集合</td>
</tr>
<tr>
<td>MyISAM</td>
<td>主要的非事务处理存储引擎</td>
</tr>
<tr>
<td>NDB</td>
<td>MySQL集群专用存储引擎</td>
</tr>
</tbody></table>
<h2 id="二、启动选项和系统变量"><a href="#二、启动选项和系统变量" class="headerlink" title="二、启动选项和系统变量"></a>二、启动选项和系统变量</h2><p><img src="https://raw.githubusercontent.com/cy77cc/pic-md/master/image-20250405105945819.png" alt="image-20250405105945819"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://cy77cc.github.io/2025/03/20/MySQL/" data-id="cm8hdw72n0000bclzf1450hbi" data-title="MySQL是怎样运行的读书笔记" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="tag">数据库</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-redis" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/03/20/redis/" class="article-date">
  <time class="dt-published" datetime="2025-03-20T12:16:00.000Z" itemprop="datePublished">2025-03-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/03/20/redis/">Redis</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="什么是Redis，Redis有哪些特点"><a href="#什么是Redis，Redis有哪些特点" class="headerlink" title="什么是Redis，Redis有哪些特点"></a>什么是Redis，Redis有哪些特点</h2><p>Redis全程为：Remote Dictionary Server（远程数据服务），Redis是一种支持key-value等多种数据结构的存储系统。可用于缓存，时间发布订阅或高速队列等场景。支持网络，提供string，hash，list，queue，set等数据结构直接存取，基于内存，可持久化。</p>
<h2 id="一、常用类型"><a href="#一、常用类型" class="headerlink" title="一、常用类型"></a>一、常用类型</h2><h3 id="String字符串"><a href="#String字符串" class="headerlink" title="String字符串"></a>String字符串</h3><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><p>存用户token，session id等信息都行，太多了。</p>
<h4 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h4><table>
<thead>
<tr>
<th>命令</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>set key value</td>
<td>设置一个key value</td>
</tr>
<tr>
<td>mset key value key value</td>
<td>同时设置多个key value</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<h3 id="List列表"><a href="#List列表" class="headerlink" title="List列表"></a>List列表</h3><h4 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h4><p>可以当简单的消息队列用</p>
<h4 id="常用命令-1"><a href="#常用命令-1" class="headerlink" title="常用命令"></a>常用命令</h4><table>
<thead>
<tr>
<th>命令</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>lpush key value</td>
<td>从左边向key插入一个数据</td>
</tr>
<tr>
<td>rpush key value</td>
<td>从右边向key插入一个数据</td>
</tr>
<tr>
<td>lpop key</td>
<td>从左边弹出一个数据</td>
</tr>
<tr>
<td>rpop key</td>
<td>从右边弹出一个数据</td>
</tr>
<tr>
<td>lrange key start end</td>
<td>从start开始遍历list到end</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<h3 id="Set集合"><a href="#Set集合" class="headerlink" title="Set集合"></a>Set集合</h3><h4 id="使用场景-2"><a href="#使用场景-2" class="headerlink" title="使用场景"></a>使用场景</h4><p>去重，用户共同好友，需要求交集，并集等这些场景。</p>
<h3 id="ZSet有序集合"><a href="#ZSet有序集合" class="headerlink" title="ZSet有序集合"></a>ZSet有序集合</h3><h4 id="使用场景-3"><a href="#使用场景-3" class="headerlink" title="使用场景"></a>使用场景</h4><p>游戏排行榜</p>
<h3 id="Hash哈希表"><a href="#Hash哈希表" class="headerlink" title="Hash哈希表"></a>Hash哈希表</h3><h4 id="使用场景-4"><a href="#使用场景-4" class="headerlink" title="使用场景"></a>使用场景</h4><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>hgetall 如果字段太多的话会阻塞。</p>
<h3 id="Bitmap位图"><a href="#Bitmap位图" class="headerlink" title="Bitmap位图"></a>Bitmap位图</h3><h4 id="使用场景-5"><a href="#使用场景-5" class="headerlink" title="使用场景"></a>使用场景</h4><p>统计用户登陆，布隆过滤器，统计活跃用户量</p>
<h3 id="Stream流"><a href="#Stream流" class="headerlink" title="Stream流"></a>Stream流</h3><h4 id="使用场景-6"><a href="#使用场景-6" class="headerlink" title="使用场景"></a>使用场景</h4><p>消息队列，官方也是想实现成消息队列</p>
<h2 id="二、持久化方案"><a href="#二、持久化方案" class="headerlink" title="二、持久化方案"></a>二、持久化方案</h2><h3 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h3><h3 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h3><h2 id="三、主从集群"><a href="#三、主从集群" class="headerlink" title="三、主从集群"></a>三、主从集群</h2><p>从节点从主节点复制数据，复制主节点的RDB文件，实现数据的复制。</p>
<h2 id="四、哨兵"><a href="#四、哨兵" class="headerlink" title="四、哨兵"></a>四、哨兵</h2><p>在集群的方案中，如果是从节点挂了那对集群影响也不大，如果主节点挂了那就凉凉，那么这个集群就相当于废了。因为一般来说主从方式时，都是主节点用来写数据，从节点读数据。如果主节点挂了，从节点也不知道从哪里复制备份数据。一般是一主两从。</p>
<h2 id="五、缓存三件套"><a href="#五、缓存三件套" class="headerlink" title="五、缓存三件套"></a>五、缓存三件套</h2><h3 id="1、缓存穿透"><a href="#1、缓存穿透" class="headerlink" title="1、缓存穿透"></a>1、缓存穿透</h3><p>缓存穿透是指要访问的数据既不在缓存中，也不在数据库中，导致请求在访问缓存时，发生缓存缺失，访问数据库时，发现数据库中也没有要访问的数据。这时就无法从数据库中加载数据到缓存中，后续的请求会一直按照访问缓存，访问数据库的流程访问这个不存在的数据，给缓存和数据库带来了很大的压力。</p>
<h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><ul>
<li>使用布隆过滤器判断数据是否存在，布隆过滤器的原理是将key通过hash的方式映射到位图上。如果一个key存在，布隆过滤器不能保证正确判断一个key一定存在，但是可以保存判断不存在的key一定不存在。</li>
<li>缓存空值，当缓存和数据库都不存在时，直接缓存一个空值到缓存中，过期时间设置短一些。</li>
</ul>
<h3 id="2、缓存击穿"><a href="#2、缓存击穿" class="headerlink" title="2、缓存击穿"></a>2、缓存击穿</h3><p>缓存击穿是指一个key过期了，但是却有大量的请求访问这个key。因此，这个时候所有的访问都会打到数据库上，导致数据库压力过大。</p>
<h4 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h4><ul>
<li>每次访问key时，如果key存在给key续约一段时间。</li>
<li>Go语言里面的singleflight。singleflight的原理是当同时有很多请求同时到达时，最终只有一个请求会最终访问到资源，其他请求都会等待结果然后返回。</li>
<li>加锁访问。cache miss 后请求DB之前必须先获取分布式锁，取锁失败说明是有其他请求在查询DB了，当前请求只需要循环等待并查询Redis检测取锁成功的请求把数据回写到Redis没有，如果有的话当前请求就可以直接从缓存中取数据返回了。</li>
</ul>
<h3 id="3、缓存雪崩"><a href="#3、缓存雪崩" class="headerlink" title="3、缓存雪崩"></a>3、缓存雪崩</h3><p>缓存雪崩时指大量的的应用请求无法在Redis缓存中进行处理，紧接着应用将大量的请求发送到数据库，导致数据库被打挂，好惨呐！！缓存雪崩一般是由两个原因导致的，应对方案也不太一样。</p>
<h4 id="1-大量缓存数据同时过期"><a href="#1-大量缓存数据同时过期" class="headerlink" title="1. 大量缓存数据同时过期"></a>1. 大量缓存数据同时过期</h4><p>​	在固定的过期时间上加一个随机过期时间</p>
<h4 id="2-缓存服务器挂了"><a href="#2-缓存服务器挂了" class="headerlink" title="2. 缓存服务器挂了"></a>2. 缓存服务器挂了</h4><p>​	熔断，保护数据库。</p>
<h2 id="六、缓存一致性"><a href="#六、缓存一致性" class="headerlink" title="六、缓存一致性"></a>六、缓存一致性</h2><p><img src="https://raw.githubusercontent.com/cy77cc/pic-md/master/image-20250331104253859.png" alt="image-20250331104253859"></p>
<p>缓存一致性是加入缓存后需要解决的一个重要问题，最核心的就是保证缓存和数据库的数据是一致的。主要存在的情况是在数据更新和删除的过程中，怎么保证数据库和缓存都是更新或删除的数据。</p>
<ul>
<li>更新：1）如果先更新缓存再更新数据库，高并发的情况下会存在缓存不一致的情况。例如，如果缓存更新后，数据库还没来得及更新或者更新失败，请求就来了，这时会从缓存中取到脏数据。2）如果先更新数据库再更新缓存，那么请求会从缓存中拿到还没更新的数据。</li>
<li>删除：1）先删除缓存后删除数据库，一般情况没问题。2）先删除数据库再删除缓存，会出现数据库已经删了，缓存还没来得及删除就有请求来了。</li>
</ul>
<h3 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案"></a>解决方案</h3><ul>
<li>无论是更新还是删除，都先删除缓存再更新删除数据库。删除缓存后更新数据库可以保证只需要考虑数据库能否正常更新删除。在下一次请求来时将数据加载到缓存中，可以保证缓存和数据库的数据是一致的。也可以使用canal监听数据库的变化，将变化的数据通过消息队列异步更新到缓存中。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://cy77cc.github.io/2025/03/20/redis/" data-id="cm8hdw72q0001bclz3lof6820" data-title="Redis" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="tag">数据库</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">weiter &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/docker/" rel="tag">docker</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/go/" rel="tag">go</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/golang/" rel="tag">golang</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mq/" rel="tag">mq</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/nginx/" rel="tag">nginx</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/tool/" rel="tag">tool</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6-docker-kubernetes/" rel="tag">中间件,docker,kubernetes</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F/" rel="tag">分布式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="tag">数据库</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/docker/" style="font-size: 10px;">docker</a> <a href="/tags/go/" style="font-size: 10px;">go</a> <a href="/tags/golang/" style="font-size: 20px;">golang</a> <a href="/tags/mq/" style="font-size: 10px;">mq</a> <a href="/tags/nginx/" style="font-size: 10px;">nginx</a> <a href="/tags/tool/" style="font-size: 10px;">tool</a> <a href="/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6-docker-kubernetes/" style="font-size: 10px;">中间件,docker,kubernetes</a> <a href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F/" style="font-size: 10px;">分布式</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" style="font-size: 20px;">数据库</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archiv</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/04/">April 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/03/">March 2025</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">letzter Beitrag</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2025/04/06/Kubernetes%EF%BC%88k8s%EF%BC%89/">k8s学习记录</a>
          </li>
        
          <li>
            <a href="/2025/04/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">Go设计模式</a>
          </li>
        
          <li>
            <a href="/2025/04/04/nginx/">Nginx</a>
          </li>
        
          <li>
            <a href="/2025/04/04/Git/">Git</a>
          </li>
        
          <li>
            <a href="/2025/04/04/docker/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2025 Mr. Zhang<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>