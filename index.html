<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>cy77cc</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="cy77cc">
<meta property="og:url" content="https://cy77cc.github.io/index.html">
<meta property="og:site_name" content="cy77cc">
<meta property="og:locale">
<meta property="article:author" content="Mr. Zhang">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="cy77cc" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/fork-awesome@1.2.0/css/fork-awesome.min.css">

<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">cy77cc</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Buscar"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Buscar"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://cy77cc.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-Kubernetes（k8s）" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/04/06/Kubernetes%EF%BC%88k8s%EF%BC%89/" class="article-date">
  <time class="dt-published" datetime="2025-04-06T01:21:00.000Z" itemprop="datePublished">2025-04-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/04/06/Kubernetes%EF%BC%88k8s%EF%BC%89/">k8s学习记录</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>有状态和无状态</p>
<ul>
<li>会保存数据的是有状态</li>
<li>不保存数据的是无状态</li>
</ul>
<h2 id="一、环境准备"><a href="#一、环境准备" class="headerlink" title="一、环境准备"></a>一、环境准备</h2><p>3台虚拟机，至少是2C2G，互相能ping通</p>
<h3 id="1-1-下载RockyLinux9"><a href="#1-1-下载RockyLinux9" class="headerlink" title="1.1 下载RockyLinux9"></a>1.1 下载RockyLinux9</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://rockylinux.org/download</span><br></pre></td></tr></table></figure>

<h3 id="1-2-环境初始化"><a href="#1-2-环境初始化" class="headerlink" title="1.2 环境初始化"></a>1.2 环境初始化</h3><p>三个node的配置差不多，ip地址换一下就行</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">网卡配置</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">cat</span> /etc/NetworkManager/system-connections/ens160.nmconnection</span></span><br><span class="line">[ipv4]</span><br><span class="line">address1=192.168.66.11/24</span><br><span class="line">method=manual</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">调用 nmcli 重启设备和连接配置</span></span><br><span class="line">nmcli d r ens160 </span><br><span class="line">nmcli c r ens160</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">更换yum源</span></span><br><span class="line">sed -e &#x27;s|^mirrorlist=|#mirrorlist=|g&#x27; \</span><br><span class="line">    -e &#x27;s|^#baseurl=http://dl.rockylinux.org/$contentdir|baseurl=https://mirrors.aliyun.com/rockylinux|g&#x27; \</span><br><span class="line">    -i.bak \</span><br><span class="line">    /etc/yum.repos.d/Rocky-*.repo</span><br><span class="line"></span><br><span class="line">dnf makecache</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">防火墙修改 firewalld 为 iptables</span></span><br><span class="line">systemctl stop firewalld</span><br><span class="line">systemctl disable firewalld</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">可选</span></span><br><span class="line">yum -y install iptables-services</span><br><span class="line">systemctl start iptables</span><br><span class="line">iptables -F</span><br><span class="line">systemctl enable iptables</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">禁用 Selinux</span></span><br><span class="line">setenforce 0</span><br><span class="line">sed -i &quot;s/SELINUX=enforcing/SELINUX=disabled/g&quot; /etc/selinux/config</span><br><span class="line">grubby --update-kernel ALL --args selinux=0</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置时区</span></span><br><span class="line">timedatectl set-timezone Asia/Shanghai</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">关闭 swap 分区</span></span><br><span class="line">swapoff -a</span><br><span class="line">sed -i &#x27;s:/dev/mapper/rl-swap:#/dev/mapper/rl-swap:g&#x27; /etc/fstab</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">修改主机名</span></span><br><span class="line">hostnamectl  set-hostname k8s-node01</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装 ipvs</span></span><br><span class="line">yum install -y ipvsadm</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">开启路由转发</span></span><br><span class="line">echo &#x27;net.ipv4.ip_forward=1&#x27; &gt;&gt; /etc/sysctl.conf</span><br><span class="line">sysctl -p</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">加载 bridge</span></span><br><span class="line">yum install -y epel-release</span><br><span class="line">yum install -y bridge-utils</span><br><span class="line"></span><br><span class="line">modprobe br_netfilter</span><br><span class="line">echo &#x27;br_netfilter&#x27; &gt;&gt; /etc/modules-load.d/bridge.conf</span><br><span class="line">echo &#x27;net.bridge.bridge-nf-call-iptables=1&#x27; &gt;&gt; /etc/sysctl.conf</span><br><span class="line">echo &#x27;net.bridge.bridge-nf-call-ip6tables=1&#x27; &gt;&gt; /etc/sysctl.conf</span><br><span class="line">sysctl -p</span><br></pre></td></tr></table></figure>

<h3 id="1-3-安装docker"><a href="#1-3-安装docker" class="headerlink" title="1.3 安装docker"></a>1.3 安装docker</h3><p>k8s也不一定要用docker作为容器运行时，可以直接使用containerd，k8s好像默认的也是containerd，使用docker作为容器运行起还需要安装cir-dockerd。参考链接 <a target="_blank" rel="noopener" href="https://docs.docker.com/engine/install/rhel/">https://docs.docker.com/engine/install/rhel/</a></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">移除旧版本</span></span><br><span class="line">sudo dnf remove docker \</span><br><span class="line">                  docker-client \</span><br><span class="line">                  docker-client-latest \</span><br><span class="line">                  docker-common \</span><br><span class="line">                  docker-latest \</span><br><span class="line">                  docker-latest-logrotate \</span><br><span class="line">                  docker-logrotate \</span><br><span class="line">                  docker-engine \</span><br><span class="line">                  podman \</span><br><span class="line">                  runc</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">添加仓库</span>                  </span><br><span class="line">sudo dnf -y install dnf-plugins-core</span><br><span class="line">sudo dnf config-manager --add-repo https://download.docker.com/linux/rhel/docker-ce.repo</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">下载最新版本的docker</span></span><br><span class="line">sudo dnf install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置开启自启动</span></span><br><span class="line">sudo systemctl enable --now docker</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">这里还需要配置docker的镜像，阿里云的镜像加速已经没用了，需要另外找</span></span><br><span class="line">sudo mkdir -p /etc/docker</span><br><span class="line">sudo tee /etc/docker/daemon.json &lt;&lt;-&#x27;EOF&#x27;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [&quot;https://xxxx.mirror.aliyuncs.com&quot;]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure>

<h3 id="1-4-安装cri-dockerd"><a href="#1-4-安装cri-dockerd" class="headerlink" title="1.4 安装cri-dockerd"></a>1.4 安装cri-dockerd</h3><p>docker之前的运行时在k8s v1.24移除了，所以现在要额外安装cri-dockerd才能用docker作为k8s的容器运行时。参考链接（<a target="_blank" rel="noopener" href="https://mirantis.github.io/cri-dockerd/usage/install-manually/%EF%BC%89">https://mirantis.github.io/cri-dockerd/usage/install-manually/）</a></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在github下载cri-dockerd</span></span><br><span class="line">wget https://github.com/Mirantis/cri-dockerd/releases/download/v0.3.17/cri-dockerd-0.3.17.amd64.tgz</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">解压</span></span><br><span class="line">tar -zxvf cri-dockerd-0.3.17.amd64.tgz</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装</span></span><br><span class="line">install -o root -g root -m 0755 cri-dockerd 解压的cri-dcokerd路径/bin/cri-dockerd</span><br><span class="line">install packaging/systemd/* /etc/systemd/system</span><br><span class="line">sed -i -e &#x27;s,/usr/bin/cri-dockerd,/usr/local/bin/cri-dockerd,&#x27; /etc/systemd/system/cri-docker.service</span><br><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl enable --now cri-docker.socket</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果要在k8s中使用添加一些配置</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">需要追加--network-plugin=cni，通过该配置告诉容器，使用kubernetes的网络接口</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">覆盖沙盒 (pause) 镜像，正常情况下，国内你是拉取不到k8s.gcr.io/pause:3.8镜像的，可以换成国内的registry.aliyuncs.com/google_containers/pause:3.10，这个镜像是一切的 Pod 的基础，要么自己手动导入进来，要么改成国内的镜像，通过设置以下配置来覆盖默认的沙盒镜像</span></span><br><span class="line">ExecStart=/usr/bin/cri-dockerd --container-runtime-endpoint fd:// --network-plugin=cni --pod-infra-container-image=registry.aliyuncs.com/google_containers/pause:3.10</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重新启动cri-dockers服务</span></span><br><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl enable cri-docker.service</span><br><span class="line">systemctl enable --now cri-docker.socket</span><br><span class="line">systemctl restart cri-dockerd</span><br></pre></td></tr></table></figure>

<h3 id="1-5-安装kubernetes"><a href="#1-5-安装kubernetes" class="headerlink" title="1.5 安装kubernetes"></a>1.5 安装kubernetes</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">此操作会覆盖 /etc/yum.repos.d/kubernetes.repo 中现存的所有配置</span></span><br><span class="line">cat &lt;&lt;EOF | sudo tee /etc/yum.repos.d/kubernetes.repo</span><br><span class="line">[kubernetes]</span><br><span class="line">name=Kubernetes</span><br><span class="line">baseurl=https://pkgs.k8s.io/core:/stable:/v1.31/rpm/</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=1</span><br><span class="line">gpgkey=https://pkgs.k8s.io/core:/stable:/v1.31/rpm/repodata/repomd.xml.key</span><br><span class="line">exclude=kubelet kubeadm kubectl cri-tools kubernetes-cni</span><br><span class="line">EOF</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装软件</span></span><br><span class="line">sudo yum install -y kubelet kubeadm kubectl --disableexcludes=kubernetes</span><br><span class="line">sudo systemctl enable --now kubelet</span><br></pre></td></tr></table></figure>

<h3 id="1-6-搭建集群"><a href="#1-6-搭建集群" class="headerlink" title="1.6 搭建集群"></a>1.6 搭建集群</h3><p>上面的操作需要在三个节点都执行一遍，也可以执行完后克隆虚拟机，修改ip地址</p>
<h4 id="1-6-1-修改三个虚拟机的hostname"><a href="#1-6-1-修改三个虚拟机的hostname" class="headerlink" title="1.6.1 修改三个虚拟机的hostname"></a>1.6.1 修改三个虚拟机的hostname</h4><p>修改节点的hostname，这样就可以直接知识honstname访问node，添加到host</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">分别在不同虚拟机执行</span></span><br><span class="line">hostnamectl  set-hostname k8s-node1</span><br><span class="line">hostnamectl  set-hostname k8s-master</span><br><span class="line">hostnamectl  set-hostname k8s-node2</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">添加到host文件</span></span><br><span class="line">vim /etc/hosts</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">添加解析</span></span><br><span class="line">192.168.66.11 k8s-master</span><br><span class="line">192.168.66.22 k8s-node1</span><br><span class="line">192.168.66.33 k8s-node2</span><br></pre></td></tr></table></figure>

<h4 id="1-6-2-初始化主节点"><a href="#1-6-2-初始化主节点" class="headerlink" title="1.6.2 初始化主节点"></a>1.6.2 初始化主节点</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">kubeadm init </span><br><span class="line">--apiserver-advertise-address=192.168.66.11    # apiserver地址</span><br><span class="line">--image-repository registry.aliyuncs.com/google_containers # 镜像仓库</span><br><span class="line">--kubernetes-version 1.32.3 # k8s的版本，使用kubectl version 查看，要和自己的版本对应 </span><br><span class="line">--service-cidr=10.10.0.0/12 </span><br><span class="line">--pod-network-cidr=10.244.0.0/16 # pod的地址</span><br><span class="line">--ignore-preflight-errors=all </span><br><span class="line">--cri-socket unix:///var/run/cri-dockerd.sock # 使用docker作为容器运行时，如果使用containerd可以不加</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">上面命令执行完后会提示执行三条命令，已经从节点怎么加入集群的命令，记得注意结尾的命令</span></span><br></pre></td></tr></table></figure>

<h4 id="1-6-3-从节点加入集群"><a href="#1-6-3-从节点加入集群" class="headerlink" title="1.6.3 从节点加入集群"></a>1.6.3 从节点加入集群</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">这里的token是在上面初始化主节点后输出的，拷贝过来，添加cri-dockerd的socket套接字执行</span></span><br><span class="line">kubeadm join 192.168.10.11:6443 --token a6xh07.yg9wh2vru2grluwb         --discovery-token-ca-cert-hash sha256:7cd8499abae48c8403800152cc0f655ac704ea00ae30a549acd9bbac7b26dca4 --cri-socket unix:///var/run/cri-dockerd.sock</span><br></pre></td></tr></table></figure>

<h3 id="1-7-部署网络插件"><a href="#1-7-部署网络插件" class="headerlink" title="1.7 部署网络插件"></a>1.7 部署网络插件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">下载配置文件</span></span><br><span class="line">curl https://raw.githubusercontent.com/projectcalico/calico/v3.29.3/manifests/calico.yaml -O</span><br><span class="line"></span><br><span class="line">vim calico.yaml</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">修改ipv4的地址为上面初始化主节点时的pod地址</span></span><br><span class="line">- name: CALICO_IPV4POOL_CIDR</span><br><span class="line">  value: &quot;10.244.0.0/16&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">修改为 BGP 模式</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Enable IPIP</span></span><br><span class="line">- name: CALICO_IPV4POOL_IPIP</span><br><span class="line">  value: &quot;Always&quot;  #改成Off</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">把配置文件里面的所有docker.io都删除，不然下载不到容器</span></span><br><span class="line">sed -i &#x27;s|docker.io/||g&#x27; calico.yaml</span><br><span class="line"></span><br><span class="line">kubectl apply -f calico.yaml  #等待容器安装完成即可</span><br></pre></td></tr></table></figure>

<h3 id="1-8-修改kube-proxy模式为ipvs"><a href="#1-8-修改kube-proxy模式为ipvs" class="headerlink" title="1.8 修改kube-proxy模式为ipvs"></a>1.8 修改kube-proxy模式为ipvs</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">kubectl edit configmap kube-proxy -n kube-system</span></span><br><span class="line">mode: ipvs</span><br><span class="line"></span><br><span class="line">kubectl delete pod -n kube-system -l k8s-app=kube-proxy</span><br></pre></td></tr></table></figure>



<h2 id="二、概念"><a href="#二、概念" class="headerlink" title="二、概念"></a>二、概念</h2><p>Kubernetes 主要由以下几个核心组件组成：</p>
<ul>
<li>etcd 保存了整个集群的状态；</li>
<li>apiserver 提供了资源操作的唯一入口，并提供认证、授权、访问控制、API 注册和发现等机制；</li>
<li>controller manager 负责维护集群的状态，比如故障检测、自动扩展、滚动更新等；</li>
<li>scheduler 负责资源的调度，按照预定的调度策略将 Pod 调度到相应的机器上；</li>
<li>kubelet 负责维护容器的生命周期，同时也负责 Volume（CSI）和网络（CNI）的管理；</li>
<li>Container runtime 负责镜像管理以及 Pod 和容器的真正运行（CRI）；</li>
<li>kube-proxy 负责为 Service 提供 cluster 内部的服务发现和负载均衡；</li>
</ul>
<p>除了核心组件，还有一些推荐的插件，其中有的已经成为 CNCF 中的托管项目：</p>
<ul>
<li>CoreDNS 负责为整个集群提供 DNS 服务</li>
<li>Ingress Controller 为服务提供外网入口</li>
<li>Prometheus 提供资源监控</li>
<li>Dashboard 提供 GUI</li>
<li>Federation 提供跨可用区的集群</li>
</ul>
<h2 id="三、资源"><a href="#三、资源" class="headerlink" title="三、资源"></a>三、资源</h2><p> k8s中所有的内容都抽象为资源，资源实例化之后叫做对象。</p>
<h3 id="2-1-资源类别"><a href="#2-1-资源类别" class="headerlink" title="2.1 资源类别"></a>2.1 资源类别</h3><ol>
<li>命名空间级别<ul>
<li>工作负载型资源：Pod、ReplicaSet、Deployment ……</li>
<li>服务发现及负载均衡型资源类型：Service、Ingress ……</li>
<li>配置与存储型资源：Volume、CSI ……</li>
<li>特殊类型的存储卷：ConfigMap、Secre ……</li>
</ul>
</li>
<li>集群级资源<ul>
<li>Namespace、Node、ClusterRole、ClusterRoleBinding</li>
</ul>
</li>
<li>元数据型资源<ul>
<li>HPA、PodTemplate、LimitRange</li>
</ul>
</li>
</ol>
<h3 id="2-2-资源清单的编写"><a href="#2-2-资源清单的编写" class="headerlink" title="2.2 资源清单的编写"></a>2.2 资源清单的编写</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl api-versions  # 获取api版本</span><br></pre></td></tr></table></figure>

<p>几乎每个 Kubernetes 对象包含两个嵌套的对象字段，它们负责管理对象的配置： 对象 <strong><code>spec</code>（规约）</strong> 和对象 <strong><code>status</code>（状态）</strong>。 对于具有 <code>spec</code> 的对象，你必须在创建对象时设置其内容，描述你希望对象所具有的特征： <strong>期望状态（Desired State）</strong>。</p>
<p><code>status</code> 描述了对象的<strong>当前状态（Current State）</strong>，它是由 Kubernetes 系统和组件设置并更新的。在任何时刻，Kubernetes <a target="_blank" rel="noopener" href="https://kubernetes.io/zh-cn/docs/reference/glossary/?all=true#term-control-plane">控制平面</a> 都一直在积极地管理着对象的实际状态，以使之达成期望状态。</p>
<p>例如，Kubernetes 中的 Deployment 对象能够表示运行在集群中的应用。 当创建 Deployment 时，你可能会设置 Deployment 的 <code>spec</code>，指定该应用要有 3 个副本运行。 Kubernetes 系统读取 Deployment 的 <code>spec</code>， 并启动我们所期望的应用的 3 个实例 —— 更新状态以与规约相匹配。 如果这些实例中有的失败了（一种状态变更），Kubernetes 系统会通过执行修正操作来响应 <code>spec</code> 和 <code>status</code> 间的不一致 —— 意味着它会启动一个新的实例来替换。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/kubernetes/examples/blob/master/guestbook/all-in-one/guestbook-all-in-one.yaml">https://github.com/kubernetes/examples/blob/master/guestbook/all-in-one/guestbook-all-in-one.yaml</a></p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span> <span class="comment"># 接口组/版本  没有写接口组就是core，根据资源类型来写</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span>  <span class="comment"># 类别</span></span><br><span class="line"><span class="attr">metadata:</span>  <span class="comment"># 元数据</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-demo</span>  <span class="comment"># 名字</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span>  <span class="comment"># 归属于哪个命名空间</span></span><br><span class="line">  <span class="attr">labels:</span>  <span class="comment"># 标签</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">myapp</span></span><br><span class="line"><span class="attr">spec:</span>  <span class="comment"># 对象规约</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">myapp-1</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">myapp:v1.0</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">busybox-1</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">tools:busybox</span></span><br><span class="line">    <span class="attr">command:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;/bin/sh&quot;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;-c&quot;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;sleep 3600&quot;</span></span><br><span class="line"><span class="attr">status:</span>  <span class="comment"># 状态</span></span><br><span class="line">  <span class="attr">conditions:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">lastProbeTime:</span> <span class="literal">null</span></span><br><span class="line">    <span class="attr">lastTransitionTime:</span> <span class="string">&quot;2023-11-21T08:49:07z&quot;</span></span><br><span class="line">    <span class="attr">status:</span> <span class="string">&quot;True&quot;</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">Initialized</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">lastProbeTime:</span> <span class="literal">null</span></span><br></pre></td></tr></table></figure>



<h2 id="四、容器的生命周期"><a href="#四、容器的生命周期" class="headerlink" title="四、容器的生命周期"></a>四、容器的生命周期</h2><p><img src="https://raw.githubusercontent.com/cy77cc/pic-md/master/image-20250407094704165.png" alt="image-20250407094704165"></p>
<h3 id="4-1-initC"><a href="#4-1-initC" class="headerlink" title="4.1. initC"></a>4.1. initC</h3><p>init容器与普通的容器相似，除了如下两点：</p>
<ul>
<li>init 容器总是运行到成功完成为止，返回码为成功。</li>
<li>每个init 容器都必须在下一个init容器启动之前成功完成</li>
</ul>
<p>如果Pod的init容器失败，Kubernetes会不断地重启该Pod，直到init容器成功为止。然而，如果Pod对应的restartPolicy为Never，它不会重新启动。</p>
<ul>
<li>initC与应用容器具备不同的镜像，可以把一些危险的工具放置在initC中进行使用。</li>
<li>initC多个之间是线性启动（串行执行）的，所以可以做一些延迟性操作。</li>
<li>initC无法定义readinessProbe（就绪探测），其他以外同应用容器定义无异。</li>
</ul>
<h3 id="4-2-探针"><a href="#4-2-探针" class="headerlink" title="4.2. 探针"></a>4.2. 探针</h3><p>探针是由kubelet对容器执行的定期诊断。要执行诊断，kubelet调用由容器实现的Handler。有三种类型的处理程序：</p>
<ul>
<li>ExecAction：在容器内执行指定命令。如果命令退出时返回码为0则认为诊断成功</li>
<li>TCPSocketAction：对指定端口上的容器的IP地址进行TCP检查。如果端口打开，则诊断被认为是成功的</li>
<li>HTTPGetAction：对指定的端口和路径上的容器的IP地址执行HTTP Get请求。如果响应的状态码大于等于200且小于400，则诊断被认为是成功的</li>
</ul>
<p>每次探测都将获得以下三种结果之一：</p>
<ul>
<li>成功：容器通过了诊断。</li>
<li>失败：容器未通过诊断。</li>
<li>未知：诊断失败，因此不会采取任何行动。</li>
</ul>
<h4 id="4-2-1-探针分类"><a href="#4-2-1-探针分类" class="headerlink" title="4.2.1 探针分类"></a>4.2.1 探针分类</h4><ul>
<li>startupProbe：启动探测，开始检测吗？</li>
<li>livenessProbe：存活探测，还活着吗</li>
<li>readinessProbe：就绪探测，准备提供服务了吗？</li>
</ul>
<h4 id="readinessProbe-就绪探针"><a href="#readinessProbe-就绪探针" class="headerlink" title="readinessProbe 就绪探针"></a>readinessProbe 就绪探针</h4><p>k8s通过添加就绪探针，解决尤其是在扩容时保证提供给用户的服务都是可用的。在进行pod扩容时，如果新建的pod还没准备就绪，那么它就不应该提供给用户访问，就绪探测可以让pod就绪后才加入到service中。</p>
<p>选项说明：</p>
<ul>
<li>initialDelaySeconds：容器启动后要等待多少秒后探针开始工作，单位“秒”，默认是0秒，最小值是0</li>
<li>periodSeconds：执行探测的时间间隔（单位是秒），默认为10s，单位“秒”，最小值1</li>
<li>timeoutSeconds：探针执行检测请求后，等待响应的超时时间，默认为1s，单位“秒”，最小值是1</li>
<li>successThreshold：探针检测失败后认为成功的最小连接成功次数，默认值为1。必须为1才能激活和启动。最小值为1</li>
<li>failurethreshold：探测失败的额重试次数，重试一定次数后将认为失败，默认值为3，最小值为1</li>
</ul>
<p>如果pod内部的容器不添加就绪探测，默认就绪。如果添加了就绪探测，只有通过就绪探测成功以后，才标记修改为就许状态。当前pod内的所有容器都就绪，才标记当前pod就绪。</p>
<ul>
<li>探测成功：将当前的容器标记为就绪</li>
<li>探测失败：静默</li>
<li>探测未知：静默</li>
</ul>
<h4 id="livenessProbe存活探针"><a href="#livenessProbe存活探针" class="headerlink" title="livenessProbe存活探针"></a>livenessProbe存活探针</h4><p>k8s通过添加存活探针，解决虽然活着但是已经死了的问题。</p>
<p>选项说明：</p>
<ul>
<li>initialDelaySeconds：容器启动后要等待多少秒后探针开始工作，单位“秒”，默认是0秒，最小值0</li>
<li>periodSeconds：执行探测的时间间隔（单位是秒），默认为10s，单位“秒”，最小值是1</li>
<li>timeoutSeconds：探针执行检测请求后，等待响应的超时时间，默认为1s，单位“秒”，最小值是1</li>
<li>successThreshold：探针检测失败后认为成功的最小连接成功次数，默认值为1。必须为1才能激活行业启动。最小值为1</li>
<li>failureThreshold：探测失败的重试次数，重试一定次数后将认为失败，默认值为3，最小值为1</li>
</ul>
<p>如果pod内部不指定存活探测，可能你会发送容器运行但是无法提供服务的情况</p>
<ul>
<li>成功：静默</li>
<li>失败：根据重启的策略进行重启的动作（重建）</li>
<li>未知：静默</li>
</ul>
<h4 id="startupProbe启动探针"><a href="#startupProbe启动探针" class="headerlink" title="startupProbe启动探针"></a>startupProbe启动探针</h4><p>k8s在1.16版本后增加startupProbe探针，主要解决在复杂的程序中readinessProbe、livenessProbe探针无法更好的判断程序是否启动、是否存活。</p>
<p>选项说明：</p>
<ul>
<li>initialDelaySeconds：容器启动后要等待多少秒后探针开始工作，单位“秒”，默认是0秒，最小值0</li>
<li>periodSeconds：执行探测的时间间隔（单位是秒），默认为10s，单位“秒”，最小值是1</li>
<li>timeoutSeconds：探针执行检测请求后，等待响应的超时时间，默认为1s，单位“秒”，最小值是1</li>
<li>successThreshold：探针检测失败后认为成功的最小连接成功次数，默认值为1。必须为1才能激活行业启动。最小值为1</li>
<li>failureThreshold：探测失败的重试次数，重试一定次数后将认为失败，默认值为3，最小值为1</li>
</ul>
<p>启动探针保障存活探针在执行的时候不会因为时间设定问题导致无限死亡或者延迟很长的情况</p>
<ul>
<li>成功：开始允许存活探测，就绪探测开始执行</li>
<li>失败：静默</li>
<li>未知：静默</li>
</ul>
<h3 id="4-3-钩子"><a href="#4-3-钩子" class="headerlink" title="4.3 钩子"></a>4.3 钩子</h3><p>Pod hook（钩子）是由k8s管理的kubelet发起的，当容器中的进程启动前或者容器中的进程终止之前运行，这是包含在容器的生命周期之中。可以同时为Pod中的所有容器都配置hook。启动后钩子，关闭前钩子</p>
<p>Hook的类型包括两种：</p>
<ul>
<li>exec：执行一段命令</li>
<li>HTTP：发送HTTP请求</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1  </span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line"> name: lifecycle-pod</span><br><span class="line"> labels:</span><br><span class="line">   app: lifecycle-pod</span><br><span class="line">spec:</span><br><span class="line"> containers:</span><br><span class="line"> - name: busybox-container</span><br><span class="line">   image: wangyanglinux/tools:busybox</span><br><span class="line">   command: [&quot;/bin/sh&quot;,&quot;-c&quot;,&quot;touch /tmp/live ; sleep 600; rm -rf /tmp/live; sleep 3600&quot;]</span><br><span class="line">   livenessProbe:</span><br><span class="line">     exec:</span><br><span class="line">       command: [&quot;test&quot;,&quot;-e&quot;,&quot;/tmp/live&quot;]</span><br><span class="line">     initialDelaySeconds: 1</span><br><span class="line">     periodSeconds: 3</span><br><span class="line">   lifecycle:</span><br><span class="line">     postStart:</span><br><span class="line">       httpGet:</span><br><span class="line">         host: 192.168.66.11</span><br><span class="line">         path: index.html</span><br><span class="line">         port: 1234</span><br><span class="line">     preStop:</span><br><span class="line">       httpGet:</span><br><span class="line">         host: 192.168.66.11</span><br><span class="line">         path: hostname.html</span><br><span class="line">         port: 1234</span><br><span class="line"> - name: myapp-container</span><br><span class="line">   image: wangyanglinux/myapp:v1.0</span><br><span class="line">   livenessProbe:</span><br><span class="line">     httpGet:</span><br><span class="line">       port: 80</span><br><span class="line">       path: /index.html</span><br><span class="line">     initialDelaySeconds: 1</span><br><span class="line">     periodSeconds: 3</span><br><span class="line">     timeoutSeconds: 3</span><br><span class="line">   readinessProbe:</span><br><span class="line">     httpGet:</span><br><span class="line">       port: 80</span><br><span class="line">       path: /index1.html</span><br><span class="line">     initialDelaySeconds: 1</span><br><span class="line">     periodSeconds: 3</span><br><span class="line"> initContainers:</span><br><span class="line"> - name: init-myservice</span><br><span class="line">   image: wangyanglinux/tools:busybox</span><br><span class="line">   command: [&#x27;sh&#x27;, &#x27;-c&#x27;, &#x27;until nslookup myservice; do echo waiting for myservice; sleep 2; done;&#x27;]</span><br><span class="line"> - name: init-mydb</span><br><span class="line">   image: wangyanglinux/tools:busybox</span><br><span class="line">   command: [&#x27;sh&#x27;, &#x27;-c&#x27;, &#x27;until nslookup mydb; do echo waiting for mydb; sleep 2; done;&#x27;]</span><br></pre></td></tr></table></figure>



<h2 id="五、Pod的控制器"><a href="#五、Pod的控制器" class="headerlink" title="五、Pod的控制器"></a>五、Pod的控制器</h2><p>在Kubernetes中运行了一系列控制器来确保集群的当前状态与期望状态保持一致，它们就是Kubernetes集群内部的管理控制中心或者说是“中心大脑”。例如，ReplicaSet控制器负责维护集群中运行的Pod数量；Node控制器负责监控节点的状态，并在节点出现故障时，执行自动化修复流程，确保集群始终处于预期的工作状态。</p>
<ul>
<li>ReplicationController、ReplicaSet</li>
<li>Deployment</li>
<li>DaemonSet</li>
<li>StateFulSet</li>
<li>Job&#x2F;CronJob</li>
<li>Horizontal Pod Autoscaling</li>
</ul>
<h3 id="5-1-ReplicationController和ReplicaSet"><a href="#5-1-ReplicationController和ReplicaSet" class="headerlink" title="5.1 ReplicationController和ReplicaSet"></a>5.1 ReplicationController和ReplicaSet</h3><p>ReplicationController（rc）用来确保容器应用的副本数始终保持在用户定义的副本数，即如果有容器异常退出，会自动创建新的Pod来替代；而如果异常多出来的容器也会自动回收；</p>
<p>在新版本的Kubernetes中建议使用ReplicaSet(rs)来取代ReplicationController。ReplicaSet和ReplicationController没有本质的不同，只是名字不一样，并且ReplicaSet支持集合式的selector；</p>
<p>RC控制器，保障当前的Pod数量与期望值一致</p>
<p>RS控制器，功能与RC控制器类似，但是多了标签选择的运算方式</p>
<h3 id="5-2-Deployment"><a href="#5-2-Deployment" class="headerlink" title="5.2 Deployment"></a>5.2 Deployment</h3><p>原理：通过 Deployment 控制器控制不同的 RS 再去创建 Pod</p>
<p>Deployment为Pod和ReplicaSet提供了一个声明式定义（declarative）方法，用来替代以前的ReplicationController来方便的管理应用。典型的应用场景包括：</p>
<ul>
<li>定义Deployment来创建Pod和ReplicaSet</li>
<li>滚动升级和回滚应用</li>
</ul>
<p><img src="https://raw.githubusercontent.com/cy77cc/pic-md/master/image-20250408145217802.png" alt="Deployment和RS的关系"></p>
<ul>
<li>扩容和缩容</li>
<li>暂停和继续Deployment</li>
</ul>
<h4 id="5-2-1-声明式和命令式"><a href="#5-2-1-声明式和命令式" class="headerlink" title="5.2.1 声明式和命令式"></a>5.2.1 声明式和命令式</h4><p>声明性的东西是对结果的陈述，表明意图而不是实现它的过程。在Kubernetes中，这就说“应该有一个包含三个Pod的ReplicaSet”。</p>
<p>命令式充当命令。声明式是被动的，而命令式是主动且直接的：“创建一个包含三个Pod的ReplicaSet”。</p>
<h4 id="5-2-2-replace与apply对比"><a href="#5-2-2-replace与apply对比" class="headerlink" title="5.2.2 replace与apply对比"></a>5.2.2 replace与apply对比</h4><h5 id="替换方式"><a href="#替换方式" class="headerlink" title="替换方式"></a>替换方式</h5><ul>
<li>kubectl replace：使用新的配置完全替换掉现有资源的配置。这意味着新配置将覆盖现有资源的所有字段和属性，包含未指定的字段，会导致整个资源的替换。</li>
<li>kubectl apply：使用新的配置部分地更新现有资源的配置。它会根据提供的配置文件或参数，只更新与新配置中不同的部分，而不会覆盖整个资源的配置。</li>
</ul>
<h5 id="字段级别的更新"><a href="#字段级别的更新" class="headerlink" title="字段级别的更新"></a>字段级别的更新</h5><ul>
<li>kubectl replace：由于是完全替换，所以会覆盖所有字段和属性，无论是否在新配置中指定。</li>
<li>kubectl apply：只更新与新配置中不同的字段和属性，保留未指定的字段不受影响。</li>
</ul>
<h5 id="部分更新"><a href="#部分更新" class="headerlink" title="部分更新"></a>部分更新</h5><ul>
<li>kubectl replace：不支持部分更新，它会替换整个资源的配置</li>
<li>kubectl apply：支持部分更新，只会更新新配置中发生变化的部分，保留未指定的部分不受影响</li>
</ul>
<h5 id="与其他配置的影响"><a href="#与其他配置的影响" class="headerlink" title="与其他配置的影响"></a>与其他配置的影响</h5><ul>
<li>kubectl replace：不考虑其他资源配置的状态，直接替换资源的配置。</li>
<li>kubectl apply：可以结合使用 -f 或 -k 参数，从文件或目录中读取多个资源配置，并根据当前集群中的资源状态进行更新。</li>
</ul>
<h4 id="5-2-3-常用命令"><a href="#5-2-3-常用命令" class="headerlink" title="5.2.3 常用命令"></a>5.2.3 常用命令</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">kubectl create -f deployment.yaml --record</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">根据yaml创建一个Deployment，--record参数可以记录命令，可以很方便的查看每次revision的变化</span></span><br><span class="line">-f 通过基于文件的创建，但是如果此文件描述的对象存在，即使文件描述的信息发生了改变，再次提交时也不会应用</span><br><span class="line"></span><br><span class="line">apply</span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">创建资源对象、修改资源对象</span></span><br><span class="line">	-f 基于文件创建，如果目标对象与文件本身发生改变，那么会根据文件的内容一一修改目标对象的属性（部分更新）</span><br><span class="line">replace</span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">创建资源对象、修改资源对象</span></span><br><span class="line">	-f 基于文件创建，如果目标对象与文件本身发生改变，那么会重建此对象（替代替换）</span><br><span class="line"></span><br><span class="line">kubectl scale deployment nginx-deployment --replicas 10 # 扩容，缩容都可以</span><br><span class="line">kubectl autoscale deployment nginx-deployment --min=10 --max=15 --cpu-percent=80  # 扩展缩容阈值</span><br><span class="line">kubectl set image deployment/nginx-deployment nginx-deployment-container=wangyanglinux/myapp:v2.0</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">回滚到上一个版本</span></span><br><span class="line">kubectl rollout undo deployment/nginx-deployment</span><br></pre></td></tr></table></figure>

<h4 id="5-2-4-更新策略"><a href="#5-2-4-更新策略" class="headerlink" title="5.2.4 更新策略"></a>5.2.4 更新策略</h4><p>Deployment 可以保证在升级时只有一定数量的 Pod 是 down 的。默认的，它会确保至少有比期望的 Pod 数量少一个是 up 状态（最多一个不可用）</p>
<p>Deployment 同时也可以确保只创建出超过期望数量一定数量的 Pod。默认的，他会确保最多比期望的 Pod 数量多一个的 Pod 是 up 的（最多 1 个 surge）</p>
<p>最多多25%，最多少25%（通过apps&#x2F;v1接口组创建的）</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">kubectl explain deploy.spec.strategy.type</span><br><span class="line">	Recreate  # 重建</span><br><span class="line">    RollingUpdate # 滚动更新</span><br><span class="line">    	maxSurge: # 指定超出副本数有几个，两种方式：1、指定数量 2、百分比</span><br><span class="line">    	maxUnavailable: # 最多有几个不可用</span><br></pre></td></tr></table></figure>

<h4 id="5-2-5-金丝雀部署"><a href="#5-2-5-金丝雀部署" class="headerlink" title="5.2.5 金丝雀部署"></a>5.2.5 金丝雀部署</h4><p>创建少量的新版本 Pod 给用户访问，如果没有问题再将所有的 Pod 都更新到新版本。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kubectl patch deploy deployment-demo -p &#x27;&#123;&quot;spec&quot;: &#123;&quot;strategy&quot;: &#123;&quot;rollingUpdate&quot;: &#123;&quot;maxSurge&quot;: 1, &quot;maxUnavailable&quot;: 0&#125;&#125;&#125;&#125;&#x27;</span><br><span class="line"></span><br><span class="line">kubectl patch deploy deployment-demo --patch &#x27;&#123;&quot;spec&quot;: &#123;&quot;template&quot;: &#123;&quot;spec&quot;: &#123;&quot;containers&quot;: [&#123;&quot;name&quot;: &quot;deployment-demo-container&quot;, &quot;image&quot;: &quot;wangyanglinux/myapp:v2.0&quot;&#125;]&#125;&#125;&#125;&#125;&#x27; &amp;&amp; kubectl rollout pause deploy deployment-demo</span><br></pre></td></tr></table></figure>

<h4 id="5-2-6-回滚命令"><a href="#5-2-6-回滚命令" class="headerlink" title="5.2.6 回滚命令"></a>5.2.6 回滚命令</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看的当前deployment的滚动更新状态</span></span><br><span class="line">kubectl rollout status deploy nginx-deployment</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看的当前deployment的滚动更新历史</span></span><br><span class="line">kubectl rollout history deployment/nginx-deployment</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">回滚到指定的revision版本</span></span><br><span class="line">kubectl rollout undo deployment/nginx-deployment --to-revision=2</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">暂停滚动更新</span></span><br><span class="line">kubectl rollout pause deployment/nginx-deployment</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">恢复滚动更新</span></span><br><span class="line">kubectl rollout resume deploy deployment-demo</span><br></pre></td></tr></table></figure>

<h4 id="5-2-7-清理策略"><a href="#5-2-7-清理策略" class="headerlink" title="5.2.7 清理策略"></a>5.2.7 清理策略</h4><p>可以通过设置<code>.spec.revisionHistoryLimit</code>项来指定 Deployment 最多保留多少 revision 历史记录。默认的会保留所有的 revision；如果将该项设置为0，Deployment 就不允许回滚了。</p>
<h3 id="5-3-DaemonSet"><a href="#5-3-DaemonSet" class="headerlink" title="5.3 DaemonSet"></a>5.3 DaemonSet</h3><p>DaemonSet 确保全部（或者一些）Node 上运行一个 Pod 的副本。当有 Node 加入集群时，也会为他们新增一个 Pod。当有 Node 从集群移除时，这些 Pod 也会被回收。删除 DaemonSet 将会删除它创建的所有 Pod。</p>
<p>使用 DaemonSet 的一些典型用法：</p>
<ul>
<li>运行集群存储 daemon，例如在每个 Node 上运行 glusterd、ceph</li>
<li>在每个 Node 上运行日志收集 daemon，例如 fluentd、logstash</li>
<li>在每个 Node 上运行监控 daemon，例如 Prometheus Node Exporter、collectd、Datadog 代理、New Relic 代理，或 Ganglia gmond</li>
</ul>
<h3 id="5-4-Job"><a href="#5-4-Job" class="headerlink" title="5.4 Job"></a>5.4 Job</h3><p>Job 负责批处理任务，即仅执行一次的任务，它保证批处理任务的一个或多个 Pod 成功结束，保障批处理任务一个或多个成功为止。</p>
<p>特殊说明：</p>
<ul>
<li>spec.template 格式同 Pod</li>
<li>RestartPolicy 仅支持 Never 或 OnFailure</li>
<li>单个 Pod 时，默认 Pod 成功运行后 Job即结束</li>
<li><code>.spec.completions</code> 标志 Job结束需要成功运行的 Pod 个数，默认为 1</li>
<li><code>.spec.parallelism</code> 标志并行运行的 Pod 的个数，默认为 1</li>
<li><code>.spec.activeDeadlineSeconds</code> 标志失败 Pod 的重试最大时间，超过这个时间不会继续重试</li>
</ul>
<h3 id="5-5-CronJob"><a href="#5-5-CronJob" class="headerlink" title="5.5 CronJob"></a>5.5 CronJob</h3><p>Cron Job管理基于时间的 Job，即：</p>
<ul>
<li>在给定时间点只运行一次</li>
<li>周期性地在给定时间点运行</li>
</ul>
<p>典型用法：</p>
<ul>
<li>在给定的时间点调度 Job 运行</li>
<li>创建周期性运行的 Job，例如：数据库备份、发送邮件</li>
</ul>
<p>spec下面的参数</p>
<ul>
<li><code>.spec.schedule</code>：调度，必需字段，指定任务运行周期，格式通 Cron</li>
<li><code>.spec.jobTemplate</code>：Job 模板，必需字段，指定需要运行的任务，格式同 Job</li>
<li><code>.spec.startingDeadlineSeconds</code>：启动 Job 的期限（秒级别），该字段是可选的。如果因为任何原因而错过了被调度的时间，那么错过执行时间的 Job 将被认为是失败的。如果没有指定，则没有期限。</li>
<li><code>.spec.concurrencyPolicy</code>：并发策略，该字段也是可选的。它制定了如何处理被 Cron Job创建的 Job 的并发执行。只允许指定下面策略中的一种：<ul>
<li><code>Allow</code>（默认）：允许并发运行 Job</li>
<li><code>Forbid</code>：禁止并发运行，如果前一个还没有完成，则直接跳过下一个</li>
<li><code>Replace</code>：取消当前正在运行的 Job，用一个新的来替换</li>
<li>注意，当前策略只能应用于同一个 Cron Job 创建的 Job。如果存在多个 Cron Job，它们创建的 Job 之间总是运行并发执行。</li>
</ul>
</li>
<li><code>.spec.suspend</code>：挂起，该字段也是可选的。如果设置为 <code>true</code>，后续所有执行都会被挂起。它对已经执行的 Job 不起作用。默认值为 <code>false</code></li>
<li><code>.spec.successfulJobsHistoryLimit</code> 和 <code>.spec.failedJobsHistoryLimit</code>：历史限制，是可选的字段。它们制定了可以保留多少完成和失败的 Job。默认情况下，它们分别设置为 3 和 1。设置限制的值为 0，相关类型的 Job 完成后将不会被保留</li>
</ul>
<p><strong>周期性的创建 Job，典型的场景：数据库的周期性备份。。。</strong></p>
<p>创建 Job 操作应该是幂等的</p>
<h3 id="5-6-StatefulSet"><a href="#5-6-StatefulSet" class="headerlink" title="5.6 StatefulSet"></a>5.6 StatefulSet</h3><p>有序创建有序回收</p>
<p>数据持久化 Pod 级别 Pod绑定 pvc，pvc 绑定 pv，pv 绑定 nfs</p>
<p>稳定的网络访问方式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PodName.headlessSvcName.nsName.svc.domainName.</span><br><span class="line">statefulSetName-num.headlessSvcName.nsName.svc.domainName.</span><br></pre></td></tr></table></figure>





<h2 id="六、Service"><a href="#六、Service" class="headerlink" title="六、Service"></a>六、Service</h2><p>Kubernetes <code>Service</code> 定义了这样一种很抽象：一个 Pod 的逻辑分组，一种可以访问它们的策略 ——通过称为微服务。这一组 Pod 能够被 Service 访问到，通常是通过 Label Selector</p>
<p>在 Kubernetes 集群中，每个 Node 运行一个 <code>kube-proxy</code> 进程。<code>kube-proxy</code> 负责为 <code>Service</code> 实现了一种VIP（虚拟IP）的形式</p>
<p>在Kubernetes v1.0 版本，代理完全在userspace。在v1.1版本，新增了 iptables 代理，但并不是默认的运行模式。从v1.2起，默认即使 iptables 代理。在v1.8中添加了ipvs代理。</p>
<h3 id="6-1-Service-类型"><a href="#6-1-Service-类型" class="headerlink" title="6.1 Service 类型"></a>6.1 Service 类型</h3><ul>
<li>ClusterIP：默认类型，自动分配一个仅 Cluster 内部可以访问的虚拟IP（集群内部使用）</li>
<li>NodePort：在 ClusterIP 基础上为 Service 在每台机器上绑定一个端口，这样就可以通过 &lt;NodeIP&gt;:&lt;NodePort&gt; 来访问服务（暴露到集群外部）</li>
<li>LoadBalancer：在 NodePort 的基础上，借助 cloud provider 创建一个外部负载均衡器，并将请求转发到 &lt;NodeIP&gt;:&lt;NodePort&gt;</li>
<li>ExternalName：把集群外部的服务引入到集群内部来，在集群内部直接使用。没有任何类型代理被创建，这只有 Kubernetes 1.7 或更高版本的 kube-dns 才支持。（别名）</li>
</ul>
<h4 id="6-1-1-ClusterIP"><a href="#6-1-1-ClusterIP" class="headerlink" title="6.1.1 ClusterIP"></a>6.1.1 ClusterIP</h4><p>svc DNS 域名</p>
<p>svcName.nsName.svc.domainName.</p>
<p>​	domainName cluster.local</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">internalTrafficPolicy 参数：</span><br><span class="line">	Cluster: 访问集群内的所有pod</span><br><span class="line">	Local: 仅限访问本机内的Pod</span><br></pre></td></tr></table></figure>

<h4 id="6-1-2-NodePort"><a href="#6-1-2-NodePort" class="headerlink" title="6.1.2 NodePort"></a>6.1.2 NodePort</h4><p>暴露集群内部的服务给外部访问</p>
<h4 id="6-1-3-ExternalName"><a href="#6-1-3-ExternalName" class="headerlink" title="6.1.3 ExternalName"></a>6.1.3 ExternalName</h4><p>ExternalName Service 是 Service 的特例，它没有 selector，也没有定义任何的端口和 Endpoint。相反的，对于运行在集群外部的服务，它通过返回该外部服务的别名这种方式来提供服务。</p>
<h3 id="6-3-Endpoint"><a href="#6-3-Endpoint" class="headerlink" title="6.3 Endpoint"></a>6.3 Endpoint</h3><p>Kubernetes 中的 Service，它定义了一组 Pods 的逻辑集合和一个用于访问它们的策略。一个 Service 的目标 Pod 集合通常是由 Label Selector 来决定的 。</p>
<p>Endpoints 是一组实际服务的端点集合。一个 Endpoint 是一个可被访问的服务端点，即一个状态为 running 的 Pod 的可访问端点。一般 Pod 都不是一个独立存在，所以一组 Pod 的端点何在一起称为 Endpoints。只有被 Service Selector 匹配选中并且状态为 Running 的才会被加入到和 Service 同名的 Endpoints 中。</p>
<ul>
<li>自动关联体系：配置 selector</li>
<li>手动关联体系：无配置 selector</li>
</ul>
<h2 id="七、存储"><a href="#七、存储" class="headerlink" title="七、存储"></a>七、存储</h2><h3 id="7-1-存储各类特性"><a href="#7-1-存储各类特性" class="headerlink" title="7.1 存储各类特性"></a>7.1 存储各类特性</h3><ul>
<li>元数据<ul>
<li>configMap：用于保存配置数据（明文）</li>
<li>Secret：用于保存敏感性数据（编码）</li>
<li>Downward API：容器在运行时从 Kubernetes API 服务器获取有关它们自身的信息</li>
</ul>
</li>
<li>真实数据<ul>
<li>Volume：用于存储临时或者持久性数据</li>
<li>PersistentVolume：申请制的持久化存储</li>
</ul>
</li>
</ul>
<h3 id="7-2-configMap"><a href="#7-2-configMap" class="headerlink" title="7.2 configMap"></a>7.2 configMap</h3><p>configMap 功能在Kubernetes 1.2 版本中引入，许多应用程序会从配置文件、命令行参数或环境变量中读取配置信息。configMap API 给我们提供了向容器中注入配置信息的机制，configMap 可以被用来保存单个属性，也可以用来保存整个配置文件或者 JSON 二进制等对象。</p>
<h4 id="7-2-1-创建"><a href="#7-2-1-创建" class="headerlink" title="7.2.1 创建"></a>7.2.1 创建</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl create configmap game-config --from-file=hongfu.file</span><br><span class="line">kubectl create configmap literal-config --from-literal=name=dave --from-literal=password=pass</span><br></pre></td></tr></table></figure>

<h4 id="7-2-2-热更新"><a href="#7-2-2-热更新" class="headerlink" title="7.2.2 热更新"></a>7.2.2 热更新</h4><p>更新 configMap 可以更改挂载到 Pod 上的文件，方式是注入，在很多应用中配置文件的更改并不一定会使得 Pod 内部应用的更新，因此可以利用滚动更新的策略重新创建 Pod，达到更新的效果。</p>
<p>更新 configMap 后：</p>
<ul>
<li>使用该 configMap 挂载的 Env 不会同步更新</li>
<li>使用该 configMap 挂载的 volume 中的数据需要一段时间才能同步更新</li>
</ul>
<h4 id="7-2-3-不可改变-immutable"><a href="#7-2-3-不可改变-immutable" class="headerlink" title="7.2.3 不可改变 immutable"></a>7.2.3 不可改变 immutable</h4><p>Kubernetes 给不可改变的 configMap 和 Secret 提供了一种可选配置，可以设置各个 Secret 和 configMap 为不可变的。对于大量使用 configMap 的集群，禁止变更它们的数据有下列好处：</p>
<ul>
<li>防止以外（或非预期的）更新导致应用程序中断</li>
<li>通过将 configMap 标记为不可变来关闭 kube-apiserver 对其的监视，从而显著降低 kube-apiserver 的负载，提升集群性能。</li>
</ul>
<p>configMap 如果修改为不可改变的状态，是不允许回退的，是不可逆的。可以删除此 configMap，然后重新创建一个没有不可改变字段的 configMap，防止出现一些错误的修改。</p>
<h3 id="7-3-Secret"><a href="#7-3-Secret" class="headerlink" title="7.3 Secret"></a>7.3 Secret</h3><p>编码而来的安全</p>
<p>Secret 对象类型用来保存敏感信息，例如密码，OAuth 令牌和 SSH 密钥。将这些信息放在 Secret 中比放在 Pod 的定义或者 容器镜像 中来说更加安全和灵活。</p>
<p><img src="https://raw.githubusercontent.com/cy77cc/pic-md/master/image-20250410164840969.png" alt="Secret分类"></p>
<h4 id="7-3-1-特性"><a href="#7-3-1-特性" class="headerlink" title="7.3.1 特性"></a>7.3.1 特性</h4><ul>
<li>Kubernetes 通过仅仅将 Secret 分发到需要访问 Secret 的 Pod 所在的机器节点来保障其安全性</li>
<li>Secret 只会存储在节点的内存中，永不写入物理存储，这样从节点删除 Secret 时就不需要擦除磁盘数据</li>
<li>从 Kubernetes 1.7 版本开始，etcd 会以加密形式存储 Secret，一定程度的保证了 Secret 安全性</li>
</ul>
<h4 id="7-3-2-Opaque"><a href="#7-3-2-Opaque" class="headerlink" title="7.3.2 Opaque"></a>7.3.2 Opaque</h4><p>当 Secret 配置文件中未作显式设定时，默认的 Secret 类型是 Opaque。当你使用 kubectl 来创建一个 Secret 时，会使用 generic 子命令来表明要创建的是一个 Opaque 类型的 Secret</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Secret</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">mysecret</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">Opaque</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="attr">password:</span> <span class="string">cGFzc3dk</span></span><br><span class="line">  <span class="attr">username:</span> <span class="string">YWRtaW4=</span></span><br></pre></td></tr></table></figure>



<h3 id="7-4-Downward-API"><a href="#7-4-Downward-API" class="headerlink" title="7.4 Downward API"></a>7.4 Downward API</h3><p>Downward API 是 Kubernetes 中的一个功能，它允许容器在运行时 从 Kubernetes API 服务器获取有关它们自身的信息。这些信息可以作为容器内部的环境变量或文件注入到容器中，以便可以获取有关其运行环境的各种信息，如 Pod 名称、命名空间、标签等。</p>
<ul>
<li>提供容器元数据</li>
<li>动态配置</li>
<li>与 Kubernetes 环境集成</li>
</ul>
<p>Downward API 提供了一种简单的方式，将 Pod 和容器的元数据传递他给它们内部运行的进程。但这种方式其实仅仅暴露了一个 Pod 自身的元数据传递给在它们内部运行的进程。但是这种方式其实仅仅可以暴露一个 Pod 自身的元数据，而且只可以暴露部分元数据。</p>
<h3 id="7-5-volume"><a href="#7-5-volume" class="headerlink" title="7.5 volume"></a>7.5 volume</h3><p>容器磁盘上的文件的生命周期是短暂的，这就使得在容器中运行重要应用时会出现一些问题。首先，当容器崩溃时，kubelet 会重启（重建）它，但是容器中的文件将丢失——容器以干净的状态（镜像最初的状态）重新启动。其次，在 Pod 中同时运行多个容器时，这些容器之间通常需要共享文件。Kubernetes 中的 Volume 抽象就很好地解决了这些问题。</p>
<h4 id="7-5-1-emptyDir"><a href="#7-5-1-emptyDir" class="headerlink" title="7.5.1 emptyDir"></a>7.5.1 emptyDir</h4><p>当 Pod 被分配给节点时，首先创建 emptyDir 卷，并且只要该 Pod 在该节点上运行，该卷就会存在。正如卷的名字所述，它最初是空的。Pod 中的容器可以读取和写入 emptyDir 卷中的相同文件，尽管改卷可以挂载到每个容器中的相同或不同路径上。当出于任何原因从节点中删除 Pod 时，emptyDir 中的数据将被永久删除</p>
<p>容器崩溃不会从节点中移除 Pod，因此 emptydir 卷中的数据在容器崩溃时是安全的</p>
<p>emptyDir 的用法有：</p>
<ul>
<li>暂存空间，例如用于磁盘的合并排序、用作长时间计算崩溃恢复时的检查点</li>
<li>Web 服务器容器提供数据时，保存内容管理器容器提取的文件</li>
</ul>
<p>在 kubelet 的工作目录（root-dir 参数控制），默认为 <code>/var/lib/kubelet</code>，会为每个使用了 <code>emptyDir: &#123;&#125;</code> 的 Pod 创建一个目录，格式如 <code>/var/lib/kubelet/pods/&#123;podid&#125;/volumes/kubernetes.io~empty-dir/</code>，所有放在 emptyDir 中的数据，最终都是落在了 node 的上述路径中</p>
<h4 id="7-5-2-hostPath"><a href="#7-5-2-hostPath" class="headerlink" title="7.5.2 hostPath"></a>7.5.2 hostPath</h4><p>hostPath 卷将主机节点的文件系统中的文件或目录挂载到集群中</p>
<p>hostPath 用途如下：</p>
<ul>
<li>运行需要访问 Docker 内部的容器；使用 <code>/var/lib/docker</code> 的 <code>hostPath</code></li>
<li>在容器中运行 cAdvisor；使用 <code>/dev/cgroups</code> 的 <code>hostPath</code></li>
<li>允许 Pod 指定给定的 hostPath 是否应该在 Pod 运行之前存在，是否应该创建，以及它应该以什么形式存在</li>
</ul>
<p>除了所需的 <code>path</code> 属性之外，用户还可以为 <code>hostPath</code> 卷指定 <code>type</code></p>
<p><strong>类型</strong></p>
<table>
<thead>
<tr>
<th>值</th>
<th>行为</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>空字符串（默认）用于向后兼容，意味着在挂载 hostPath 卷之前不会执行任何检查</td>
</tr>
<tr>
<td>DirectoryOrCreate</td>
<td>如果在给定的路径上没有任何东西存在，那么将根据需要在那么创建一个空目录，权限设置为 0755，与 Kubelet 具有相同的组合所有权</td>
</tr>
<tr>
<td>Directory</td>
<td>给定的路径下必须存在目录</td>
</tr>
<tr>
<td>FileOrCreate</td>
<td>如果在给定的路径上没有任何东西存在，那么会根据需要创建一个空文件，权限设置为 0644，与 Kubelet 具有相同的组合所有权</td>
</tr>
<tr>
<td>File</td>
<td>给定的路径下必须存在文件</td>
</tr>
<tr>
<td>Socket</td>
<td>给定的路径下必须存在 UNIX 套接字</td>
</tr>
<tr>
<td>CharDevice</td>
<td>给定的路径下必须存在字符设备</td>
</tr>
<tr>
<td>BlockDevice</td>
<td>给定的路径下必须存在块设备</td>
</tr>
</tbody></table>
<h3 id="7-6-PV-PVC"><a href="#7-6-PV-PVC" class="headerlink" title="7.6 PV&#x2F;PVC"></a>7.6 PV&#x2F;PVC</h3><img src="https://raw.githubusercontent.com/cy77cc/pic-md/master/image-20250411104731185.png" alt="PV/PVC之间的关系" style="zoom: 50%;" />

<p>PV&#x2F;PVC 关联条件</p>
<ul>
<li>容量：PV 的值不小于 PVC 要求，可以大于最好一致</li>
<li>读写策略：完全匹配<ul>
<li>单节点读写 - ReadWriteOnce - RWO</li>
<li>多节点只读 - ReadOnlyMany - ROX</li>
<li>多借点读写 - ReadWriteMany - RWX</li>
</ul>
</li>
<li>存储类：PV 的类与 PVC 的类必须一致，不存在包容降级关系</li>
</ul>
<h4 id="PV-PVC-回收策略"><a href="#PV-PVC-回收策略" class="headerlink" title="PV&#x2F;PVC - 回收策略"></a>PV&#x2F;PVC - 回收策略</h4><ul>
<li>Retain（保留）：手动回收</li>
<li>Recycle（回收）：基本擦除（<code>rm -rf /thevolume/*</code>）</li>
<li>Delete（删除）：关联的存储资产（例如 AWS EBS、GCE PD、Azure Dis 和 OpenStack Cinder 卷）将被删除</li>
</ul>
<p>当前，只有 NFS 和 HostPath 支持回收策略。AWS EBS、GCE PD、Azure Disk 和 Cinder 卷支持删除策略</p>
<h4 id="PV-PVC-状态"><a href="#PV-PVC-状态" class="headerlink" title="PV&#x2F;PVC - 状态"></a>PV&#x2F;PVC - 状态</h4><ul>
<li>Available（可用）：一块空闲资源还没有被任何声明所绑定</li>
<li>Bound（已绑定）：卷已经被声明绑定</li>
<li>Released（已释放）：声明被删除，但是资源还未被集群重新声明</li>
<li>Failed（失败）：该卷的自动回收失败</li>
</ul>
<p>命令行会显示绑定到 PV 的 PVC 的名称</p>
<h3 id="7-7-storageClass"><a href="#7-7-storageClass" class="headerlink" title="7.7 storageClass"></a>7.7 storageClass</h3><p>一种动态的申请存储的机制</p>
<p>StorageClass 是一种资源对象，用于定义持久卷（Persistent Volumes）的动态供给（Dynamic Provisioning）策略。StorageClass 允许管理员定义不同类型的存储，并指定如何动态创建持久卷以供应程序使用。这使得 Kubernetes 集群中的存储管理更加灵活和自动化</p>
<h2 id="八、调度器"><a href="#八、调度器" class="headerlink" title="八、调度器"></a>八、调度器</h2><h3 id="8-1-概念"><a href="#8-1-概念" class="headerlink" title="8.1 概念"></a>8.1 概念</h3><p>scheduler 是作为单独的程序运行的，启动之后会一直监听 API Server，获取 <code>PodSpec.NodeName</code> 为空的 Pod，对每个 Pod 都会创建一个 binding，表明该 Pod 应该放到哪个节点上。</p>
<p>概念听起来是非常简单的，但有很多要考虑的问题：</p>
<ul>
<li>公平：如何保证每个节点都能被分配资源</li>
<li>资源高效利用：集群所有资源最大化被使用</li>
<li>效率：调度的性能要好，能够尽快地对大批量的 Pod 完成调度工作</li>
<li>灵活：允许用户根据自己的需求控制调度的逻辑</li>
</ul>
<p>除了 Kubernetes 自带的调度器，也可以编写自己的调度器。通过 <code>spec.schedulername</code> 参数指定调度器的名字，可以为 Pod 选择某个调度器进行调度。</p>
<p><strong>过程</strong></p>
<p>调度分为几个部分：首先是过滤掉不满足条件的节点，这个过程称为<code>预选</code>，然后对通过预选的节点按照优先级排序，这个是<code>优选</code>；最后从中选择优先级最高的节点。如果中间任何一步骤有错误，就直接返回错误。</p>
<h3 id="8-2-亲和性"><a href="#8-2-亲和性" class="headerlink" title="8.2 亲和性"></a>8.2 亲和性</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 软亲和性，偏好满足条件的节点</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">node-affinity-preferred</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">node-affinity-preferred</span></span><br><span class="line"><span class="attr">spec:</span> </span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">node-affinity-preferred-pod</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">wangyanglinux/myapp:v1.0</span></span><br><span class="line">  <span class="comment"># 亲和性</span></span><br><span class="line">  <span class="attr">affinity:</span></span><br><span class="line">  <span class="comment"># 节点亲和性</span></span><br><span class="line">    <span class="attr">nodeAffinity:</span></span><br><span class="line">    <span class="comment"># 软策略</span></span><br><span class="line">      <span class="attr">preferredDuringSchedulingIgnoreDuringExecution:</span></span><br><span class="line">      <span class="comment"># 权重</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">weight:</span> <span class="number">1</span></span><br><span class="line">      <span class="comment"># 偏好</span></span><br><span class="line">        <span class="attr">preference:</span></span><br><span class="line">          <span class="attr">matchExpressions:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">domain</span></span><br><span class="line">            <span class="attr">operator:</span> <span class="string">In</span></span><br><span class="line">            <span class="attr">values:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">xinxianghf</span></span><br><span class="line"><span class="comment"># 硬亲和性，必须满足条件</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">node-affinity-required</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">node-affinity-required</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">node-affinity-required-pod</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">wangyanglinux/myapp:v1.0</span></span><br><span class="line">  <span class="attr">affinity:</span></span><br><span class="line">    <span class="attr">nodeAffinity:</span></span><br><span class="line">      <span class="attr">requiredDuringSchedulingIgnoredDuringExecution:</span></span><br><span class="line">        <span class="attr">nodeSelectorTerms:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">matchExpressions:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">kubernetes.io/hostname</span></span><br><span class="line">            <span class="attr">operator:</span> <span class="string">In</span></span><br><span class="line">            <span class="attr">values:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">k8s-node4</span></span><br></pre></td></tr></table></figure>

<p>pod亲和性&#x2F;反亲和性，希望和哪个 Pod 在（不在）同一个节点</p>
<p>希望创建的 Pod 和目标 Pod 在同一个拓扑域下，匹配顺序是，首先查找目标 Pod 的拓扑域，然后通过调度策略调度到目标 Pod 拓扑域下的任一节点</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-aff-prefer</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">pod-aff</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">myapp</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">wangyanglinux/myapp:v1.0</span></span><br><span class="line">  <span class="attr">affinity:</span></span><br><span class="line">    <span class="attr">podAffinity:</span></span><br><span class="line">      <span class="attr">preferredDuringSchedulingIgnoredDuringExecution:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">weight:</span> <span class="number">1</span></span><br><span class="line">        <span class="attr">podAffinityTerm:</span></span><br><span class="line">          <span class="attr">labelSelector:</span></span><br><span class="line">            <span class="attr">matchExpressions:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">app</span></span><br><span class="line">              <span class="attr">operator:</span> <span class="string">In</span></span><br><span class="line">              <span class="attr">values:</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">pod-1</span></span><br><span class="line">          <span class="attr">topologyKey:</span> <span class="string">kubernetes.io/hostname</span></span><br><span class="line">          </span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-aff-required</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">pod-aff</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">myapp</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">wangyanglinux/myapp:v1.0</span></span><br><span class="line">  <span class="attr">affinity:</span></span><br><span class="line">    <span class="attr">podAffinity:</span></span><br><span class="line">      <span class="attr">requiredDuringSchedulingIgnoredDuringExecution:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">labelSelector:</span></span><br><span class="line">          <span class="attr">matchExpressions:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">app</span></span><br><span class="line">            <span class="attr">operator:</span> <span class="string">In</span></span><br><span class="line">            <span class="attr">values:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">pod-1</span></span><br><span class="line">        <span class="attr">topologyKey:</span> <span class="string">kubernetes.io/hostname</span></span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/cy77cc/pic-md/master/image-20250412143958462.png" alt="image-20250412143958462"></p>
<h3 id="8-3-污点和容忍"><a href="#8-3-污点和容忍" class="headerlink" title="8.3 污点和容忍"></a>8.3 污点和容忍</h3><h4 id="8-3-1-污点"><a href="#8-3-1-污点" class="headerlink" title="8.3.1 污点"></a>8.3.1 污点</h4><p>Taint 和 toleration 相互配合，可以用来避免 Pod 被分配到不合适的节点上。每个节点上都可以应用一个或多个 taint，这表示对于那些不能容忍这些 taint 的 Pod，是不会被该节点接受的。如果将 toleration 应用于 Pod 上，则表示这些 Pod 可以（但不要求）被调度到具有匹配 taint 的节点上。</p>
<p>每个污点有一个 key 和 value 作为污点的标签，其中 value 可以为空，effect 描述污点的作用。当前 taint effect 支持如下三个选项：</p>
<ul>
<li>NoSchedule：表示 k8s 不会将 Pod 调度到具有该污点的 Node 上。</li>
<li>PreferNoSchedule：表示 k8s 会尽量避免将 Pod 调度到具有该污点的 Node 上</li>
<li>NoExecute：表示 k8s 不会将 Pod 调度到具有该污点的 Node 上，同时会将 Node 上已经存在的 Pod 驱逐出去。（节点更新、物理机更新损坏等情况）</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">添加污点</span></span><br><span class="line">kubectl taint node k8s-master computeengine=gpu:NoSchedule（key=value:effect）</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除污点</span></span><br><span class="line">kubectl taint node k8s-master computeengine=gpu:NoSchedule-</span><br></pre></td></tr></table></figure>

<h4 id="8-3-2-容忍"><a href="#8-3-2-容忍" class="headerlink" title="8.3.2 容忍"></a>8.3.2 容忍</h4><p>设置了污点的 Node 将根据 taint 的 effect：NoSchedule、PreferNoSchedule、NoExecute 和 Pod 之间产生互斥的关系，Pod 将在一定程度上不会被调度到 Node 上。但我们可以在 Pod 上设置容忍（toleration），意思是设置了容忍的 Pod 将可以容忍污点的存在，可以被调度到存在污点的 Node 上</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">tolerations:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">key:</span> <span class="string">key1</span></span><br><span class="line">  <span class="attr">operator:</span> <span class="string">Equal</span></span><br><span class="line">  <span class="attr">value:</span> <span class="string">value1</span></span><br><span class="line">  <span class="attr">effect:</span> <span class="string">NoSchedule</span></span><br><span class="line">  </span><br><span class="line"><span class="attr">tolerations:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">key:</span> <span class="string">key1</span></span><br><span class="line">  <span class="attr">operator:</span> <span class="string">Equal</span></span><br><span class="line">  <span class="attr">value:</span> <span class="string">value1</span></span><br><span class="line">  <span class="attr">effect:</span> <span class="string">NoExecute</span></span><br><span class="line">  <span class="attr">tolerationSeconds:</span> <span class="number">3600</span></span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<p>1、当不指定 value 时，表示容忍所有的污点 value</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">key:</span> <span class="string">key2</span></span><br><span class="line">  <span class="attr">operator:</span> <span class="string">Exists</span></span><br><span class="line">  <span class="attr">effect:</span> <span class="string">NoSchedule</span></span><br></pre></td></tr></table></figure>

<p>2、当不指定 key 值时，表示容忍所有的污点 key</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">tolerations:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">operator:</span> <span class="string">Exists</span></span><br></pre></td></tr></table></figure>

<p>3、当不指定 effect 值时，表示容忍所有的污点作用</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">tolerations:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">key:</span> <span class="string">key</span></span><br><span class="line">  <span class="attr">operator:</span> <span class="string">Exists</span></span><br></pre></td></tr></table></figure>

<p>4、有多个 Master 存在时，防止资源浪费，可以如下设置</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl taint nodes NodeName node-role.kubernetes.io/master=:PreferNoSchedule</span><br></pre></td></tr></table></figure>

<h3 id="8-4-固定节点调度"><a href="#8-4-固定节点调度" class="headerlink" title="8.4 固定节点调度"></a>8.4 固定节点调度</h3><p>通过设置 <code>pod.spec.nodeName</code>将 Pod 直接调度到指定的 Node 节点上，会跳过 Scheduler 的调度策略，该匹配规则是强制匹配，可以跳过污点</p>
<p>通过<code>pod.spec.nodeSelector</code> 标签选择机制，有调度器调度策略匹配 label，而后调度 Pod 到目标节点，该匹配规则属于强制约束，不能跳过污点</p>
<h2 id="九-安全机制"><a href="#九-安全机制" class="headerlink" title="九 安全机制"></a>九 安全机制</h2><p>Kubernetes 作为一个分布式集群的管理工具，保证集群的安全性是其一个重要的任务。API Server 是集群内部各个组件通信的中间，也是外部控制的入口。所以 Kubernetes 的安全机制基本就是围绕保护 API Server 来设计的。</p>
<img src="https://raw.githubusercontent.com/cy77cc/pic-md/master/image-20250412155644138.png" alt="image-20250412155644138" style="zoom: 50%;" />

<h3 id="9-1-认证"><a href="#9-1-认证" class="headerlink" title="9.1 认证"></a>9.1 认证</h3><h4 id="9-1-1-类型"><a href="#9-1-1-类型" class="headerlink" title="9.1.1 类型"></a>9.1.1 类型</h4><ul>
<li>HTTP Token 认证：通过一个 Token 来识别合法用户<ul>
<li>HTTP Token 的认证是用一个很长的特殊编码方式并且难以被模仿的字符串 - Token 来表达客户的一种方式。Token 是一个很长并且很复杂的字符串，每一个 Token 对应一个用户名存储在 API Server 能访问的文件中。当客户端发起 API 调用请求时，需要在 HTTP Header 里放入 Token。</li>
</ul>
</li>
<li>HTTP Base 认证：通过 用户名+密码 的方式认证<ul>
<li>用户名+密码：用 BASE64 算法进行编码后的字符串放在 HTTP Request 中的 Heather Authorization 域里发送给服务端，服务端收到后进行编码，获取用户名及密码</li>
</ul>
</li>
<li>最严格的 HTTPS 证书认证：基于 CA 根证书签名的客户端身份认证方式</li>
</ul>
<p><img src="https://raw.githubusercontent.com/cy77cc/pic-md/master/image-20250412190857131.png" alt="image-20250412190857131"></p>
<p>apiserver 需要认证的类型</p>
<p>组件</p>
<ul>
<li>无需加密，基于 kubeadm 部署与 ApiServer 处于同一台机器，通过 <code>127.0.0.1</code> 访问<ul>
<li>Controller Manager、Scheduler</li>
</ul>
</li>
<li>需要加密的<ul>
<li>kubelet（证书自动颁发）、kube-proxy、kubectl（证书手动颁发）</li>
</ul>
</li>
</ul>
<p>Pod，通过 SA 认证</p>
<h4 id="9-1-2-ServiceAccount"><a href="#9-1-2-ServiceAccount" class="headerlink" title="9.1.2 ServiceAccount"></a>9.1.2 ServiceAccount</h4><p>Pod 中的容器访问 API server。因为 Pod 的创建、销毁是动态的，所以要为它手动生成证书就不可行了，Kubernetes 使用 ServiceAccount 解决 Pod 访问 API Server 的认证问题。</p>
<p>Kubernetes 设计了一种资源对象叫做 Secret，分为两类，一种是用于 ServiceAccount 的 service-account-token，另一种是用于保存用户自定义保密信息的 Opaque。ServiceAccount 中用到包含三个部分：Token、ca.crt、namespace</p>
<ul>
<li>Token 是使用 API Server 私钥签名的 JWT 。用于访问 API Server 时，Server 端认证。</li>
<li>ca.crt，根证书。用于 Client 端验证 API Server 发送的证书</li>
<li>namespace，表示这个 service-account-token 的作用域命名空间</li>
</ul>
<p>默认情况下，每个 namespace 都会有一个 ServiceAccount，如果 Pod 在创建时没有指明 ServiceAccount，就会使用 Pod 所属 namespace 的 ServiceAccount</p>
<h3 id="9-2-鉴权"><a href="#9-2-鉴权" class="headerlink" title="9.2 鉴权"></a>9.2 鉴权</h3><h4 id="9-2-1-类型"><a href="#9-2-1-类型" class="headerlink" title="9.2.1 类型"></a>9.2.1 类型</h4><p>认证的过程只是用于通信的双方相互确认对方是可信的，可以相互通信。而鉴权是确定请求方有哪些资源的权限。API Server 目前支持以下几种授权策略（通过 API Server 的启动参数“–authorization-mode”设置）</p>
<ul>
<li>AlwaysDeny：表示拒绝所有的请求，一般用户测试</li>
<li>AlwaysAllow：允许接受所有请求，如果集群不需要授权流程，则可以采用该策略</li>
<li>ABAC（Attribute-Based Access Control）：基于属性的访问控制，表示使用用户配置的授权规则对用户请求进行匹配和控制</li>
<li>Webhook：通过调用外部 REST 服务对用户进行授权</li>
<li>RBAC（Role-Based Access Control）：基于角色的访问控制，现行默认规则</li>
</ul>
<h4 id="9-2-2-RBAC"><a href="#9-2-2-RBAC" class="headerlink" title="9.2.2 RBAC"></a>9.2.2 RBAC</h4><p>RBAC（Role-Based Access Control）基于角色的访问控制，相对于其它访问控制方式，拥有一下优势：</p>
<ul>
<li>对集群中的资源和非资源均拥有完整的覆盖</li>
<li>整个 RBAC 完全由几个 API 对象完成，同其它 API 对象一样，可以用 kubectl 或 API 进行操作</li>
<li>可以在运行时进行调整，无需重启 API Server</li>
</ul>
<p>RBAC 引入了 4 个新的顶级资源对象：Role、ClusterRole、RoleBinding、ClusterRoleBinding，4 种对象类型均可以通过 kubectl 与 API 操作</p>
<img src="https://raw.githubusercontent.com/cy77cc/pic-md/master/image-20250412201807387.png" alt="image-20250412201807387" style="zoom:67%;" />

<p>有三种绑定关系：</p>
<ul>
<li>Role + RoleBinding</li>
<li>ClusterRole + ClusterRoleBinding</li>
<li>ClusterRole + RoleBinding (降维，作用域限制)</li>
</ul>
<p>在 RBAC API 中，Role 表示一组规则权限，权限只会增加（累加权限），不存在一个资源一开始就有很多权限而通过 RBAC 对其进行减少的操作；Role 可以定义在一个 namespace 中，如果想要跨 namespace 则可以创建 ClusterRole</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">kind:</span> <span class="string">Role</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"> <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line"> <span class="attr">name:</span> <span class="string">pod-reader</span></span><br><span class="line"><span class="attr">rules:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">apiGroups:</span> [<span class="string">&quot;&quot;</span>] <span class="comment"># &quot;&quot; 表示core组</span></span><br><span class="line">  <span class="attr">resources:</span> [<span class="string">&quot;pods&quot;</span>]</span><br><span class="line">  <span class="attr">verbs:</span> [<span class="string">&quot;get&quot;</span>, <span class="string">&quot;watch&quot;</span>, <span class="string">&quot;list&quot;</span>]</span><br></pre></td></tr></table></figure>

<p>ClusterRole 具有与 Role 相同的权限角色控制能力，不同的是 ClusterRole 是集群级别的，ClusterRole 可以用于：</p>
<ul>
<li>集群级别的资源控制（如 Node 访问权限）</li>
<li>非资源型 endpoints （例如 <code>/health</code> 访问）</li>
<li>所有命名空间资源控制（例如 Pods）</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">kind:</span> <span class="string">ClusterRole</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"> <span class="attr">name:</span> <span class="string">secret-reader</span></span><br><span class="line"><span class="attr">rules:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">apiGroups:</span> [<span class="string">&quot;&quot;</span>]</span><br><span class="line">  <span class="attr">resources:</span> [<span class="string">&quot;secrets&quot;</span>]</span><br><span class="line">  <span class="attr">verbs:</span> [<span class="string">&quot;get&quot;</span>, <span class="string">&quot;watch&quot;</span>, <span class="string">&quot;list&quot;</span>]</span><br></pre></td></tr></table></figure>

<p>RoleBinding + Role 可以将 Role 中定义的权限授予用于或用户组，RoleBinding 包含一组权限列表（subjects），权限列表中包含有不同形式的待授予权限资源类型（users, groups, service accounts）；RoleBinding 同样包含对被 Bind 的 Role 引用；RoleBinding 适用于某个命名空间内授权，而 ClusterRoleBinding 适用于集群范围内的授权。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">kind:</span> <span class="string">RoleBinding</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"> <span class="attr">name:</span> <span class="string">read-pods</span></span><br><span class="line"> <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">subjects:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">User</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">jane</span></span><br><span class="line">  <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br><span class="line"><span class="attr">roleRef:</span></span><br><span class="line"> <span class="attr">kind:</span> <span class="string">Role</span></span><br><span class="line"> <span class="attr">name:</span> <span class="string">pod-reader</span></span><br><span class="line"> <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br></pre></td></tr></table></figure>

<p>RoleBinding + ClusterRole 同样可以引用 ClusterRole 来对当前 namespace 内用户、用户组或 ServiceAccount 进行授权，这种操作允许集群管理员在整个集群内定义一些通用的 ClusterRole，然后在不同的 namespace 中使用 RoleBinding 来引用</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这个角色绑定只允许dave在dev命名空间内读取Secret</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">RoleBinding</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"> <span class="attr">name:</span> <span class="string">read-secrets</span></span><br><span class="line"> <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">subjects:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">User</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">dave</span></span><br><span class="line">  <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br><span class="line"><span class="attr">roleRef:</span></span><br><span class="line"> <span class="attr">kind:</span> <span class="string">ClusterRole</span></span><br><span class="line"> <span class="attr">name:</span> <span class="string">secret-reader</span></span><br><span class="line"> <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br></pre></td></tr></table></figure>

<p>ClusterRoleBinding 可以对整个集群中的所有命名空间资源权限进行授权；一下 ClusterRoleBinding 样例展示了授权 manager 组内所有用户在全部命名空间中对 secrets 进行访问</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">kind:</span> <span class="string">ClusterRoleBinding</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"> <span class="attr">name:</span> <span class="string">read-secrets-global</span></span><br><span class="line"><span class="attr">subjects:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">Group</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">manager</span></span><br><span class="line">  <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br><span class="line"><span class="attr">roleRef:</span></span><br><span class="line"> <span class="attr">kind:</span> <span class="string">ClusterRole</span></span><br><span class="line"> <span class="attr">name:</span> <span class="string">secret-reader</span></span><br><span class="line"> <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br></pre></td></tr></table></figure>

<p><strong>Resources</strong>：Kubernetes 集群内一些资源一般以其名称字符串来表示，这些字符串一般会在 API 的 URL 地址中出现；同时某些资源也会包含子资源，例如 logs 资源就属于 pods 的子资源，API 中 URL 样例如下</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /api/v1/namespace/&#123;namespace&#125;/pods/&#123;name&#125;/log</span><br></pre></td></tr></table></figure>

<p>如果要在 RBAC 授权模型中控制这些子资源的访问权限，可以通过 &#x2F; 分隔符来实现，以下是一个定义 pods 资源 logs 访问权限的 Role 定义样例</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">...</span></span><br><span class="line"><span class="attr">rules:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">apiGroups:</span> [<span class="string">&quot;&quot;</span>]</span><br><span class="line">  <span class="attr">resources:</span> [<span class="string">&quot;pods/log&quot;</span>]</span><br><span class="line">  <span class="attr">verbs:</span> [<span class="string">&quot;get&quot;</span>, <span class="string">&quot;list&quot;</span>]</span><br></pre></td></tr></table></figure>

<p>subjects</p>
<p><img src="https://raw.githubusercontent.com/cy77cc/pic-md/master/image-20250412211511314.png" alt="image-20250412211511314"></p>
<h4 id="9-2-3-实操"><a href="#9-2-3-实操" class="headerlink" title="9.2.3 实操"></a>9.2.3 实操</h4><p>需求：创建一个用户只能管理 dev 命名空间</p>
<p>实现：创建证书 &gt; 装换为 kubeconfig 文件 &gt; 创建命名空间 &gt; 角色绑定</p>
<h2 id="kubectl操作"><a href="#kubectl操作" class="headerlink" title="kubectl操作"></a>kubectl操作</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">kubectl get ns(namespace) # 获取命名空间</span><br><span class="line">kubectl get po(pod) # 获取默认命名空间下的pod</span><br><span class="line">kubectl get nodes # 获取节点信息</span><br><span class="line">kubectl scale deploy --replicas=3 nginx # 设置deploy副本数为3</span><br><span class="line">kubectl create -f pod.yaml   # 基于pod.yaml文件创建pod资源</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">获取当前资源，pod、node、namespace</span></span><br><span class="line">kubectl get pod</span><br><span class="line">	-A,--all-namespaces   	查看当前所有命名空间的资源</span><br><span class="line">	-n						指定命名空间，默认值default，kube-system空间存放的时当前组件资源</span><br><span class="line">	-l 						筛选资源，key  key=value</span><br><span class="line">	-o wide 				详细信息包括IP、分配的节点等</span><br><span class="line">	-w						监控资源的变化状态</span><br><span class="line"><span class="meta prompt_">	</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">示例</span></span><br><span class="line">kubectl get pod --show-labels # 查看标签</span><br><span class="line">kubectl get pod -l app(app=nginx) # 通过标签筛选pod   app是key</span><br><span class="line">	</span><br><span class="line"><span class="meta prompt_">	</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">进入Pod内部的容器执行命令</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">当一个pod内部就一个容器时，可以省略ContainerName(不包括pause)</span></span><br><span class="line">kubectl exec -it PodName -c ContainerName -- command</span><br><span class="line">	-c 						可以省略，默认进入唯一的容器内部</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">示例</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">进入pod容器内部</span></span><br><span class="line">kubectl exec -it pod名称 -c 容器名称 -- /bin/bash</span><br><span class="line">kubectl exec -it nginx-5869d7778c-5wwcd -c nginx -- /bin/bash</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看资源的描述</span></span><br><span class="line">kubectl explain pod.spec</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看Pod内部容器的日志</span></span><br><span class="line">kubectl logs PodName -c ContainerName</span><br><span class="line">kubectl logs app=nginx -c nginx # 查看日志</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看资源的详细信息</span></span><br><span class="line">kubectl describe pod PodName (node NodeName)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除pod</span></span><br><span class="line">kubectl delete pod PodName</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除所有pod</span></span><br><span class="line">kubectl delete pod --all</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除由k8s.ymal创建的资源</span></span><br><span class="line">kubectl delete -f k8s.yaml</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建service，service会匹配myapp标签的pod</span></span><br><span class="line">kubectl create svc clusterip myapp --tcp=80:80</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">标签操作</span></span><br><span class="line">kubectl label pod PodName key=value  # 想PodName添加key=value的标签</span><br><span class="line">	--overwrite</span><br><span class="line"><span class="meta prompt_">	</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">扩容操作</span></span><br><span class="line">kubectl scale rc rcName --replicas=5</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">--dry-run 只测试不运行，在不记得怎么写资源清单的时候可以用这个得到模板</span></span><br><span class="line">kubectl create deploy myapp --image=wangyanglinux/myapp:v1.0 --dry-run -o yaml</span><br></pre></td></tr></table></figure>



<p>每个Pod都有一个pause容器，Pod内的其他容器共享pause容器的Pid，Uid等信息</p>
<p><img src="https://raw.githubusercontent.com/cy77cc/pic-md/master/image-20250406163615248.png" alt="image-20250406163615248"></p>
<p>高可用集群，如果一个节点挂了会发生哪些事情 <a target="_blank" rel="noopener" href="https://developer.aliyun.com/article/785311">https://developer.aliyun.com/article/785311</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://cy77cc.github.io/2025/04/06/Kubernetes%EF%BC%88k8s%EF%BC%89/" data-id="cm8wiyf4t0000qslza6gj3g58" data-title="k8s学习记录" class="article-share-link"><span class="fa fa-share">Compartir</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6-docker-kubernetes/" rel="tag">中间件,docker,kubernetes</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-设计模式" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/04/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" class="article-date">
  <time class="dt-published" datetime="2025-04-05T08:48:00.000Z" itemprop="datePublished">2025-04-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/04/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">Go设计模式</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="一、创建型设计模式"><a href="#一、创建型设计模式" class="headerlink" title="一、创建型设计模式"></a>一、创建型设计模式</h2><h3 id="1-单例模式"><a href="#1-单例模式" class="headerlink" title="1. 单例模式"></a>1. 单例模式</h3><p>单例模式（Singleton Pattern）是一种常用的软件设计模式。单例模式的类提供了一种访问其唯一对象的方法，该对象可以直接被访问，无须实例化。单例模式保证了一个类的对象只存在一个，同时维护了一个对其对象的全局访问点。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="keyword">type</span> Singleton <span class="keyword">struct</span> &#123;</span><br><span class="line">	Value <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance *Singleton</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> mutex *sync.Mutex</span><br></pre></td></tr></table></figure>

<h4 id="1-1-懒汉式单例模式"><a href="#1-1-懒汉式单例模式" class="headerlink" title="1.1 懒汉式单例模式"></a>1.1 懒汉式单例模式</h4><p>懒汉式单例模式是指，在创建对象时，不直接创建对象，在加载配置文件时才创建对象。需要加锁保证并发安全。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LazyGetInstance</span><span class="params">()</span></span> *Singleton &#123;</span><br><span class="line">	mutex.Lock()</span><br><span class="line">	<span class="keyword">defer</span> mutex.Unlock()</span><br><span class="line">	<span class="keyword">if</span> instance == <span class="literal">nil</span> &#123;</span><br><span class="line">		instance = <span class="built_in">new</span>(Singleton)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> instance</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-2-饿汉式单例模式"><a href="#1-2-饿汉式单例模式" class="headerlink" title="1.2 饿汉式单例模式"></a>1.2 饿汉式单例模式</h4><p>在创建对象时，不判断创建的对象是否为空，直接创建对象。时并发安全的，唯一的缺点时在导入包的同时会创建对象，并且创建的对象会持续存在与内存中。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入包时创建</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> instance == <span class="literal">nil</span> &#123;</span><br><span class="line">		instance = <span class="built_in">new</span>(Singleton)</span><br><span class="line">		fmt.Println(<span class="string">&quot;创建单个实例&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HungryGetInstance</span><span class="params">()</span></span> *Singleton &#123;</span><br><span class="line">	<span class="keyword">return</span> instance</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-3-双重检查单例模式"><a href="#1-3-双重检查单例模式" class="headerlink" title="1.3 双重检查单例模式"></a>1.3 双重检查单例模式</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DoubleCheckGetInstance</span><span class="params">()</span></span> *Singleton &#123;</span><br><span class="line">	<span class="keyword">if</span> instance == <span class="literal">nil</span> &#123;</span><br><span class="line">		mutex.Lock()</span><br><span class="line">		<span class="keyword">if</span> instance == <span class="literal">nil</span> &#123;</span><br><span class="line">			instance = <span class="built_in">new</span>(Singleton)</span><br><span class="line">			fmt.Println(<span class="string">&quot;创建单个实例&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		mutex.Unlock()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> instance</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-4-sync-Once单例模式"><a href="#1-4-sync-Once单例模式" class="headerlink" title="1.4 sync.Once单例模式"></a>1.4 sync.Once单例模式</h4><p>init()函数会在包被首次加载的时候执行，如果被加载的包不立即使用，会浪费内存空间和程序加载时间。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> once sync.Once</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">OnceGetInstance</span><span class="params">()</span></span> *Singleton &#123;</span><br><span class="line">	once.Do(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		instance = <span class="built_in">new</span>(Singleton)</span><br><span class="line">		fmt.Println(<span class="string">&quot;创建单个实例&quot;</span>)</span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="keyword">return</span> instance</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><ol>
<li>优点<ul>
<li>单例模式可以拓展为工厂模式</li>
<li>对于需要频繁创建和销毁对象的系统，使用单例模式可以提升系统的性能。</li>
</ul>
</li>
<li>缺点<ul>
<li>可拓展性差</li>
<li>如果实例化的对象长时间没有被使用，会被GC，导致对象缺失。</li>
</ul>
</li>
</ol>
<h3 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h3><h4 id="1-1-使用场景"><a href="#1-1-使用场景" class="headerlink" title="1.1 使用场景"></a>1.1 使用场景</h4>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://cy77cc.github.io/2025/04/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" data-id="cm93zwe9b0000uklz81mc6pux" data-title="Go设计模式" class="article-share-link"><span class="fa fa-share">Compartir</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/go/" rel="tag">go</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-nginx" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/04/04/nginx/" class="article-date">
  <time class="dt-published" datetime="2025-04-04T11:02:00.000Z" itemprop="datePublished">2025-04-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/04/04/nginx/">Nginx</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="Nginx服务的启动和暂停"><a href="#Nginx服务的启动和暂停" class="headerlink" title="Nginx服务的启动和暂停"></a>Nginx服务的启动和暂停</h2><ul>
<li>启动：直接运行nginx软件</li>
<li>暂停</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">nginx -s stop       快速关闭Nginx，可能不保存相关信息，并迅速终止web服务。</span><br><span class="line">nginx -s quit       平稳关闭Nginx，保存相关信息，有安排的结束web服务。</span><br><span class="line">nginx -s reload     因改变了Nginx相关配置，需要重新加载配置而重载。</span><br><span class="line">nginx -s reopen     重新打开日志文件。</span><br><span class="line">nginx -c filename   为 Nginx 指定一个配置文件，来代替缺省的。</span><br><span class="line">nginx -t            不运行，仅仅测试配置文件。nginx 将检查配置文件的语法的正确性，并尝试打开配置文件中所引用到的文件。</span><br><span class="line">nginx -v            显示 nginx 的版本。</span><br><span class="line">nginx -V            显示 nginx 的版本，编译器版本和配置参数。</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="https://cy77cc.github.io/2025/04/04/nginx/" data-id="cm92oesh50006mclzbelj1pbo" data-title="Nginx" class="article-share-link"><span class="fa fa-share">Compartir</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/nginx/" rel="tag">nginx</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Git" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/04/04/Git/" class="article-date">
  <time class="dt-published" datetime="2025-04-04T05:01:00.000Z" itemprop="datePublished">2025-04-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/04/04/Git/">Git</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="Git的一些知识"><a href="#Git的一些知识" class="headerlink" title="Git的一些知识"></a>Git的一些知识</h2><ul>
<li>工作区：.git所在的目录</li>
<li>暂存区：.git&#x2F;index</li>
<li>本地仓库：.git&#x2F;objects</li>
</ul>
<p><img src="https://raw.githubusercontent.com/cy77cc/pic-md/master/image-20250404130234654.png" alt="image-20250404130234654"></p>
<ul>
<li>文件一共有四种状态<ul>
<li>未跟踪（Untrack）</li>
<li>未修改（Unmodified）</li>
<li>已修改（Modified）</li>
<li>已暂存（Staged）</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/cy77cc/pic-md/master/image-20250404130531714.png" alt="image-20250404130531714"></p>
<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">git init 				创建仓库</span><br><span class="line">git status 				查看仓库的状态</span><br><span class="line">git add 				添加到暂存区</span><br><span class="line">git rm --cached &lt;file&gt; 	将文件从暂存区移除</span><br><span class="line">git restore 			撤销修改</span><br><span class="line">git commit 				提交</span><br><span class="line">git log 				查看仓库提交历史记录，可以使用--oneline参数来查看简洁的提交记录</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">git reset 				恢复到之前的版本</span><br><span class="line">	git reset --soft  	回到之前的某一个版本，并且保存工作区和暂存区的所有修改内容</span><br><span class="line">	git reset --hard  	回到之前的某一个版本，并且丢弃工作区和暂存区的所有修改内容</span><br><span class="line">	git reset --mixed 	回到之前的某一个版本，并且只保存工作区的内容，丢弃暂存区的修改内容</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">git reflog 				操作记录</span><br><span class="line">git ls-files			查看暂存区中的内容 </span><br><span class="line"></span><br><span class="line">git diff  				查看文件在工作区、暂存区、本地仓库之间的差异，</span><br><span class="line">						查看不同版本之间的差异，</span><br><span class="line">						查看不同分支之间的差异</span><br><span class="line">	git diff HEAD~3 HEAD [filename]							和当前最新提交的前第三个版本进行比较（或者只对比某个文件）</span><br><span class="line"></span><br><span class="line">git rm 					删除一个文件，把文件从工作区和暂存区同时删除</span><br><span class="line">git fetch 				从远程仓库中拉取代码</span><br><span class="line">git pull				从远程仓库中拉取代码，并合并分支，如果有冲突会合并失败</span><br><span class="line"></span><br><span class="line">git remote add &lt;远程仓库别名&gt; &lt;远程仓库地址&gt;  添加远程仓库</span><br><span class="line">git push -u &lt;远程仓库别名&gt; &lt;分支名&gt;    上传本地仓库的代码到远程仓库</span><br><span class="line">git remote -v 			查看远程仓库</span><br><span class="line"></span><br><span class="line">git branch dev 			创建dev分支</span><br><span class="line">git checkout dev 		切换到dev分支，恢复文件</span><br><span class="line">git switch main			切换分支</span><br><span class="line">git checkout -b dev 	创建并切换到dev分支</span><br><span class="line"></span><br><span class="line">合并分支</span><br><span class="line">git switch main			先切换到main分支</span><br><span class="line">git merge dev			将dev分支合并到main分支上</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">git log --graph --oneline --decorate --all  查看历史</span><br><span class="line"></span><br><span class="line">git branch -d dev		删除dev分支</span><br><span class="line">git branch -D dev 		强制删除dev分支</span><br><span class="line"></span><br><span class="line">git rebase dev			找到main分支和dev分支的最近公共祖先，将最近公共祖先后面的dev分支合并到main的后面</span><br><span class="line">						在哪个分支上执行就是合并到哪个分支的后面</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/cy77cc/pic-md/master/image-20250404134558888.png" alt="image-20250404134558888"></p>
<p><img src="https://raw.githubusercontent.com/cy77cc/pic-md/master/image-20250404134930219.png" alt="image-20250404134930219"></p>
<p><img src="https://raw.githubusercontent.com/cy77cc/pic-md/master/image-20250404154758934.png" alt="image-20250404154758934"></p>
<p><img src="https://raw.githubusercontent.com/cy77cc/pic-md/master/image-20250404161550825.png" alt="image-20250404161550825"></p>
<h2 id="什么时候会发生冲突"><a href="#什么时候会发生冲突" class="headerlink" title="什么时候会发生冲突"></a>什么时候会发生冲突</h2><p>不同分支对相同的文件进行了更改，在合并分支时就会发生冲突。需要手动处理冲突后，添加文件到暂存区，提交。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge --abort		冲突发生后中断合并</span><br></pre></td></tr></table></figure>

<h2 id="工作流模型"><a href="#工作流模型" class="headerlink" title="工作流模型"></a>工作流模型</h2><h3 id="版本号规则"><a href="#版本号规则" class="headerlink" title="版本号规则"></a>版本号规则</h3><p>主版本.次版本.修订版本1.0.0</p>
<ul>
<li>主版本（Major Version）：主要的功能变化或重大更新；</li>
<li>次版本（Minor Version）：一些新的功能、改进和更新，通常不会影响现有功能；</li>
<li>修订版本（Patch Version）：一些小的bug修复，安全漏洞补丁等。通常不会更改现有功能和接口；</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://cy77cc.github.io/2025/04/04/Git/" data-id="cm92oesgv0000mclzbznz5sn4" data-title="Git" class="article-share-link"><span class="fa fa-share">Compartir</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/tool/" rel="tag">tool</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-docker" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/04/04/docker/" class="article-date">
  <time class="dt-published" datetime="2025-04-04T02:47:00.000Z" itemprop="datePublished">2025-04-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="https://cy77cc.github.io/2025/04/04/docker/" data-id="cm92oesh20003mclz9sew588g" data-title="" class="article-share-link"><span class="fa fa-share">Compartir</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/docker/" rel="tag">docker</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-RocketMQ" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/04/04/RocketMQ/" class="article-date">
  <time class="dt-published" datetime="2025-04-04T02:22:00.000Z" itemprop="datePublished">2025-04-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/04/04/RocketMQ/">RocketMQ</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="https://cy77cc.github.io/2025/04/04/RocketMQ/" data-id="cm92oesgz0001mclz3usadz74" data-title="RocketMQ" class="article-share-link"><span class="fa fa-share">Compartir</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/mq/" rel="tag">mq</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-消息队列" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/03/25/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/" class="article-date">
  <time class="dt-published" datetime="2025-03-25T05:21:00.000Z" itemprop="datePublished">2025-03-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/03/25/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/">各种消息队列MQ的学习记录</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="一、MQ介绍"><a href="#一、MQ介绍" class="headerlink" title="一、MQ介绍"></a>一、MQ介绍</h1><h2 id="1、什么时MQ，有什么用"><a href="#1、什么时MQ，有什么用" class="headerlink" title="1、什么时MQ，有什么用"></a>1、什么时MQ，有什么用</h2><p>MQ（message queue），消息队列。<strong>message是在不同应用程序实践传递的数据，queue将消息以队列的形式存储起来，并且在不同的应用程序之间进行传递。生产者（producer）发送消息，消费者（consumer）接收消息。</strong></p>
<img src="https://raw.githubusercontent.com/cy77cc/pic-md/master/image-20250325163831883.png" alt="image-20250325163831883" style="zoom:80%;" />

<p>在上面这个例子中，订单服务在生成订单后，发送消息到MQ，短信服务、积分服务、通知服务在监听到MQ变化后接收消息，进行下一步的处理。</p>
<p>在这个业务中，MQ中间件应该要起到什么作用呢？</p>
<ul>
<li><strong>解耦</strong>：Producer和Consumer都只跟中间件进行交互，而不需要互相进行交互。这意味着，在Producer发送消息时，不需要考虑有没有Consumer或者有多少个Consumer。反之亦然。甚至，即便Producer和Consumer是用不同语言开发的，只要都能够与MQ中间件正常交互，那么他们就可以通过MQ中间件进行消息传递。</li>
<li><strong>异步</strong>：消息并不是从Producer发送出来后，就立即交由Consumer处理，而是在MQ中间件中暂存下来。等到Consumer启动后，自行去MQ中间件上处理。也就是说，错开了Producer发送消息和Consumer消费消息的时间。</li>
<li><strong>削峰</strong>：有了MQ做消息暂存，那么当Producer发送消息的速度与Consumer处理消息的速度不一致时，MQ就能起到削峰填谷的作用。</li>
</ul>
<h2 id="2、主流MQ产品对比"><a href="#2、主流MQ产品对比" class="headerlink" title="2、主流MQ产品对比"></a>2、主流MQ产品对比</h2><table>
<thead>
<tr>
<th></th>
<th>优点</th>
<th>缺点</th>
<th>使用场景</th>
</tr>
</thead>
<tbody><tr>
<td>Kafka</td>
<td>吞吐量非常大，性能非常好，技术生态完整</td>
<td>功能比较单一</td>
<td>分布式日志收集，大数据采集</td>
</tr>
<tr>
<td>RabbitMQ</td>
<td>消息可靠性高，功能全面</td>
<td>吞吐量较低。消息积压会影响性能。</td>
<td>企业内部系统调用</td>
</tr>
<tr>
<td>RocketMQ</td>
<td>高吞吐、高性能、高可用，高级功能非常齐全</td>
<td>技术生态相对没有那么完整</td>
<td>几乎全场景。尤其适合金融</td>
</tr>
</tbody></table>
<h1 id="二、消息队列的流派"><a href="#二、消息队列的流派" class="headerlink" title="二、消息队列的流派"></a>二、消息队列的流派</h1><h2 id="1-有broker"><a href="#1-有broker" class="headerlink" title="1. 有broker"></a>1. 有broker</h2><ul>
<li><p>重topic：kafka、rocketMQ、activeMQ</p>
<p>整个broker，依据topic来进行消息的中转。在重topic的消息队列里必然需要topic的存在</p>
</li>
<li><p>轻topic：rabbitMQ</p>
<p>topic只是一种中转模式</p>
</li>
</ul>
<h2 id="2-无broker"><a href="#2-无broker" class="headerlink" title="2. 无broker"></a>2. 无broker</h2><p>在生产者和消费者之间没有使用broker，例如zeroMQ，直接使用socket进行通信。</p>
<h1 id="三、Kafka"><a href="#三、Kafka" class="headerlink" title="三、Kafka"></a>三、Kafka</h1><h2 id="1-Kafka的基本概念"><a href="#1-Kafka的基本概念" class="headerlink" title="1. Kafka的基本概念"></a>1. Kafka的基本概念</h2><p>kafka是一个分布式的，分区的消息服务。它提供了一个消息系统应该具备的功能，但是却有着独特的设计。可以这样来说，kafka借鉴了JMS（Java Message Service）规范的思想，但是并没有完全遵循JMS规范。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>Broker</td>
<td>消息中间件处理节点，一个Kafka节点就是一个broker，一个或者多个Broker组成一个kafka集群</td>
</tr>
<tr>
<td>Topic</td>
<td>kafka根据topic对消息进行归类，发布到kafka集群的每条消息都需要指定一个topic</td>
</tr>
<tr>
<td>Producer</td>
<td>消息生产者，向Broker发送消息的客户端</td>
</tr>
<tr>
<td>Consumer</td>
<td>消息消费者，从Broker读取消息的客户端</td>
</tr>
<tr>
<td>ConsumerGroup</td>
<td>每个Consumer属于一个特定的Consumer Group，一条消息可以被多个不同的Consumer Group消费，但是一个Consumer Group重智能有一个Consumer能够消费该消息</td>
</tr>
<tr>
<td>Partition</td>
<td>物理上的概念，一个topic可以分为多个partition，每个partition内部消息是有序的</td>
</tr>
</tbody></table>
<h2 id="2-创建topic"><a href="#2-创建topic" class="headerlink" title="2. 创建topic"></a>2. 创建topic</h2><p>kafka4.0</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动容器</span></span><br><span class="line">docker run -d --name broker apache/kafka:latest</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设定工作目录，进入容器内</span></span><br><span class="line">docker exec --workdir /opt/kafka/bin/ -it broker sh</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建topic，4.0不用zookeeper就这样启动</span></span><br><span class="line">./kafka-topics.sh --bootstrap-server localhost:9092 --create --topic test-topic</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">4.0之前</span></span><br><span class="line">./kafka-topics.sh --create --zookeeper zookeeper地址 --replication-factor 1 --partitions 1 --topic test</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看所有的topic</span></span><br><span class="line">./kafka-topics.sh --bootstrap-server localhost:9092 --list</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="3-发送消息"><a href="#3-发送消息" class="headerlink" title="3. 发送消息"></a>3. 发送消息</h2><p>kafka自带了一个producer命令客户端，可以从本地文件中读取内容，或者我们也可以命令行直接输入内容，并将这些内容以消息的形式发送到kafka集群中。在默认情况下，每一个行会被当做成一个独立的消息。使用kafka的发送消息的客户端，指定发送到kafka服务器地址和topic</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./kafka-console-producer.sh --bootstrap-server localhost:9092 --topic test-topic</span><br></pre></td></tr></table></figure>

<p>把消息发送给broker中的某个topic，打开一个kafka发送消息的客户端，然后开始用客户端向kafka服务器发送消息。</p>
<h2 id="4-消费消息"><a href="#4-消费消息" class="headerlink" title="4. 消费消息"></a>4. 消费消息</h2><p>对于consumer，kafka携带了一个命令行客户端，会将获取到的内容在命令中进行输出，<strong>默认是消费最新的消息</strong>。使用kafka的消费者消息客户端，从指定kafka服务器的指定topic中消费消息</p>
<p>打开一个消费消息的客户端，向kafka服务器的某个主题消费消息</p>
<ul>
<li>方式一：从最后一条消息的偏移量+1开始消费</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic test</span><br></pre></td></tr></table></figure>

<ul>
<li>方式二：从头开始消费</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">从开始消费消息</span></span><br><span class="line">./kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic test-topic --from-beginning</span><br></pre></td></tr></table></figure>

<h2 id="5-关于消息的细节"><a href="#5-关于消息的细节" class="headerlink" title="5. 关于消息的细节"></a>5. 关于消息的细节</h2><ul>
<li><p>生产者将消息发送给broker，broker会将消息保存在本地的日志文件中。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/tmp/kraft-combined-logs/test-0/00000000000000000000.log</span><br></pre></td></tr></table></figure>
</li>
<li><p>消息的保存是有序的，通过offset偏移量来描述消息的有序性。</p>
</li>
<li><p>消费者消费消息时也是通过offset来描述当前要消费的消息的位置。</p>
</li>
</ul>
<h2 id="6-单播消息"><a href="#6-单播消息" class="headerlink" title="6. 单播消息"></a>6. 单播消息</h2><p>在一个kafka的topic中，启动两个消费者，一个生产者，问：生产者发送消息，这条消息是否同时会被两个消费者消费？</p>
<p>如果多个消费者在同一个消费组，那么只有一个消费者可以收到订阅的topic中的消息，换言之，同一个消费组中只能有一个消费者收到一个topic中的消息。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./kafka-console-comsumer.sh --bootstrap-server localhost:9092 --consumer-property group.id=testGroup --topic test</span><br></pre></td></tr></table></figure>

<h2 id="7-多播消息"><a href="#7-多播消息" class="headerlink" title="7. 多播消息"></a>7. 多播消息</h2><p>不同的消费组订阅同一个topic，那么不同的消费组中只有一个消费者能收到消息。实际上也是多个消费组中的多个消费者收到了同一个消息。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./kafka-console-comsumer.sh --bootstrap-server localhost:9092 --consumer-property group.id=testGroup --topic test</span><br><span class="line">./kafka-console-comsumer.sh --bootstrap-server localhost:9092 --consumer-property group.id=testGroup1 --topic test</span><br></pre></td></tr></table></figure>

<h2 id="8-查看消费组及信息"><a href="#8-查看消费组及信息" class="headerlink" title="8. 查看消费组及信息"></a>8. 查看消费组及信息</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看当前主题下有哪些消费组，没有显式指定消费组<span class="built_in">id</span>会有默认的随机消费组</span></span><br><span class="line">./kafka-consumer-groups.sh --bootstrap-server localhost:9092 --list</span><br><span class="line">console-consumer-74284</span><br><span class="line">console-consumer-80820</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看消费组中的具体信息：比如当前偏移量、最后一条消息的偏移量、堆积的消息数量</span></span><br><span class="line">./kafka-consumer-groups.sh --bootstrap-server localhost:9092 --describe --group testGroup</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GROUP                  TOPIC           PARTITION  CURRENT-OFFSET  LOG-END-OFFSET  LAG             CONSUMER-ID                                           HOST            CLIENT-ID</span><br><span class="line">console-consumer-80820 test            0          -               7               -               console-consumer-b2f852a9-12c9-48ed-bcf0-e6fc97807524 /127.0.0.1      console-consumer</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>CURRENT-OFFSET：当前消费组的已消费偏移量，最后被消费的消息的偏移量</li>
<li>LOG_END_OFFSET：主题对应分区消息的结束偏移量（HW），最后一条消息的偏移量</li>
<li>LAG：当前消费组未消费的消息数，积压了多少条消息</li>
</ul>
<h1 id="四、kafka主题、分区的概念"><a href="#四、kafka主题、分区的概念" class="headerlink" title="四、kafka主题、分区的概念"></a>四、kafka主题、分区的概念</h1><h2 id="1-主题topic"><a href="#1-主题topic" class="headerlink" title="1. 主题topic"></a>1. 主题topic</h2><p>主题-topic在kafka中是一个逻辑的概念，kafka通过topic将消息进行分类。不同的topic会被订阅该topic的消费者消费。</p>
<p>如果说这个topic中的消息可能非常非常多，多到需要几个T来存，因为消息是会保存到log日志文件中。为了解决这个文件过大的问题，kafka提出了partition的概念。</p>
<h2 id="2-分区Partition"><a href="#2-分区Partition" class="headerlink" title="2. 分区Partition"></a>2. 分区Partition</h2><h3 id="1）分区的概念"><a href="#1）分区的概念" class="headerlink" title="1）分区的概念"></a>1）分区的概念</h3><p>一个主题中的消息量是非常大的，因此可以通过分区的设置，分布式存储这些消息。比如一个topic创建3个分区。那么topic中的消息就会分别存放在这三个分区中。 </p>
<ul>
<li>分区存储，可以解决同意存储文件过大的问题</li>
<li>提供了读写的吞吐量：读和写可以同时在多个分区中进行</li>
<li>可以分布式存储</li>
<li>可以并行写</li>
</ul>
<h3 id="2）创建多分区的主题"><a href="#2）创建多分区的主题" class="headerlink" title="2）创建多分区的主题"></a>2）创建多分区的主题</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建一个两个分区的主题test1</span></span><br><span class="line">./kafka-topics.sh --create --bootstrap-server localhost:9092 --replication-factor 1 --partitions 2 --topic test1</span><br></pre></td></tr></table></figure>

<h2 id="3-kafka中消息日志文件保存的内容"><a href="#3-kafka中消息日志文件保存的内容" class="headerlink" title="3.kafka中消息日志文件保存的内容"></a>3.kafka中消息日志文件保存的内容</h2><ul>
<li><p>000000000.log：这个文件保存的就是消息</p>
</li>
<li><p>__consumer_offsets-49：kafka内部创建了__consumer_offsets 主题包含了50个分区。这个主题用来存放消费者消费某个主题的偏移量。 </p>
<ul>
<li>存放数据内容是：key是consumerGroupId+topic+分区号，value就是当前offset的值，kafka会定期清理topic里的消息，最后就保留最新的那条数据。</li>
<li>kafka默认分配50个分区（可以通过offsets.topic.num.partitions设置），通过$hash(consumerGoupId) % __consumer_offsets主题的分区数$可以选出consumer消费的offset要提交到__consumer_offsets的哪个分区</li>
</ul>
</li>
<li><p>文件中保存的消息，默认保存七天。七天后消息会被删除。</p>
</li>
</ul>
<h1 id="五、kafka集群操作"><a href="#五、kafka集群操作" class="headerlink" title="五、kafka集群操作"></a>五、kafka集群操作</h1><h2 id="1-搭建kafka集群"><a href="#1-搭建kafka集群" class="headerlink" title="1. 搭建kafka集群"></a>1. 搭建kafka集群</h2><h2 id="2-副本的概念"><a href="#2-副本的概念" class="headerlink" title="2. 副本的概念"></a>2. 副本的概念</h2><p>在创建主题时，除了指明主题的分区数以外，还指明了副本数。副本是为了为主题中的分区创建多个副本，多个副本在kafka集群的多个broker中，会有一个副本作为leader，其他是follower。</p>
<ul>
<li>leader：kafka的写和读操作，都发生在leader上。leader负责把数据同步给followe。当leader挂了，经过主从选举，从多个follower中选举出一个新的leader（raft）。</li>
<li>follower：接收leader的同步数据</li>
<li>isr：可以同步和已同步的节点会被存入isr集合中。如果isr中的节点性能较差，会被踢出isr集合。</li>
</ul>
<p>集群中有多个broker，创建主题时可以指明主题有多个分区（把消息拆分到不同的分区中存储），可以为分区创建多个副本，不同的副本存放在不同的broker中。</p>
<h2 id="3-关于分区消费组消费者的细节"><a href="#3-关于分区消费组消费者的细节" class="headerlink" title="3. 关于分区消费组消费者的细节"></a>3. 关于分区消费组消费者的细节</h2><p>一个kafka集群有两个broker，每个broker中有多个partition。一个partition只能被一个消费组里的某一个消费者消费，从而保证消费顺序。kafka只在partition的范围内保证消息消费的局部顺序性，不能在同一个topic中的多个partition中保证总的消费顺序。一个消费者可以消费多个partition。</p>
<p>消费组中消费者的数量不能比一个topic中的partition数量多，否则多出来的消费者消费不到消息。</p>
<h1 id="六、Go操作kafka"><a href="#六、Go操作kafka" class="headerlink" title="六、Go操作kafka"></a>六、Go操作kafka</h1><h2 id="1-ack"><a href="#1-ack" class="headerlink" title="1. ack"></a>1. ack</h2><p>在同步发送的前提下，生产者在获得集群返回的ack之前会一直阻塞。分别有下面三种配置：</p>
<ul>
<li>ack&#x3D;0：kafka集群不需要任何的broker收到消息，就立即返回ack给生产者，最容易丢消息，效率最高。</li>
<li>ack&#x3D;1（默认）：多副本之间leader已经收到消息，并把消息写入到本地的log中，才会返回ack给生产者，性能和安全性最均衡的</li>
<li>ack&#x3D;-1&#x2F;all：等到集群内有超过配置的min.insync.replicas个broker写入本地消息才会返回ack，最安全，但性能最差</li>
</ul>
<h1 id="七、kafka集群controller、rebalance和HW"><a href="#七、kafka集群controller、rebalance和HW" class="headerlink" title="七、kafka集群controller、rebalance和HW"></a>七、kafka集群controller、rebalance和HW</h1><h2 id="1-Controller"><a href="#1-Controller" class="headerlink" title="1. Controller"></a>1. Controller</h2><p>集群的controller，负责管理整个集群中的所有分区和副本的状态：</p>
<ul>
<li>当某个分区的leader副本出现故障时，由控制器负责为该分区选举新的leader副本。</li>
<li>当检测到某个分区的ISR集合发生变化时，由控制器负责为该分区选举新的leader副本。</li>
<li>当使用kafka-topics.sh脚本为某个topic增加分区数量时，同样还是有controller负责让新分区被其他节点感知。</li>
</ul>
<h2 id="2-Rebalance机制"><a href="#2-Rebalance机制" class="headerlink" title="2. Rebalance机制"></a>2. Rebalance机制</h2><p>前提是：消费者没有指明分区消费。当消费组里消费者和分区的关系发送变化，就会出发rebalance机制。</p>
<p>这个机制会重新调整消费者消费哪个分区。</p>
<p>在触发rebalance机制之前，消费者消费哪个分区有三种策略：</p>
<ul>
<li>range：通过公式（总分区数&#x2F;消费组消费者总数）计算某个消费者消费哪个分区。</li>
<li>轮询：轮询消费</li>
<li>sticky：在触发rebalance后，在消费者消费的原分区不变的基础上进行调整。将挂掉的消费者所持有的分区分到剩下的消费者上。如果有消费者挂了，但是没用这种策略就需要重新分配。</li>
</ul>
<h2 id="3-HW和LEO"><a href="#3-HW和LEO" class="headerlink" title="3. HW和LEO"></a>3. HW和LEO</h2><p>LEO（log-end-offset）是某个副本最后消息的消息位置</p>
<p>HW俗称高水位，HighWatermark的缩写，取一个partition对应的ISR最小的LEO作为HW，consumer最多只能消费到HW所在的位置。另外每个replica都有HW，leader和follower各自负责更新自己的HW的状态。对于leader新写入的消息，consumer不能立刻消费，leader会等待该消息被所有ISR中的replicas同步后更新HW，此时消息才能被consumer消费。这样就保证了如果leader所在的broker失效，该消息仍然可以从新选举的leader中获取。</p>
<h1 id="八、kafka线上问题优化"><a href="#八、kafka线上问题优化" class="headerlink" title="八、kafka线上问题优化"></a>八、kafka线上问题优化</h1><h2 id="1-如何防止消息丢失"><a href="#1-如何防止消息丢失" class="headerlink" title="1. 如何防止消息丢失"></a>1. 如何防止消息丢失</h2><ul>
<li>发送方：1）使用同步发送 2）ack是1或者-1&#x2F;all可以防止消息丢失，如果要做到99.99999%，ack设为all，把min.insync.replicas配置成分区备份数。</li>
<li>消费方：把自动提交改为手动提交。</li>
</ul>
<h2 id="2-如何防止消息的重复消费"><a href="#2-如何防止消息的重复消费" class="headerlink" title="2. 如何防止消息的重复消费"></a>2. 如何防止消息的重复消费</h2><p>在防止消息丢失的方案中，如果生产者发送消息后，因为网络抖动，没有收到ack，但实际上broker已经收到了。此时生产者会进行重试，于是broker就会收到多条相同的消息，而造成消费者的重复消费。</p>
<p>解决方案：</p>
<ul>
<li><p>生产者关闭重试机制，但是容易造成消息丢失。</p>
</li>
<li><p>消费者解决幂等性消费问题：</p>
<p>幂等性：多次访问的结果是一样的。对于rest的请求（get（幂等），post（非幂等），put（幂等），delete（幂等））</p>
<p>解决方案：</p>
<ol>
<li>在数据库中创建联合主键，防止相同的主键创建多条记录</li>
<li>使用分布式锁，以业务id为锁，保证只有一条记录能够创建成功</li>
</ol>
</li>
</ul>
<h2 id="3-如何做到顺序消费"><a href="#3-如何做到顺序消费" class="headerlink" title="3. 如何做到顺序消费"></a>3. 如何做到顺序消费</h2><ul>
<li>发送方：在发送时将ack不能设置为0，d使用同步发送，等发送成功再发送下一条。确保消息是顺序发送的。</li>
<li>接收方：消息是发送到一个分区中，只能有一个消费组的消费者来接收消息。</li>
</ul>
<p>kafka的顺序消费使用场景不多，要想实现顺序消费会牺牲掉性能，可以使用rocketMQ。</p>
<h2 id="4-消息积压"><a href="#4-消息积压" class="headerlink" title="4. 消息积压"></a>4. 消息积压</h2><h3 id="1）消息积压问题的出现"><a href="#1）消息积压问题的出现" class="headerlink" title="1）消息积压问题的出现"></a>1）消息积压问题的出现</h3><p>消息的消费者的消费速度远赶不上生产者生产消息的速度，导致kafka中有大量的数据没有被消费。随着没有被消费的数据堆积越多，消费者寻址的性能会越来越差，最后导致整个kafka对外提供服务的性能很差，从而造成其他服务的访问速度变慢，造成服务雪崩。</p>
<h3 id="2）消息积压的解决法方案"><a href="#2）消息积压的解决法方案" class="headerlink" title="2）消息积压的解决法方案"></a>2）消息积压的解决法方案</h3><ul>
<li>在这个消费者中，使用多线程，充分利用机器的性能进行消费消息。</li>
<li>创建多个消费组，多个消费者，部署到其他机器上，一起消费，提高消费者的消费速度。</li>
<li>创建一个消费者，该消费者在kafka另建一个主题，配上多个分区，多个分区再配上多个消费者。该消费者将poll下来的消息，不进行消费，直接转发到新建的主题上。此时，新的主题的多个分区的多个消费者就开始一起消费了。</li>
</ul>
<h2 id="5-实现延迟队列的效果"><a href="#5-实现延迟队列的效果" class="headerlink" title="5. 实现延迟队列的效果"></a>5. 实现延迟队列的效果</h2><h3 id="1）应用场景"><a href="#1）应用场景" class="headerlink" title="1）应用场景"></a>1）应用场景</h3><p>订单创建后，超过30分钟没有支付，则需要取消订单，这种场景可以通过延时队列来实现</p>
<h3 id="2）具体方案"><a href="#2）具体方案" class="headerlink" title="2）具体方案"></a>2）具体方案</h3><ul>
<li>kafka中创建相应的主题</li>
<li>消费者消费该主题的消息（轮询）</li>
<li>消费者消费消息时判断消息的创建时间和当前时间是否超过30分钟（前提是订单没支付）<ul>
<li>如果是：去数据库中修改订单状态为已取消</li>
<li>如果否：记录当前消息的offset，并不再继续消费之后的消息。等待一段时间后，再次想kafka拉去该offset及之后的消息，继续进行判断，以此重复。</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://cy77cc.github.io/2025/03/25/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/" data-id="cm8s98nmj0009f8lzakov0adh" data-title="各种消息队列MQ的学习记录" class="article-share-link"><span class="fa fa-share">Compartir</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-我的golang面试总结" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/03/22/%E6%88%91%E7%9A%84golang%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/" class="article-date">
  <time class="dt-published" datetime="2025-03-22T01:11:00.000Z" itemprop="datePublished">2025-03-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/03/22/%E6%88%91%E7%9A%84golang%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/">golang学习笔记</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="函数传参的问题"><a href="#函数传参的问题" class="headerlink" title="函数传参的问题"></a>函数传参的问题</h1><p>在Go语言里面所有的函数传参都是值传递，无论是值类型（int、string、struct等等）还是引用类型（map、slice）等等</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://cy77cc.github.io/2025/03/22/%E6%88%91%E7%9A%84golang%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/" data-id="cm8s98nmf0001f8lz3vf5hknn" data-title="golang学习笔记" class="article-share-link"><span class="fa fa-share">Compartir</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/golang/" rel="tag">golang</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-MySQL" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/03/20/MySQL/" class="article-date">
  <time class="dt-published" datetime="2025-03-20T12:32:00.000Z" itemprop="datePublished">2025-03-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/03/20/MySQL/">MySQL是怎样运行的读书笔记</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="一、初识MySQL"><a href="#一、初识MySQL" class="headerlink" title="一、初识MySQL"></a>一、初识MySQL</h2><h3 id="1-1-MySQL的客户端-服务端架构"><a href="#1-1-MySQL的客户端-服务端架构" class="headerlink" title="1.1 MySQL的客户端&#x2F;服务端架构"></a>1.1 MySQL的客户端&#x2F;服务端架构</h3><p>MySQL采用C&#x2F;S的架构，在客户端程序中输入语句命令，并将其作为请求发送到服务器程序。服务器程序在收到这些请求后，根据请求的内容来操作具体的数据，并将结果返回给客户的。</p>
<h3 id="1-2-启动MySQL服务器程序"><a href="#1-2-启动MySQL服务器程序" class="headerlink" title="1.2 启动MySQL服务器程序"></a>1.2 启动MySQL服务器程序</h3><h4 id="1-2-1-MySQL的启动服务程序"><a href="#1-2-1-MySQL的启动服务程序" class="headerlink" title="1.2.1 MySQL的启动服务程序"></a>1.2.1 MySQL的启动服务程序</h4><ol>
<li>mysqld</li>
<li>mysqld_safe：mysqld_safe是一个启动脚本会间接调用mysqld，并监测mysql服务器的运行状态。当mysql服务器发送错误时，可以帮助重启服务器程序。在启动MySQL服务器程序时，它会将服务器程序的出错信息和其他诊断信息输出到错误日志。</li>
<li>mysql.server：也是一个启动脚本，会间接调用mysqld_safe。</li>
<li>mysqld_multi：可以在一台计算机上启动多个服务器程序。</li>
</ol>
<h4 id="1-2-2-windows启动MySQL服务"><a href="#1-2-2-windows启动MySQL服务" class="headerlink" title="1.2.2 windows启动MySQL服务"></a>1.2.2 windows启动MySQL服务</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">net <span class="built_in">start</span> MySQL   <span class="comment">#需要管理员权限</span></span><br><span class="line">net stop MySQL</span><br></pre></td></tr></table></figure>

<h3 id="1-3-启动MySQL客户端程序"><a href="#1-3-启动MySQL客户端程序" class="headerlink" title="1.3 启动MySQL客户端程序"></a>1.3 启动MySQL客户端程序</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql <span class="literal">-h</span> <span class="literal">-p</span> <span class="literal">-P</span> <span class="literal">-e</span></span><br><span class="line"><span class="literal">-h</span> 指定连接的地址</span><br><span class="line"><span class="literal">-p</span> 密码</span><br><span class="line"><span class="literal">-P</span> 连接的端口</span><br><span class="line"><span class="literal">-e</span> 执行MySQL语句</span><br><span class="line"><span class="literal">-u</span> 连接的用户</span><br></pre></td></tr></table></figure>

<h3 id="1-4-客户端与服务器连接的过程"><a href="#1-4-客户端与服务器连接的过程" class="headerlink" title="1.4 客户端与服务器连接的过程"></a>1.4 客户端与服务器连接的过程</h3><p>客户端进程向服务器进程发送请求并得到相应的过程本质上是一个进程间通信的过程。MySQL支持下面集中客户端进程和服务器进程的通信方式。</p>
<ol>
<li>TCP&#x2F;IP</li>
</ol>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql <span class="literal">-u</span> root <span class="literal">-p</span> <span class="literal">-h</span> <span class="number">127.0</span>.<span class="number">0.1</span> <span class="literal">-P</span> <span class="number">3306</span></span><br><span class="line">连接到本地的<span class="number">3306</span>端口，指定用户为root</span><br></pre></td></tr></table></figure>
<ol start="2">
<li><p>命令管道和共享内存</p>
<ul>
<li><p>使用命名管道进行进程间通信：需要在启动服务器程序的命令中加上–enable-named-pipe参数，然后在启动客户端程序的命令中加上–pipe或者–protocol&#x3D;pipe参数。</p>
</li>
<li><p>使用共享内存进行进程间通信：需要在启动服务器程序的命令中加上–shared-memory参数。在启动客户端程序的命令加上–protocol&#x3D;memory参数。</p>
</li>
</ul>
</li>
<li><p>unix套接字</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql <span class="literal">-h</span> localhost <span class="literal">-u</span> root <span class="literal">--socket</span>=/tmp/mysql.sock</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="1-5-服务器处理客户端请求"><a href="#1-5-服务器处理客户端请求" class="headerlink" title="1.5 服务器处理客户端请求"></a>1.5 服务器处理客户端请求</h3><ol>
<li>连接管理</li>
<li>解析与优化<ol>
<li>查询缓存</li>
<li>语法解析</li>
<li>查询优化</li>
</ol>
</li>
<li>存储引擎</li>
</ol>
<h3 id="1-6-常用存储引擎"><a href="#1-6-常用存储引擎" class="headerlink" title="1.6 常用存储引擎"></a>1.6 常用存储引擎</h3><table>
<thead>
<tr>
<th>存储引擎</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>ARCHIVE</td>
<td>用户数据存档（记录插入后不能再修改）</td>
</tr>
<tr>
<td>BLACKHOLE</td>
<td>丢弃写操作，读操作会返回空内容</td>
</tr>
<tr>
<td>CSV</td>
<td>在存储数据时，以逗号分隔各个数据项</td>
</tr>
<tr>
<td>FEDERATED</td>
<td>用来访问远程表</td>
</tr>
<tr>
<td>InnoDB</td>
<td>支持事务、行级锁、外键</td>
</tr>
<tr>
<td>MEMORY</td>
<td>数据只存储在内存，不存储在磁盘；多用于临时表</td>
</tr>
<tr>
<td>MERGE</td>
<td>用来管理多个MyISAM表构成的表集合</td>
</tr>
<tr>
<td>MyISAM</td>
<td>主要的非事务处理存储引擎</td>
</tr>
<tr>
<td>NDB</td>
<td>MySQL集群专用存储引擎</td>
</tr>
</tbody></table>
<h2 id="二、启动选项和系统变量"><a href="#二、启动选项和系统变量" class="headerlink" title="二、启动选项和系统变量"></a>二、启动选项和系统变量</h2><p><img src="https://raw.githubusercontent.com/cy77cc/pic-md/master/image-20250405105945819.png" alt="image-20250405105945819"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://cy77cc.github.io/2025/03/20/MySQL/" data-id="cm8hdw72n0000bclzf1450hbi" data-title="MySQL是怎样运行的读书笔记" class="article-share-link"><span class="fa fa-share">Compartir</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="tag">数据库</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-redis" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/03/20/redis/" class="article-date">
  <time class="dt-published" datetime="2025-03-20T12:16:00.000Z" itemprop="datePublished">2025-03-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/03/20/redis/">Redis</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="什么是Redis，Redis有哪些特点"><a href="#什么是Redis，Redis有哪些特点" class="headerlink" title="什么是Redis，Redis有哪些特点"></a>什么是Redis，Redis有哪些特点</h2><p>Redis全程为：Remote Dictionary Server（远程数据服务），Redis是一种支持key-value等多种数据结构的存储系统。可用于缓存，时间发布订阅或高速队列等场景。支持网络，提供string，hash，list，queue，set等数据结构直接存取，基于内存，可持久化。</p>
<h2 id="一、常用类型"><a href="#一、常用类型" class="headerlink" title="一、常用类型"></a>一、常用类型</h2><h3 id="String字符串"><a href="#String字符串" class="headerlink" title="String字符串"></a>String字符串</h3><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><p>存用户token，session id等信息都行，太多了。</p>
<h4 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h4><table>
<thead>
<tr>
<th>命令</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>set key value</td>
<td>设置一个key value</td>
</tr>
<tr>
<td>mset key value key value</td>
<td>同时设置多个key value</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<h3 id="List列表"><a href="#List列表" class="headerlink" title="List列表"></a>List列表</h3><h4 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h4><p>可以当简单的消息队列用</p>
<h4 id="常用命令-1"><a href="#常用命令-1" class="headerlink" title="常用命令"></a>常用命令</h4><table>
<thead>
<tr>
<th>命令</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>lpush key value</td>
<td>从左边向key插入一个数据</td>
</tr>
<tr>
<td>rpush key value</td>
<td>从右边向key插入一个数据</td>
</tr>
<tr>
<td>lpop key</td>
<td>从左边弹出一个数据</td>
</tr>
<tr>
<td>rpop key</td>
<td>从右边弹出一个数据</td>
</tr>
<tr>
<td>lrange key start end</td>
<td>从start开始遍历list到end</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<h3 id="Set集合"><a href="#Set集合" class="headerlink" title="Set集合"></a>Set集合</h3><h4 id="使用场景-2"><a href="#使用场景-2" class="headerlink" title="使用场景"></a>使用场景</h4><p>去重，用户共同好友，需要求交集，并集等这些场景。</p>
<h3 id="ZSet有序集合"><a href="#ZSet有序集合" class="headerlink" title="ZSet有序集合"></a>ZSet有序集合</h3><h4 id="使用场景-3"><a href="#使用场景-3" class="headerlink" title="使用场景"></a>使用场景</h4><p>游戏排行榜</p>
<h3 id="Hash哈希表"><a href="#Hash哈希表" class="headerlink" title="Hash哈希表"></a>Hash哈希表</h3><h4 id="使用场景-4"><a href="#使用场景-4" class="headerlink" title="使用场景"></a>使用场景</h4><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>hgetall 如果字段太多的话会阻塞。</p>
<h3 id="Bitmap位图"><a href="#Bitmap位图" class="headerlink" title="Bitmap位图"></a>Bitmap位图</h3><h4 id="使用场景-5"><a href="#使用场景-5" class="headerlink" title="使用场景"></a>使用场景</h4><p>统计用户登陆，布隆过滤器，统计活跃用户量</p>
<h3 id="Stream流"><a href="#Stream流" class="headerlink" title="Stream流"></a>Stream流</h3><h4 id="使用场景-6"><a href="#使用场景-6" class="headerlink" title="使用场景"></a>使用场景</h4><p>消息队列，官方也是想实现成消息队列</p>
<h2 id="二、持久化方案"><a href="#二、持久化方案" class="headerlink" title="二、持久化方案"></a>二、持久化方案</h2><h3 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h3><h3 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h3><h2 id="三、主从集群"><a href="#三、主从集群" class="headerlink" title="三、主从集群"></a>三、主从集群</h2><p>从节点从主节点复制数据，复制主节点的RDB文件，实现数据的复制。</p>
<h2 id="四、哨兵"><a href="#四、哨兵" class="headerlink" title="四、哨兵"></a>四、哨兵</h2><p>在集群的方案中，如果是从节点挂了那对集群影响也不大，如果主节点挂了那就凉凉，那么这个集群就相当于废了。因为一般来说主从方式时，都是主节点用来写数据，从节点读数据。如果主节点挂了，从节点也不知道从哪里复制备份数据。一般是一主两从。</p>
<h2 id="五、缓存三件套"><a href="#五、缓存三件套" class="headerlink" title="五、缓存三件套"></a>五、缓存三件套</h2><h3 id="1、缓存穿透"><a href="#1、缓存穿透" class="headerlink" title="1、缓存穿透"></a>1、缓存穿透</h3><p>缓存穿透是指要访问的数据既不在缓存中，也不在数据库中，导致请求在访问缓存时，发生缓存缺失，访问数据库时，发现数据库中也没有要访问的数据。这时就无法从数据库中加载数据到缓存中，后续的请求会一直按照访问缓存，访问数据库的流程访问这个不存在的数据，给缓存和数据库带来了很大的压力。</p>
<h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><ul>
<li>使用布隆过滤器判断数据是否存在，布隆过滤器的原理是将key通过hash的方式映射到位图上。如果一个key存在，布隆过滤器不能保证正确判断一个key一定存在，但是可以保存判断不存在的key一定不存在。</li>
<li>缓存空值，当缓存和数据库都不存在时，直接缓存一个空值到缓存中，过期时间设置短一些。</li>
</ul>
<h3 id="2、缓存击穿"><a href="#2、缓存击穿" class="headerlink" title="2、缓存击穿"></a>2、缓存击穿</h3><p>缓存击穿是指一个key过期了，但是却有大量的请求访问这个key。因此，这个时候所有的访问都会打到数据库上，导致数据库压力过大。</p>
<h4 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h4><ul>
<li>每次访问key时，如果key存在给key续约一段时间。</li>
<li>Go语言里面的singleflight。singleflight的原理是当同时有很多请求同时到达时，最终只有一个请求会最终访问到资源，其他请求都会等待结果然后返回。</li>
<li>加锁访问。cache miss 后请求DB之前必须先获取分布式锁，取锁失败说明是有其他请求在查询DB了，当前请求只需要循环等待并查询Redis检测取锁成功的请求把数据回写到Redis没有，如果有的话当前请求就可以直接从缓存中取数据返回了。</li>
</ul>
<h3 id="3、缓存雪崩"><a href="#3、缓存雪崩" class="headerlink" title="3、缓存雪崩"></a>3、缓存雪崩</h3><p>缓存雪崩时指大量的的应用请求无法在Redis缓存中进行处理，紧接着应用将大量的请求发送到数据库，导致数据库被打挂，好惨呐！！缓存雪崩一般是由两个原因导致的，应对方案也不太一样。</p>
<h4 id="1-大量缓存数据同时过期"><a href="#1-大量缓存数据同时过期" class="headerlink" title="1. 大量缓存数据同时过期"></a>1. 大量缓存数据同时过期</h4><p>​	在固定的过期时间上加一个随机过期时间</p>
<h4 id="2-缓存服务器挂了"><a href="#2-缓存服务器挂了" class="headerlink" title="2. 缓存服务器挂了"></a>2. 缓存服务器挂了</h4><p>​	熔断，保护数据库。</p>
<h2 id="六、缓存一致性"><a href="#六、缓存一致性" class="headerlink" title="六、缓存一致性"></a>六、缓存一致性</h2><p><img src="https://raw.githubusercontent.com/cy77cc/pic-md/master/image-20250331104253859.png" alt="image-20250331104253859"></p>
<p>缓存一致性是加入缓存后需要解决的一个重要问题，最核心的就是保证缓存和数据库的数据是一致的。主要存在的情况是在数据更新和删除的过程中，怎么保证数据库和缓存都是更新或删除的数据。</p>
<ul>
<li>更新：1）如果先更新缓存再更新数据库，高并发的情况下会存在缓存不一致的情况。例如，如果缓存更新后，数据库还没来得及更新或者更新失败，请求就来了，这时会从缓存中取到脏数据。2）如果先更新数据库再更新缓存，那么请求会从缓存中拿到还没更新的数据。</li>
<li>删除：1）先删除缓存后删除数据库，一般情况没问题。2）先删除数据库再删除缓存，会出现数据库已经删了，缓存还没来得及删除就有请求来了。</li>
</ul>
<h3 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案"></a>解决方案</h3><ul>
<li>无论是更新还是删除，都先删除缓存再更新删除数据库。删除缓存后更新数据库可以保证只需要考虑数据库能否正常更新删除。在下一次请求来时将数据加载到缓存中，可以保证缓存和数据库的数据是一致的。也可以使用canal监听数据库的变化，将变化的数据通过消息队列异步更新到缓存中。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://cy77cc.github.io/2025/03/20/redis/" data-id="cm8hdw72q0001bclz3lof6820" data-title="Redis" class="article-share-link"><span class="fa fa-share">Compartir</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="tag">数据库</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Siguiente &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/docker/" rel="tag">docker</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/go/" rel="tag">go</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/golang/" rel="tag">golang</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mq/" rel="tag">mq</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/nginx/" rel="tag">nginx</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/tool/" rel="tag">tool</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6-docker-kubernetes/" rel="tag">中间件,docker,kubernetes</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F/" rel="tag">分布式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="tag">数据库</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Nube de Tags</h3>
    <div class="widget tagcloud">
      <a href="/tags/docker/" style="font-size: 10px;">docker</a> <a href="/tags/go/" style="font-size: 10px;">go</a> <a href="/tags/golang/" style="font-size: 20px;">golang</a> <a href="/tags/mq/" style="font-size: 10px;">mq</a> <a href="/tags/nginx/" style="font-size: 10px;">nginx</a> <a href="/tags/tool/" style="font-size: 10px;">tool</a> <a href="/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6-docker-kubernetes/" style="font-size: 10px;">中间件,docker,kubernetes</a> <a href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F/" style="font-size: 10px;">分布式</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" style="font-size: 20px;">数据库</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archivos</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/04/">April 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/03/">March 2025</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Posts recientes</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2025/04/06/Kubernetes%EF%BC%88k8s%EF%BC%89/">k8s学习记录</a>
          </li>
        
          <li>
            <a href="/2025/04/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">Go设计模式</a>
          </li>
        
          <li>
            <a href="/2025/04/04/nginx/">Nginx</a>
          </li>
        
          <li>
            <a href="/2025/04/04/Git/">Git</a>
          </li>
        
          <li>
            <a href="/2025/04/04/docker/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2025 Mr. Zhang<br>
      Construido por <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>