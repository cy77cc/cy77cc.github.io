<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>cy77cc</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="cy77cc">
<meta property="og:url" content="https://cy77cc.github.io/index.html">
<meta property="og:site_name" content="cy77cc">
<meta property="og:locale">
<meta property="article:author" content="Mr. Zhang">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="cy77cc" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/fork-awesome@1.2.0/css/fork-awesome.min.css">

<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">cy77cc</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Suche"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Suche"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://cy77cc.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-分布式事务" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/03/20/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/" class="article-date">
  <time class="dt-published" datetime="2025-03-20T06:59:07.754Z" itemprop="datePublished">2025-03-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="分布式事务学习笔记"><a href="#分布式事务学习笔记" class="headerlink" title="分布式事务学习笔记"></a>分布式事务学习笔记</h1><p>分布式事务就和名字一样是在分布式的情况下需要考虑的。</p>
<h2 id="一、MySQL的事务"><a href="#一、MySQL的事务" class="headerlink" title="一、MySQL的事务"></a>一、MySQL的事务</h2><p>把多条语句作为一个整体进行操作的功能，被称为数据库事务。数据库事务可以确保该事务范围内的所有操作都可以全部成功或者全部失败。</p>
<p>MySQL事务支持ACID，原子性，持久性，一致性，隔离行四个特性，其中原子性能保证事务内所有执行都完整完成，不存在部分完成的情况，一致性指事务执行前后不会改变数据库的状态，持久性指能够一直保存（简单地说就是保存在磁盘上不会丢，除非你把磁盘烧了），隔离性指每个事务之间不会相互影响。</p>
<h2 id="二、分布式理论"><a href="#二、分布式理论" class="headerlink" title="二、分布式理论"></a>二、分布式理论</h2><h3 id="2-1-CAP理论"><a href="#2-1-CAP理论" class="headerlink" title="2.1 CAP理论"></a>2.1 CAP理论</h3><p>C（一致性）指的是分布式系统中从多副本读取数据时的一致性。分强一致性、弱一致性和最终一致性。</p>
<p>A（可用性）保证每个请求不管成功或者失败都有响应。</p>
<p>P（分区容错性）分区容忍性是分布式系统中必须实现的（高可用），一个节点挂了不能导致服务也挂了。</p>
<p>不存在CAP都满足的，最多CP+HA  高可用。</p>
<h3 id="2-2-BASE理论"><a href="#2-2-BASE理论" class="headerlink" title="2.2 BASE理论"></a>2.2 BASE理论</h3><p>Basically Available(基本可用)</p>
<p>Soft state（软状态）</p>
<p>Eventually consistent（最终一致性）</p>
<h2 id="三、分布式事务"><a href="#三、分布式事务" class="headerlink" title="三、分布式事务"></a>三、分布式事务</h2><p>分布式事务指事务的发起者、资源及资源管理器和事务协调者分别位于分布式系统的不同节点之上（同时写、修改多个数据库），微服务里面是一个操作需要同时修改不同服务内的数据，例如一个订单的微服务在创建时需要减掉相应商品的库存，这时候如果先创建订单，然后再减掉商品库存就会导致常见的超卖现象。还有一种情况可能是，订单创建了，商品这个微服务挂了，然后库存没减掉。这些现象在分布式的情况中需要注意。</p>
<h3 id="3-1-两阶段提交-XA"><a href="#3-1-两阶段提交-XA" class="headerlink" title="3.1 两阶段提交&#x2F;XA"></a>3.1 两阶段提交&#x2F;XA</h3><p>XA是由X&#x2F;Open组织提出的分布式事务的规范，XA规范主要定义了(全局)事务管理器(TM)和(局部)资源管理器(RM)之间的接口。本地的数据库如mysql在XA中扮演的是RM角色</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">xa start &#x27;xxx&#x27;</span><br><span class="line">CRUD</span><br><span class="line">xa end &#x27;xxx&#x27;</span><br><span class="line">xa prepare &#x27;xxx&#x27;   # 如果这个数据库和全局事务管理器断开了就会自动回滚</span><br><span class="line">xa commit &#x27;xxx&#x27; # 所有参与者都完成了prepare，就进入提交</span><br></pre></td></tr></table></figure>

<p><img src="https://dtm.pub/assets/xa_normal.5a0ce600.jpg" alt="xa_normal"></p>
<p>图片来源DTM（<a target="_blank" rel="noopener" href="https://dtm.pub/%EF%BC%89">https://dtm.pub/）</a></p>
<p>XA一共分为两个阶段：</p>
<p>第一阶段准备：所有的参与者RM准备执行事务并锁住需要的资源。参与者ready时，向TM报告已准备就绪。</p>
<p>第二阶段（commit&#x2F;rollback）：当TM确认所有参与RM都ready后，向所有参与RM发送commit命令。</p>
<p>XA事务的特点是：</p>
<ul>
<li>简单易理解，开发较容易。</li>
<li>对资源进行长时间的锁定，影响系统的并发。</li>
</ul>
<h3 id="3-2-SAGA"><a href="#3-2-SAGA" class="headerlink" title="3.2 SAGA"></a>3.2 SAGA</h3><p>核心思想是将长事务拆分为多个本地事务，由Saga事务协调器协调，如果正常结束那就正常完成，如果某个步骤失败，则根据相反顺序一次调用补偿操作（类似undo log）</p>
<p><img src="https://dtm.pub/assets/saga_normal.a2849672.jpg" alt="saga_normal"></p>
<p>图片来源DTM（<a target="_blank" rel="noopener" href="https://dtm.pub/%EF%BC%89">https://dtm.pub/）</a></p>
<p><strong>Saga事务的特点：</strong></p>
<ul>
<li>并发度高，不用像XA事务一样长时间锁住资源。</li>
<li>需要定义正常操作以及补偿操作，开发量更大了（写undo log，double的业务逻辑）。</li>
<li>一致性较弱，对于转账，可能发生用户A已扣款，最后转账又失败的情况。</li>
</ul>
<h3 id="3-3-TCC"><a href="#3-3-TCC" class="headerlink" title="3.3 TCC"></a>3.3 TCC</h3><p>TCC(Try-Confirm-Cancel)，TCC分为3个阶段：</p>
<ul>
<li>Try阶段：尝试执行，完成所有业务检查（一致性），预留必须的业务资源（准隔离性）。</li>
<li>Confirm阶段：确认执行真正执行业务，不作任何业务检查，只是用Try阶段预留的业务资源，Confirm操作要求具备幂等设计，Confirm失败后需要进行重试。</li>
<li>Cancel阶段：取消执行，释放Try阶段预留的业务资源。Cancel阶段的异常和Confirm阶段异常处理方案基本一致，要求满足幂等设计。</li>
</ul>
<p><img src="https://dtm.pub/assets/tcc_normal.dea14fb3.jpg" alt="tcc_normal"></p>
<p>图片来源DTM（<a target="_blank" rel="noopener" href="https://dtm.pub/%EF%BC%89">https://dtm.pub/）</a></p>
<p>TCC的Confirm&#x2F;Cancel阶段在业务逻辑上是不允许返回失败的，如果因为网络或者其他临时故障，导致不能返回成功，TM会不断的重试，直到Confirm&#x2F;Cancel返回成功。</p>
<p>TCC特点如下：</p>
<ul>
<li>并发度高，无长期资源锁定。</li>
<li>开发量较大，需要提供Try、Confirm、Cancel接口。</li>
<li>一致性较好，不会发生SAGA已扣款最后有家转账失败的情况。</li>
<li>TCC适用于订单类业务，对中间状态有约束的业务。</li>
</ul>
<h3 id="3-4-本地消息表"><a href="#3-4-本地消息表" class="headerlink" title="3.4 本地消息表"></a>3.4 本地消息表</h3><p><img src="https://dtm.pub/assets/local_msg_table.089f1fd3.jpg" alt="local_msg_table"></p>
<p>图片来源DTM（<a target="_blank" rel="noopener" href="https://dtm.pub/%EF%BC%89">https://dtm.pub/）</a></p>
<p>写本地消息和业务操作放在一个事务里，保证了业务和发消息的原子性，要么他们全都成功，要么全都失败。</p>
<p>容错机制：</p>
<ul>
<li>扣减余额失败时，事务直接回滚，无后续步骤。</li>
<li>轮询生成消息失败，增加余额事务失败都会进行重试。</li>
</ul>
<p>本地消息表的特点：</p>
<ul>
<li>长事务仅需分成多个任务，使用简单。</li>
<li>生产者需要额外的创建消息表。</li>
<li>不支持回滚。</li>
<li>轮询生产消息难实现，如果定时轮询会延长事务总时长，如果订阅binlog则开发维护困难。</li>
</ul>
<h3 id="3-5-事务消息"><a href="#3-5-事务消息" class="headerlink" title="3.5 事务消息"></a>3.5 事务消息</h3><p>事务消息发送及提交：</p>
<ul>
<li>发送消息（half消息）。</li>
<li>服务端存储消息，并响应消息写入结果。</li>
<li>根据发送结果执行本地事务（如果写入失败，此时half消息对业务不可见，本地逻辑不执行）。</li>
<li>根据本地事务状态执行Commit或者Rollback（Commit操作发布消息，消息对消费者可见）。</li>
</ul>
<p>​	</p>
<h3 id="3-6-最大努力通知"><a href="#3-6-最大努力通知" class="headerlink" title="3.6 最大努力通知"></a>3.6 最大努力通知</h3><p>最大努力通知适用于业务通知类型，例如微信交易的结果，就是通过最大努力通知方式通知各个商户，既有回调通知，也有交易查询接口。</p>
<h3 id="3-7-AT事务模型"><a href="#3-7-AT事务模型" class="headerlink" title="3.7 AT事务模型"></a>3.7 AT事务模型</h3><p>优点是该事务模式使用方式，类似XA模式，业务无需编写各类补偿操作，回滚由框架自动完成，该模式缺点也较多，一方面类似XA，存在较长时间的锁，不满足高并发的场景；另一方面存在脏回滚之类的问题，容易引发数据不一致。</p>
<h2 id="四、分布式事务的新方案"><a href="#四、分布式事务的新方案" class="headerlink" title="四、分布式事务的新方案"></a>四、分布式事务的新方案</h2><h3 id="二阶段消息-DTM"><a href="#二阶段消息-DTM" class="headerlink" title="二阶段消息(DTM)"></a>二阶段消息(DTM)</h3><p><img src="https://segmentfault.com/img/bVcXBhX/view" alt="preview"></p>
<p>图片来源DTM（<a target="_blank" rel="noopener" href="https://dtm.pub/%EF%BC%89">https://dtm.pub/）</a></p>
<h2 id="五、异常处理"><a href="#五、异常处理" class="headerlink" title="五、异常处理"></a>五、异常处理</h2>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://cy77cc.github.io/2025/03/20/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/" data-id="cm8ha8omz0000u8lz2g75blj1" data-title="" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Golang" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/03/19/Golang/" class="article-date">
  <time class="dt-published" datetime="2025-03-19T06:12:11.000Z" itemprop="datePublished">2025-03-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/03/19/Golang/">golang学习笔记</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="Go语言"><a href="#Go语言" class="headerlink" title="Go语言"></a><strong>Go语言</strong></h1><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><p>go build指令将go源码文件编译成可执行文件(.exe)</p>
<p>go run指令直接执行go文件</p>
<p>两种执行流程的方式区别</p>
<ol>
<li><p>如果我们先编译成了可执行文件，那么我们可以将可执行文件拷贝到没有go开发环境的机器上，仍然可运行</p>
</li>
<li><p>如果我们直接go run go源码，那么如果要在另外一个机器上可以运行，也需要go开发环境，否则无法执行</p>
</li>
<li><p>在编译时，编译器会将程序运行依赖的库文件包含在可执行文件中，所以，可执行文件变大了很多</p>
</li>
</ol>
<p>指定生成可执行文件的名称</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> build -o myHello.exe hello.<span class="keyword">go</span>   指定生成的可执行文件名为myHello</span><br></pre></td></tr></table></figure>

<p>如果程序没有错误，没有任何提示</p>
<p>如果程序有错，编译时，会在错误的那行报错</p>
<h2 id="Go-module"><a href="#Go-module" class="headerlink" title="Go module"></a>Go module</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">开启go module</span><br><span class="line">go env <span class="literal">-w</span> GO111MODULE=on</span><br><span class="line"></span><br><span class="line">设置代理</span><br><span class="line">go env <span class="literal">-w</span> GOPROXY=https://goproxy.cn,direct</span><br><span class="line"></span><br><span class="line">初始化项目</span><br><span class="line">go mod init test(test为项目名)</span><br><span class="line"></span><br><span class="line">检测依赖</span><br><span class="line">go mod tidy</span><br><span class="line"></span><br><span class="line">下载依赖包</span><br><span class="line">go mod download</span><br><span class="line"></span><br><span class="line">导入依赖</span><br><span class="line">go mod vendor</span><br><span class="line"></span><br><span class="line">常用命令</span><br><span class="line">go mod init  <span class="comment"># 初始化go.mod</span></span><br><span class="line">go mod tidy  <span class="comment"># 更新依赖文件</span></span><br><span class="line">go mod download  <span class="comment"># 下载依赖文件</span></span><br><span class="line">go mod vendor  <span class="comment"># 将依赖转移至本地的vendor文件</span></span><br><span class="line">go mod edit  <span class="comment"># 手动修改依赖文件</span></span><br><span class="line">go mod graph  <span class="comment"># 打印依赖图</span></span><br><span class="line">go mod verify  <span class="comment"># 校验依赖</span></span><br></pre></td></tr></table></figure>

<p>go.mod文件</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">module test</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="number">1.13</span></span><br><span class="line"></span><br><span class="line">require (</span><br><span class="line">    github.com/gin-contrib/sessions v0<span class="number">.0</span><span class="number">.1</span></span><br><span class="line">    github.com/gin-contrib/sse v0<span class="number">.1</span><span class="number">.0</span> <span class="comment">// indirect</span></span><br><span class="line">    github.com/gin-gonic/gin v1<span class="number">.4</span><span class="number">.0</span></span><br><span class="line">    github.com/<span class="keyword">go</span>-redis/redis v6<span class="number">.15</span><span class="number">.6</span>+incompatible</span><br><span class="line">    github.com/<span class="keyword">go</span>-sql-driver/mysql v1<span class="number">.4</span><span class="number">.1</span></span><br><span class="line">    github.com/golang/protobuf v1<span class="number">.3</span><span class="number">.2</span> <span class="comment">// indirect</span></span><br><span class="line">    github.com/jinzhu/gorm v1<span class="number">.9</span><span class="number">.11</span></span><br><span class="line">    github.com/json-iterator/<span class="keyword">go</span> v1<span class="number">.1</span><span class="number">.7</span> <span class="comment">// indirect</span></span><br><span class="line">    github.com/kr/pretty v0<span class="number">.1</span><span class="number">.0</span> <span class="comment">// indirect</span></span><br><span class="line">    github.com/mattn/<span class="keyword">go</span>-isatty v0<span class="number">.0</span><span class="number">.10</span> <span class="comment">// indirect</span></span><br><span class="line">    github.com/sirupsen/logrus v1<span class="number">.2</span><span class="number">.0</span></span><br><span class="line">    github.com/ugorji/<span class="keyword">go</span> v1<span class="number">.1</span><span class="number">.7</span> <span class="comment">// indirect</span></span><br><span class="line">    golang.org/x/sys v0<span class="number">.0</span><span class="number">.0</span><span class="number">-20191025021431</span><span class="number">-6</span>c3a3bfe00ae <span class="comment">// indirect</span></span><br><span class="line">    gopkg.in/yaml.v2 v2<span class="number">.2</span><span class="number">.4</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>



<h2 id="常见转义字符"><a href="#常见转义字符" class="headerlink" title="常见转义字符"></a>常见转义字符</h2><table>
<thead>
<tr>
<th>escape char</th>
<th>表示的意思</th>
</tr>
</thead>
<tbody><tr>
<td>\t</td>
<td>一个制表符，实现对齐的功能</td>
</tr>
<tr>
<td>\n</td>
<td>换行符</td>
</tr>
<tr>
<td>\\</td>
<td>一个\</td>
</tr>
<tr>
<td>&quot;</td>
<td>一个”</td>
</tr>
<tr>
<td>\r</td>
<td>一个回车，从当前行的最前面开始输出，覆盖掉以前的内容</td>
</tr>
</tbody></table>
<p>gofmt -w main.go该指令可以将格式化后的内容重写到文件</p>
<p>go test -v 测试</p>
<p>一行最多80个字符</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main   包名必须的 </span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span>    引入这个包 这个包实现输入输出 i/o流 </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;     </span><br><span class="line">    main函数 最先执行的函数 如果有init()函数就先执行init()   </span><br><span class="line">    fmt.Println(<span class="string">&quot;hello world&quot;</span>) 换行输出    </span><br><span class="line">    fmt.Print(<span class="string">&quot;hello world&quot;</span>)  不换行输出 </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>go语言结尾不需要分号 如果多条语句写在同一行就要使用分号分隔</p>
<h2 id="进制"><a href="#进制" class="headerlink" title="进制"></a>进制</h2><p>对于整数，有四种表示方式</p>
<ol>
<li><p>二进制：0，1，满2进1</p>
<p> ​    在Golang，不能直接使用二进制来表示一个整数</p>
</li>
<li><p>十进制：0-9，满10进1</p>
</li>
<li><p>八进制：0-7，满8进1，以数字0开头表示</p>
</li>
<li><p>十六进制：0-9和A-F，满16进1，以0x开头</p>
<p> ​    A-F不区分大小写，0x也不区分大小写</p>
</li>
</ol>
<h3 id="进制的转换"><a href="#进制的转换" class="headerlink" title="进制的转换"></a>进制的转换</h3><ol>
<li><p>其他进制转十进制de</p>
</li>
<li><p>二进制转十进制</p>
<p>​    每一位乘以2的(n - 1)次方</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">二进制数101</span><br><span class="line">1 * 2的二次方 + 0 * 2的一次方 + 1 * 2的零次方</span><br></pre></td></tr></table></figure>
</li>
<li><p>八进制转十进制</p>
<p>​    每一位乘以8的(n - 1)次方</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">八进制数101</span><br><span class="line">1 * 8的二次方 + 0 * 8的一次方 + 1 * 8的零次方</span><br></pre></td></tr></table></figure>
</li>
<li><p>十六进制转十进制</p>
<p>​    每一位乘以16的(n - 1)次方</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">十六进制数101</span><br><span class="line">1 * 16的二次方 + 0 * 16的一次方 + 1 * 16的零次方</span><br></pre></td></tr></table></figure>
</li>
<li><p>十进制转其他进制</p>
<pre><code>1. 十进制转二进制
</code></pre>
<p>​    将该数不断除以2，直到商为0为止，然后将每步得到的余数倒过来，就是对应的二进制</p>
<ol start="2">
<li>十进制转八进制</li>
</ol>
<p>​    将该数不断除以8，直到商为0为止，然后将每步得到的余数倒过来，就是对应的二进制</p>
<ol start="3">
<li>十进制转十六进制</li>
</ol>
<p>​    将该数不断除以16，直到商为0为止，然后将每步得到的余数倒过来，就是对应的二进制</p>
</li>
<li><p>二进制转其他进制</p>
<pre><code>1. 二进制转八进制
</code></pre>
<p>将二进制数的每三位为一组(从低位开始组合)，转成对应的八进制数即可</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">二进制数11010101</span><br><span class="line">11 010 101 对应的数是 3 2 5</span><br><span class="line">所以对应的八进制数是 0325</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>二进制转十六进制</li>
</ol>
<p>将二进制数的每四位为一组(从低位开始组合)，转成对应的十六进制数即可</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">二进制数11010101</span><br><span class="line">1101 0101 对应的数是 D 5</span><br><span class="line">所以对应的八进制数是 0xD5</span><br></pre></td></tr></table></figure>
</li>
<li><p>二进制转其他进制</p>
<ol>
<li>八进制转二进制</li>
</ol>
<p>将八进制数的每1位，转成一个对应的3位的二进制数即可</p>
<ol start="2">
<li>十六进制转二进制</li>
</ol>
<p>将十六进制数的每1位，转成一个对应的4位的二进制数即可</p>
</li>
<li><p>十进制小数和二进制小数互转</p>
<pre><code>1. 十进制转二进制

      <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0.125 * 2 = 0.25   0</span><br><span class="line">0.25 * 2 = 0.5     0</span><br><span class="line">0.5 * 2 = 1        1</span><br><span class="line">所以0.125转换成二进制为0.001</span><br></pre></td></tr></table></figure>

2. 二进制转十进制

      每一位一次乘以2的n次方

      <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0.001</span><br><span class="line">第一位 0 * 2 的 -1 次方</span><br><span class="line">第二位 0 * 2 的 -2 次方</span><br><span class="line">第三位 0 * 2 的 -3 次方</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ol>
<h3 id="原码，反码，补码"><a href="#原码，反码，补码" class="headerlink" title="原码，反码，补码"></a>原码，反码，补码</h3><p>对于有符号的而言</p>
<ol>
<li><p>二进制的最高位是符号位：0表示正数，1表示负数</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> 的二进制表示 <span class="number">0000</span> <span class="number">0001</span> 		</span><br><span class="line"><span class="number">-1</span> 的二进制表示 <span class="number">1000</span> <span class="number">0001</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>正数的原码，反码，补码都一样</p>
</li>
<li><p>负数的反码&#x3D;它的原码符号位不变，其他位取反(1 -&gt; 0, 0 -&gt; 1)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 的原码 0000 0001 反码 0000 0001 补码 0000 0001</span><br><span class="line">-1 的原码 1000 0001 反码 1111 1110 补码 1111 1111</span><br></pre></td></tr></table></figure>
</li>
<li><p>负数的补码&#x3D;它的反码+1</p>
</li>
<li><p>0的反码，补码都是0</p>
</li>
<li><p>在计算机运算的时候，都是以补码的形式来运行的</p>
</li>
</ol>
<h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a><strong>关键字</strong></h2><p>下面列举了 Go 代码中会使用到的 25 个关键字或保留字：</p>
<table>
<thead>
<tr>
<th>break</th>
<th>default</th>
<th>func</th>
<th>interface</th>
<th>select</th>
</tr>
</thead>
<tbody><tr>
<td>case</td>
<td>defer</td>
<td>go</td>
<td>map</td>
<td>struct</td>
</tr>
<tr>
<td>chan</td>
<td>else</td>
<td>goto</td>
<td>package</td>
<td>switch</td>
</tr>
<tr>
<td>const</td>
<td>fallthrough</td>
<td>if</td>
<td>range</td>
<td>type</td>
</tr>
<tr>
<td>continue</td>
<td>for</td>
<td>import</td>
<td>return</td>
<td>var</td>
</tr>
</tbody></table>
<p>除了以上介绍的这些关键字，Go 语言还有 36 个预定义标识符：</p>
<table>
<thead>
<tr>
<th>append</th>
<th>bool</th>
<th>byte</th>
<th>cap</th>
<th>close</th>
<th>complex</th>
<th>complex64</th>
<th>complex128</th>
<th>uint16</th>
</tr>
</thead>
<tbody><tr>
<td>copy</td>
<td>false</td>
<td>float32</td>
<td>float64</td>
<td>imag</td>
<td>int</td>
<td>int8</td>
<td>int16</td>
<td>uint32</td>
</tr>
<tr>
<td>int32</td>
<td>int64</td>
<td>iota</td>
<td>len</td>
<td>make</td>
<td>new</td>
<td>nil</td>
<td>panic</td>
<td>uint64</td>
</tr>
<tr>
<td>print</td>
<td>println</td>
<td>real</td>
<td>recover</td>
<td>string</td>
<td>true</td>
<td>uint</td>
<td>uint8</td>
<td>uintptr</td>
</tr>
</tbody></table>
<h2 id="变量"><a href="#变量" class="headerlink" title="**变量  **"></a>**变量  **</h2><h3 id="变量的使用步骤"><a href="#变量的使用步骤" class="headerlink" title="变量的使用步骤"></a>变量的使用步骤</h3><ol>
<li>声明变量</li>
<li>赋值</li>
<li>使用</li>
</ol>
<h3 id="变量使用的注意事项"><a href="#变量使用的注意事项" class="headerlink" title="变量使用的注意事项"></a>变量使用的注意事项</h3><ol>
<li><p>变量表示该内存中的一个存储区域</p>
</li>
<li><p>该区域有自己的名称（变量名）和类型（数据类型）</p>
</li>
<li><p>Golang变量声明使用的三种方式</p>
<p> 3.1. 第一种 指定变量类型 声明后若不赋值则使用默认值</p>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 变量名 变量类型 <span class="keyword">var</span> a <span class="type">int</span> = <span class="number">10</span>   默认值<span class="number">0</span> </span><br></pre></td></tr></table></figure>

<p>​		3.2. 第二种 不指定声明的变量类型 会根据值判断变量类型</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 变量名 = 值 <span class="keyword">var</span> b = <span class="number">10</span> </span><br></pre></td></tr></table></figure>

<p>​		3.3. 第三种 省略var使用 :&#x3D;声明变量不能是已存在的变量   只能在函数体内用</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c := <span class="number">10</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>多变量声明</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a, b, c <span class="type">int</span> </span><br><span class="line"><span class="keyword">var</span> a, b, c = <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> </span><br><span class="line">d, e, f := <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> </span><br><span class="line">声明多个不同类型的 </span><br><span class="line"><span class="keyword">var</span> () 在函数体外使用</span><br><span class="line"><span class="keyword">var</span> (    </span><br><span class="line">    变量名<span class="number">1</span> 变量类型    </span><br><span class="line">    变量名<span class="number">2</span> 变量类型   </span><br><span class="line">    ... </span><br><span class="line">) </span><br></pre></td></tr></table></figure>

<ol start="5">
<li>匿名变量</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i, _ := <span class="number">10</span>, <span class="number">20</span>   _ 就是匿名变量  丢弃数据不做处理  配合函数返回值使用才有优势 </span><br></pre></td></tr></table></figure>

<h3 id="同类型的值可以直接通过等号来交换值"><a href="#同类型的值可以直接通过等号来交换值" class="headerlink" title="同类型的值可以直接通过等号来交换值"></a>同类型的值可以直接通过等号来交换值</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a1, b1 := <span class="number">20</span>, <span class="number">30</span> </span><br><span class="line">fmt.Printf(<span class="string">&quot;a1=%d,b2=%d\n&quot;</span>, a1, b1) </span><br><span class="line">b1, a1 = a1, b1 同类型的直接等号交换值 </span><br><span class="line">fmt.Printf(<span class="string">&quot;a1=%d,b2=%d\n&quot;</span>, a1, b1) 输出 </span><br><span class="line">交换前 </span><br><span class="line">a1=<span class="number">20</span>,b2=<span class="number">30</span> </span><br><span class="line">交换后 </span><br><span class="line">a1=<span class="number">30</span>,b2=<span class="number">20</span> </span><br></pre></td></tr></table></figure>

<h2 id="变量的数据类型"><a href="#变量的数据类型" class="headerlink" title="变量的数据类型"></a>变量的数据类型</h2><p><img src="https://i.loli.net/2021/06/24/rJjBIvTEfZdKWbo.jpg" alt="img"></p>
<p><img src="https://i.loli.net/2021/01/10/DHtszaAV562xMOJ.png" alt="image-20200523210859064"></p>
<h3 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a>整数类型</h3><p>int和uint类型占的字节数大小跟操作系统位数有关</p>
<h4 id="整型的使用细节"><a href="#整型的使用细节" class="headerlink" title="整型的使用细节"></a>整型的使用细节</h4><p>​	1. Golang整型类型分为有符号和无符号，int、uint的大小和操作系统位数有关</p>
<p>​	2. Golang的默认整型是int</p>
<p>​	3. 查看一个变量的数据类型和占用字节大小</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fmt.Printf(<span class="string">&quot;%T&quot;</span>, n)  <span class="comment">// %T格式化输出变量的数据类型</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;n2 所占的字节数大小 %d&quot;</span>, unsafe.Sizeof(n2))  </span><br><span class="line"><span class="comment">// unsafe包下的Sizeof可以返回变量所占字节大小</span></span><br></pre></td></tr></table></figure>

<p>​	4. Golang程序中整型数据变量在使用时，遵守保小不保大的原则，即：在程序正确运行下，尽量使用占用空间小的数据类型</p>
<p>​	5. bit：计算机中的最小存储单位，byte：计算机中基本存储单元，1byte &#x3D; 8bit</p>
<h3 id="浮点型-小数类型"><a href="#浮点型-小数类型" class="headerlink" title="浮点型&#x2F;小数类型"></a>浮点型&#x2F;小数类型</h3><ol>
<li><p>基本介绍</p>
<p> 小数类型就是用于存放小数的，默认是float64</p>
</li>
<li><p>小数类型分类</p>
<p> 单精度：float32    4个字节</p>
<p> 双精度：float64    8个字节</p>
</li>
<li><p>浮点数在机器中的存放形式：浮点数 &#x3D; 符号位 + 指数位 + 尾数位</p>
<p> 3.56</p>
<p> 11110000111.111111111111111111000</p>
</li>
<li><p>尾数部分可能丢失，造成精度损失</p>
</li>
<li><p>浮点数的存储分为三部分： 符号位 + 指数位 + 尾数位 在存储过程中，精度会有丢失</p>
</li>
<li><p>0.几的小数可以省略0 例：0.12 可以写成 .12</p>
</li>
<li><p>支持科学计数法：5.1234e2就是512.34 e2代表10的2次方， e可以大写也可以小写数字为负数就代表除</p>
</li>
<li><p>通常情况下，应该使用float64，它比float32更精确</p>
</li>
</ol>
<h3 id="字符类型"><a href="#字符类型" class="headerlink" title="字符类型"></a>字符类型</h3><ol>
<li>Golang中没有专门的字符类型，如果要存储单个字符（字母），一般用byte来保存</li>
<li>字符类型的直接输出，输出的是字符对应的ASCII值</li>
<li>字符常量是用单引号括起来的单个字符</li>
<li>允许使用转义字符 ’ \ ‘ 来将其后的字符转变成特殊字符型常量</li>
<li>Go语言的字符使用utf-8编码  英文字母1个字节，汉字3个字节</li>
<li>在Go中，字符的本质是一个整数，直接输出时，是该字符对应的utf-8编码的码值</li>
<li>可以直接给某个变量赋一个数字，然后按格式化输出是%c会输出该数字对应的Unicode字符</li>
<li>字符类型是可以进行运算的，相当于一个整数，因为它都有对应的Unicode码</li>
</ol>
<h3 id="布尔类型bool"><a href="#布尔类型bool" class="headerlink" title="布尔类型bool"></a>布尔类型bool</h3><ol>
<li>布尔类型也叫bool类型，bool类型数据只允许取true或false</li>
<li>布尔类型占1个字节</li>
<li>bool类型适于逻辑运算，一般用于程序流程控制</li>
</ol>
<h3 id="字符串类型string"><a href="#字符串类型string" class="headerlink" title="字符串类型string"></a>字符串类型string</h3><ol>
<li><p>字符串就是一串固定长度的字符连接起来的字符序列。Go的字符串是有单个字节连接起来的</p>
</li>
<li><p>Golang的字符串一旦声明赋值，就不能再修改，在Go中字符串是不可变的</p>
</li>
<li><p>字符串的两种表示形式</p>
<ol>
<li>双引号会识别转义字符</li>
<li>反引号， 以字符串的原生形式输出，包括换行和特殊字符，可以实现防止攻击、输出源代码等效果</li>
</ol>
</li>
<li><p>字符串拼接方式</p>
<ol>
<li><p>两个字符串相加</p>
 <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str <span class="type">string</span> = <span class="string">&quot;Hello&quot;</span> + <span class="string">&quot;World&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>当一行字符串太长时，需要用到多行字符串，加号留在上面</p>
 <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str <span class="type">string</span> = <span class="string">&quot;Hello&quot;</span> + <span class="string">&quot;World&quot;</span> + </span><br><span class="line"><span class="string">&quot;Hello&quot;</span> + <span class="string">&quot;World&quot;</span></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<h3 id="基本数据类型的转换"><a href="#基本数据类型的转换" class="headerlink" title="基本数据类型的转换"></a>基本数据类型的转换</h3><ol>
<li><p>Go在不同类型的变量之间赋值是需要显式转换，没有自动类型转换</p>
</li>
<li><p>基本语法 T(v) 将值 v 转换成类型 T </p>
<ol>
<li>T：就是数据类型</li>
<li>v：就是需要转换的变量</li>
</ol>
 <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i <span class="type">int</span> = <span class="number">10</span></span><br><span class="line"><span class="keyword">var</span> f <span class="type">float64</span> = <span class="type">float64</span>(i)</span><br></pre></td></tr></table></figure>
</li>
<li><p>被转换的数据本身的数据类型是不会改变的</p>
</li>
<li><p>从数据范围大的转成数据范围小的时，会造成数据溢出</p>
</li>
<li><p>进行赋值运算的时候等号两边的数据类型也要一致，否则会报错</p>
</li>
</ol>
<h3 id="基本数据类型和string的转换"><a href="#基本数据类型和string的转换" class="headerlink" title="基本数据类型和string的转换"></a>基本数据类型和string的转换</h3><ol>
<li><p>在程序开发中，我们经常需要将基本数据类型转成string类型，或string类型转成基本数据类型</p>
</li>
<li><p>基本数据类型转string类型</p>
<ol>
<li><p>fmt.Sprintf(“%参数”, 表达式）</p>
 <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sprintf</span><span class="params">(format <span class="type">string</span>, a ...<span class="keyword">interface</span>&#123;&#125;)</span></span> <span class="type">string</span></span><br><span class="line">Sprintf根据format参数生成格式化的字符串并返回该字符串。</span><br></pre></td></tr></table></figure>

<ol>
<li>参数需要和表达式的数据类型相匹配</li>
<li>fmt.Sprintf() 会返回转换后的字符串</li>
</ol>
</li>
<li><p>使用 strconv 包的函数</p>
 <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FormatBool</span><span class="params">(b <span class="type">bool</span>)</span></span> <span class="type">string</span></span><br><span class="line">根据b的值返回<span class="string">&quot;true&quot;</span>或<span class="string">&quot;false&quot;</span>。</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FormatInt</span><span class="params">(i <span class="type">int64</span>, base <span class="type">int</span>)</span></span> <span class="type">string</span></span><br><span class="line">返回i的base进制的字符串表示。base 必须在<span class="number">2</span>到<span class="number">36</span>之间，结果中会使用小写字母<span class="string">&#x27;a&#x27;</span>到<span class="string">&#x27;z&#x27;</span>表示大于<span class="number">10</span>的数字</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FormatUint</span><span class="params">(i <span class="type">uint64</span>, base <span class="type">int</span>)</span></span> <span class="type">string</span></span><br><span class="line">是FormatInt的无符号整数版本。</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FormatFloat</span><span class="params">(f <span class="type">float64</span>, fmt <span class="type">byte</span>, prec, bitSize <span class="type">int</span>)</span></span> <span class="type">string</span></span><br><span class="line">函数将浮点数表示为字符串并返回。</span><br><span class="line"></span><br><span class="line">bitSize表示f的来源类型（<span class="number">32</span>：<span class="type">float32</span>、<span class="number">64</span>：<span class="type">float64</span>），会据此进行舍入。</span><br><span class="line"></span><br><span class="line">fmt表示格式：<span class="string">&#x27;f&#x27;</span>（-ddd.dddd）、<span class="string">&#x27;b&#x27;</span>（-ddddp±ddd，指数为二进制）、<span class="string">&#x27;e&#x27;</span>（-d.dddde±dd，十进制指数）、<span class="string">&#x27;E&#x27;</span>（-d.ddddE±dd，十进制指数）、<span class="string">&#x27;g&#x27;</span>（指数很大时用<span class="string">&#x27;e&#x27;</span>格式，否则<span class="string">&#x27;f&#x27;</span>格式）、<span class="string">&#x27;G&#x27;</span>（指数很大时用<span class="string">&#x27;E&#x27;</span>格式，否则<span class="string">&#x27;f&#x27;</span>格式）。</span><br><span class="line"></span><br><span class="line">prec控制精度（排除指数部分）：对<span class="string">&#x27;f&#x27;</span>、<span class="string">&#x27;e&#x27;</span>、<span class="string">&#x27;E&#x27;</span>，它表示小数点后的数字个数；对<span class="string">&#x27;g&#x27;</span>、<span class="string">&#x27;G&#x27;</span>，它控制总的数字个数。如果prec 为<span class="number">-1</span>，则代表使用最少数量的、但又必需的数字来表示f。</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Itoa</span><span class="params">(i <span class="type">int</span>)</span></span> <span class="type">string</span></span><br><span class="line">Itoa是FormatInt(i, <span class="number">10</span>) 的简写</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>string类型转基本数据类型</p>
 <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ParseBool</span><span class="params">(str <span class="type">string</span>)</span></span> (value <span class="type">bool</span>, err <span class="type">error</span>)</span><br><span class="line">返回字符串表示的<span class="type">bool</span>值。它接受<span class="number">1</span>、<span class="number">0</span>、t、f、T、F、<span class="literal">true</span>、<span class="literal">false</span>、True、False、TRUE、FALSE；否则返回错误。</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ParseInt</span><span class="params">(s <span class="type">string</span>, base <span class="type">int</span>, bitSize <span class="type">int</span>)</span></span> (i <span class="type">int64</span>, err <span class="type">error</span>)</span><br><span class="line">返回字符串表示的整数值，接受正负号。</span><br><span class="line"></span><br><span class="line">base指定进制（<span class="number">2</span>到<span class="number">36</span>），如果base为<span class="number">0</span>，则会从字符串前置判断，<span class="string">&quot;0x&quot;</span>是<span class="number">16</span>进制，<span class="string">&quot;0&quot;</span>是<span class="number">8</span>进制，否则是<span class="number">10</span>进制；</span><br><span class="line"></span><br><span class="line">bitSize指定结果必须能无溢出赋值的整数类型，<span class="number">0</span>、<span class="number">8</span>、<span class="number">16</span>、<span class="number">32</span>、<span class="number">64</span> 分别代表 <span class="type">int</span>、<span class="type">int8</span>、<span class="type">int16</span>、<span class="type">int32</span>、<span class="type">int64</span>；返回的err是*NumErr类型的，如果语法有误，err.Error = ErrSyntax；如果结果超出类型范围err.Error = ErrRange。</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ParseUint</span><span class="params">(s <span class="type">string</span>, base <span class="type">int</span>, bitSize <span class="type">int</span>)</span></span> (n <span class="type">uint64</span>, err <span class="type">error</span>)</span><br><span class="line">ParseUint类似ParseInt但不接受正负号，用于无符号整型。</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ParseFloat</span><span class="params">(s <span class="type">string</span>, bitSize <span class="type">int</span>)</span></span> (f <span class="type">float64</span>, err <span class="type">error</span>)</span><br><span class="line">解析一个表示浮点数的字符串并返回其值。</span><br><span class="line"></span><br><span class="line">如果s合乎语法规则，函数会返回最为接近s表示值的一个浮点数（使用IEEE754规范舍入）。bitSize指定了期望的接收类型，<span class="number">32</span>是<span class="type">float32</span>（返回值可以不改变精确值的赋值给<span class="type">float32</span>），<span class="number">64</span>是<span class="type">float64</span>；返回值err是*NumErr类型的，语法有误的，err.Error=ErrSyntax；结果超出表示范围的，返回值f为±Inf，err.Error= ErrRange。</span><br></pre></td></tr></table></figure>
</li>
<li><p>string转基本数据类型的注意事项</p>
<ol>
<li>在string类型转成基本数据类型时，要确保string类型能够转成有效的数据，比如我们可以把”123”,转成一个整数，但是不能把”hello”转成一个整数，如果这样做，Golang直接将其转成0</li>
</ol>
</li>
</ol>
<h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><ol>
<li>基本数据类型，变量存的就是指，也叫值类型</li>
<li>获取变量地址，用&amp;，比如：var num int，获取num的地址：&amp;num</li>
<li>指针类型变量存的是一个地址，这个地址指向的空间才是值，比如：var ptr *int &#x3D; &amp;num</li>
<li>获取指针类型所指向的值，使用：* 比如：var ptr *int，使用*ptr获取ptr指向的值</li>
</ol>
<img src="https://i.loli.net/2021/01/10/a857yg2CNxSr1e9.png" alt="image-20200525175855704" style="zoom:50%;" /> 

<p>​	指针变量存储的是一个地址值，其本身也有一个地址值</p>
<p><img src="https://i.loli.net/2021/01/10/rKX3BkZNVgR5WCQ.png" alt="image-20200525180115804"> </p>
<ol start="5">
<li>指针细节<ol>
<li>值类型，都有对应的指针类型，形式为*数据类型，比如int对应的指针就是*int</li>
<li><strong>值类型</strong>包括：基本数据类型 <strong>int系列</strong>、<strong>float系列</strong>、<strong>bool</strong>、<strong>string</strong>、<strong>数组</strong>和<strong>结构体struct</strong></li>
</ol>
</li>
</ol>
<h2 id="值类型和引用类型"><a href="#值类型和引用类型" class="headerlink" title="值类型和引用类型"></a>值类型和引用类型</h2><ol>
<li><strong>值类型</strong>：基本数据类型 <strong>int系列</strong>、<strong>float系列</strong>、<strong>bool</strong>、<strong>string</strong>、<strong>数组</strong>和<strong>结构体struct</strong></li>
<li><strong>引用类型</strong>：<strong>指针</strong>、<strong>slice切片</strong>、<strong>map</strong>、<strong>管道chan</strong>、<strong>interface</strong>、等都是引用类型 </li>
<li>值类型：变量直接存储值，内存通常在栈中分配</li>
<li>引用类型：变量存储的是一个地址，这个地址对应的空间才真正存储数据，内存通常在堆中分配，当没有任何变量引用这个地址时，该地址对应的数据空间就成为一个垃圾，用GC来回收</li>
</ol>
<h2 id="标识符的命名规则"><a href="#标识符的命名规则" class="headerlink" title="标识符的命名规则"></a>标识符的命名规则</h2><h3 id="标识符的概念"><a href="#标识符的概念" class="headerlink" title="标识符的概念"></a>标识符的概念</h3><ol>
<li>Golang对自己各种变量、方法等命名时使用的字符序列称为标识符</li>
<li>凡是自己可以起名字的地方都叫标识符</li>
</ol>
<h3 id="标识符的命名规则-1"><a href="#标识符的命名规则-1" class="headerlink" title="标识符的命名规则"></a>标识符的命名规则</h3><ol>
<li>由26个英文字母大小写，0-9，_ 组成</li>
<li>不可以数字开头</li>
<li>Golang中严格区分大小写</li>
<li>标识符不能包含空格</li>
<li>下划线” _ “本身在Golang中是一个特殊的标识符，称为空标识符。可以代表任何其他空标识符，但是它对应的值会被忽略(比如，忽略某个返回值)，所以仅能作为占位符使用，不能作为标识符使用</li>
<li>不能以系统保留关键字作为标识符，比如break，if等等</li>
</ol>
<h3 id="标识符命名注意事项"><a href="#标识符命名注意事项" class="headerlink" title="标识符命名注意事项"></a>标识符命名注意事项</h3><ol>
<li>包名：保持package的名字和目录保持一致，尽量采取有意义的包名，简短，有意义，不要和标准库命名冲突</li>
<li>变量名、函数名、常量名，采用驼峰法</li>
<li>如果变量名、函数名、常量名、首字母大写，则可以被其他包访问，如果首字母小写，则只能在本包中使用，（可以简单的理解成：首字母大写是公有的，首字母小写是私有的）</li>
</ol>
<h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a><strong>常量</strong></h2><h3 id="常量介绍"><a href="#常量介绍" class="headerlink" title="常量介绍"></a>常量介绍</h3><ol>
<li>常量使用const修饰</li>
<li>常量在定义的时候必须初始化</li>
<li>常量不能修改</li>
<li>常量只能是bool，数值类型(int，float类型)，string类型</li>
<li>语法：const name [type] &#x3D; value</li>
<li>仍然通过首字母的大小写来控制常量的访问范围</li>
</ol>
<p>使用const关键字声明常量  变量名一般用大写</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> A <span class="type">int</span> = <span class="number">2</span>   变量类型也可以不写 会根据值得类型来自动设置变量类型 </span><br></pre></td></tr></table></figure>

<h3 id="iota常量自动生成器-枚举"><a href="#iota常量自动生成器-枚举" class="headerlink" title="iota常量自动生成器 枚举"></a>iota常量自动生成器 枚举</h3><p>​	1、iota常量自动生成器，每隔一行，自动累加1</p>
<p>​	2、iota给常量赋值用</p>
<p>​	3、iota遇到const重置为0</p>
<p>​	4、如果是同一行值都一样</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main </span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span> </span><br><span class="line"><span class="keyword">const</span> (   </span><br><span class="line">    a = <span class="literal">iota</span>   <span class="number">0</span>   </span><br><span class="line">    b = <span class="literal">iota</span>   <span class="number">1</span>   </span><br><span class="line">    c = <span class="literal">iota</span>   <span class="number">2</span> </span><br><span class="line">) </span><br><span class="line">可以只写一个<span class="literal">iota</span> </span><br><span class="line"><span class="keyword">const</span> (    </span><br><span class="line">    a = <span class="literal">iota</span>    </span><br><span class="line">    b    </span><br><span class="line">    c </span><br><span class="line">) </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;   </span><br><span class="line">    fmt.Println(a, b, c)  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><h3 id="1-算术运算符"><a href="#1-算术运算符" class="headerlink" title="1. 算术运算符"></a>1. 算术运算符</h3><table>
<thead>
<tr>
<th align="left">运算符</th>
<th align="left">运算</th>
<th align="left">范例</th>
<th align="left">结果</th>
</tr>
</thead>
<tbody><tr>
<td align="left">+</td>
<td align="left">正号</td>
<td align="left">+3</td>
<td align="left">3</td>
</tr>
<tr>
<td align="left">-</td>
<td align="left">负号</td>
<td align="left">-3</td>
<td align="left">-3</td>
</tr>
<tr>
<td align="left">+</td>
<td align="left">加</td>
<td align="left">5 + 5</td>
<td align="left">10</td>
</tr>
<tr>
<td align="left">-</td>
<td align="left">减</td>
<td align="left">10 - 5</td>
<td align="left">5</td>
</tr>
<tr>
<td align="left">*</td>
<td align="left">乘</td>
<td align="left">10 * 5</td>
<td align="left">50</td>
</tr>
<tr>
<td align="left">&#x2F;</td>
<td align="left">除</td>
<td align="left">10 &#x2F; 3</td>
<td align="left">3</td>
</tr>
<tr>
<td align="left">%</td>
<td align="left">取模（求余）</td>
<td align="left">7 % 5</td>
<td align="left">2</td>
</tr>
<tr>
<td align="left">++</td>
<td align="left">自增</td>
<td align="left">a &#x3D; 2 a++</td>
<td align="left">a &#x3D; 3</td>
</tr>
<tr>
<td align="left">–</td>
<td align="left">自减</td>
<td align="left">a &#x3D; 3 a–</td>
<td align="left">a &#x3D; 2</td>
</tr>
<tr>
<td align="left">+</td>
<td align="left">字符串相加</td>
<td align="left">“He” + “llo”</td>
<td align="left">“Hello”</td>
</tr>
</tbody></table>
<p>除运算的时候只要有浮点数参与运算，那么输出的就是浮点数，否则都就是整数类型</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">10</span> / <span class="number">2</span> <span class="comment">// num 是int类型的  值为 5</span></span><br><span class="line"><span class="keyword">var</span> num = <span class="number">10.0</span> / <span class="number">2</span> <span class="comment">// num 是float64类型的   值为 5</span></span><br><span class="line"><span class="keyword">var</span> num = <span class="number">10</span> / <span class="number">2.0</span> <span class="comment">// num 是float64类型的   值为 5</span></span><br></pre></td></tr></table></figure>

<p>模运算的公式：a % b &#x3D; a - a &#x2F; b * b</p>
<h4 id="注意细节"><a href="#注意细节" class="headerlink" title="注意细节"></a>注意细节</h4><pre><code>1. Golang的自增和自减只能当做一个独立语句使用，不能使用 b := a++

2. Golang的++ 和 -- 只能写在变量后面不能写在变量前面
</code></pre>
<h3 id="2-赋值运算符"><a href="#2-赋值运算符" class="headerlink" title="2. 赋值运算符"></a>2. 赋值运算符</h3><p>下表列出了所有Go语言的赋值运算符。</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
<th>实例</th>
</tr>
</thead>
<tbody><tr>
<td>&#x3D;</td>
<td>简单的赋值运算符，将一个表达式的值赋给一个左值</td>
<td>C &#x3D; A + B 将 A + B 表达式结果赋值给 C</td>
</tr>
<tr>
<td>+&#x3D;</td>
<td>相加后再赋值</td>
<td>C +&#x3D; A 等于 C &#x3D; C + A</td>
</tr>
<tr>
<td>-&#x3D;</td>
<td>相减后再赋值</td>
<td>C -&#x3D; A 等于 C &#x3D; C - A</td>
</tr>
<tr>
<td>*&#x3D;</td>
<td>相乘后再赋值</td>
<td>C *&#x3D; A 等于 C &#x3D; C * A</td>
</tr>
<tr>
<td>&#x2F;&#x3D;</td>
<td>相除后再赋值</td>
<td>C &#x2F;&#x3D; A 等于 C &#x3D; C &#x2F; A</td>
</tr>
<tr>
<td>%&#x3D;</td>
<td>求余后再赋值</td>
<td>C %&#x3D; A 等于 C &#x3D; C % A</td>
</tr>
<tr>
<td>&lt;&lt;&#x3D;</td>
<td>左移后赋值</td>
<td>C &lt;&lt;&#x3D; 2 等于 C &#x3D; C &lt;&lt; 2</td>
</tr>
<tr>
<td>&gt;&gt;&#x3D;</td>
<td>右移后赋值</td>
<td>C &gt;&gt;&#x3D; 2 等于 C &#x3D; C &gt;&gt; 2</td>
</tr>
<tr>
<td>&amp;&#x3D;</td>
<td>按位与后赋值</td>
<td>C &amp;&#x3D; 2 等于 C &#x3D; C &amp; 2</td>
</tr>
<tr>
<td>^&#x3D;</td>
<td>按位异或后赋值</td>
<td>C ^&#x3D; 2 等于 C &#x3D; C ^ 2</td>
</tr>
<tr>
<td>|&#x3D;</td>
<td>按位或后赋值</td>
<td>C |&#x3D; 2 等于 C &#x3D; C | 2</td>
</tr>
</tbody></table>
<h4 id="赋值运算符的特点"><a href="#赋值运算符的特点" class="headerlink" title="赋值运算符的特点"></a>赋值运算符的特点</h4><ol>
<li><p>运算顺序从右往左</p>
</li>
<li><p>赋值运算符的左边只能是变量，右边可以是变量、表达式、常量值</p>
</li>
</ol>
<p>交换两个变量的值，但是不可以使用中间变量</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="type">int</span> = <span class="number">10</span></span><br><span class="line"><span class="keyword">var</span> b <span class="type">int</span> = <span class="number">20</span></span><br><span class="line">a = a + b <span class="comment">// a = 30</span></span><br><span class="line">b = a - b <span class="comment">// b = 10</span></span><br><span class="line">a = a - b <span class="comment">// a = 20</span></span><br></pre></td></tr></table></figure>

<h3 id="3-关系运算符"><a href="#3-关系运算符" class="headerlink" title="3. 关系运算符"></a>3. 关系运算符</h3><ol>
<li><p>关系运算符的结果都是bool型，也就是要么true，要么是false</p>
</li>
<li><p>关系表达式，经常用在if结构的条件中或循环结构的条件中</p>
</li>
</ol>
<table>
<thead>
<tr>
<th>运算符</th>
<th>运算</th>
<th>范例</th>
<th>结果</th>
</tr>
</thead>
<tbody><tr>
<td>&#x3D;&#x3D;</td>
<td>相等于</td>
<td>4 &#x3D;&#x3D; 3</td>
<td>false</td>
</tr>
<tr>
<td>!&#x3D;</td>
<td>不等于</td>
<td>4 !&#x3D; 3</td>
<td>true</td>
</tr>
<tr>
<td>&lt;</td>
<td>小于</td>
<td>4 &lt; 3</td>
<td>false</td>
</tr>
<tr>
<td>&gt;</td>
<td>大于</td>
<td>4 &gt; 3</td>
<td>true</td>
</tr>
<tr>
<td>&lt;&#x3D;</td>
<td>小于等于</td>
<td>4 &lt;&#x3D; 3</td>
<td>false</td>
</tr>
<tr>
<td>&gt;&#x3D;</td>
<td>大于等于</td>
<td>4 &gt;&#x3D; 3</td>
<td>true</td>
</tr>
</tbody></table>
<h3 id="4-逻辑运算符"><a href="#4-逻辑运算符" class="headerlink" title="4. 逻辑运算符"></a>4. 逻辑运算符</h3><ol>
<li>用于连接多个条件（一般就是关系表达式），最终结果也是一个bool值</li>
</ol>
<p>假设 A 值为true B值为false</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
<th>实例</th>
</tr>
</thead>
<tbody><tr>
<td>&amp;&amp;</td>
<td>逻辑 与 运算。如果两边的操作都是true，则为true，否则为false</td>
<td>(A &amp;&amp; B)为false</td>
</tr>
<tr>
<td>||</td>
<td>逻辑 或 运算。如果两边的操作有一个为true，则为true，否则为false</td>
<td>(A || B)为true</td>
</tr>
<tr>
<td>!</td>
<td>逻辑 非 运算。如果条件为true，则逻辑为false，否则为true</td>
<td>!(A &amp;&amp; B)为true</td>
</tr>
</tbody></table>
<h3 id="5-位运算符"><a href="#5-位运算符" class="headerlink" title="5. 位运算符"></a>5. 位运算符</h3><p>位运算符对整数在内存中的二进制位进行操作。</p>
<p>下表列出了位运算符 &amp;, |, 和 ^ 的计算：</p>
<table>
<thead>
<tr>
<th>p</th>
<th>q</th>
<th>p &amp; q</th>
<th>p | q</th>
<th>p ^ q</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
</tbody></table>
<p>&amp;：两个都是1才是1 其他都是0</p>
<p>|：两个中有一个或两个是1则是1</p>
<p>^：两个都是1或0就是0 其他情况是 1</p>
<p>&lt;&lt;：左移运算符，符号位不变，低位补0</p>
<p>&gt;&gt;：右移运算符，低位溢出，符号位不变，并用符号位补溢出的高位</p>
<h3 id="6-其他运算符"><a href="#6-其他运算符" class="headerlink" title="6. 其他运算符"></a>6. 其他运算符</h3><p>&amp;：返回变量存储地址</p>
<p>*：指针变量</p>
<h3 id="7-运算符优先级"><a href="#7-运算符优先级" class="headerlink" title="7. 运算符优先级"></a>7. 运算符优先级</h3><p>有些运算符拥有较高的优先级，二元运算符的运算方向均是从左至右。下表列出了所有运算符以及它们的优先级，由上至下代表优先级由高到低：</p>
<table>
<thead>
<tr>
<th>优先级</th>
<th>运算符</th>
</tr>
</thead>
<tbody><tr>
<td>7</td>
<td>^ !</td>
</tr>
<tr>
<td>6</td>
<td>* &#x2F; % &lt;&gt; &amp; &amp;^</td>
</tr>
<tr>
<td>5</td>
<td>+ - | ^</td>
</tr>
<tr>
<td>4</td>
<td>&#x3D;&#x3D; !&#x3D; &lt; &#x3D; &gt;</td>
</tr>
<tr>
<td>3</td>
<td>&lt;-</td>
</tr>
<tr>
<td>2</td>
<td>&amp;&amp;</td>
</tr>
<tr>
<td>1</td>
<td>||</td>
</tr>
</tbody></table>
<h2 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a><strong>条件语句</strong></h2><p>​	Go的 if，switch 还有一个强大的地方就是条件判断里面允许声明一个变量，这个变量的作用域该条件逻辑块内，其他地方就不起作用了</p>
<p>​	if 后面的条件加不加括号都没错，if的条件表达式不能是一个赋值语句</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">单分支<span class="keyword">if</span></span><br><span class="line"><span class="keyword">if</span> 条件表达式 &#123;    </span><br><span class="line">    语句 </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">if</span>支持一个初始化语句 </span><br><span class="line"><span class="keyword">if</span> b := <span class="number">2</span>; b == <span class="number">2</span> &#123;</span><br><span class="line">    语句 </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">双分支<span class="keyword">if</span></span><br><span class="line"><span class="keyword">if</span> 条件表达式 &#123;    </span><br><span class="line">    语句 </span><br><span class="line">&#125; <span class="keyword">else</span> &#123;    </span><br><span class="line">    语句 </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">多分支<span class="keyword">if</span></span><br><span class="line"><span class="keyword">if</span> 条件表达式 &#123;    </span><br><span class="line">    语句 </span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> 条件表达式&#123;    </span><br><span class="line">    语句 </span><br><span class="line">&#125; <span class="keyword">else</span> &#123;    </span><br><span class="line">    语句 </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b <span class="type">bool</span> = <span class="literal">true</span></span><br><span class="line"><span class="keyword">if</span> b = <span class="literal">false</span> &#123;  <span class="comment">// 这是错误的  可以写成 b = false; b 作为初始化语句</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;a&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;b&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>语句</span><br><span class="line"><span class="keyword">fallthrough</span></span><br><span class="line">使用 <span class="keyword">fallthrough</span> 会强制执行后面的 <span class="keyword">case</span> 语句，<span class="keyword">fallthrough</span> 不会判断下一条 <span class="keyword">case</span> 的表达式结果是否为 <span class="literal">true</span>。</span><br><span class="line">也支持一个初始化语句 </span><br><span class="line"><span class="keyword">switch</span> a := <span class="number">1</span>; a &#123;&#125; </span><br><span class="line"><span class="keyword">switch</span> 值 &#123;    </span><br><span class="line">    <span class="keyword">case</span> 值<span class="number">1</span>:         </span><br><span class="line">    value1        </span><br><span class="line">    <span class="keyword">fallthrough</span>    不会结束会继续执行下一个<span class="keyword">case</span>语句    </span><br><span class="line">    <span class="keyword">case</span> 值<span class="number">2</span>：        </span><br><span class="line">    value2    </span><br><span class="line">    <span class="keyword">case</span> 值<span class="number">3</span>, 值<span class="number">4</span>, ......:  支持多条件匹配用逗号分隔        </span><br><span class="line">    value3    </span><br><span class="line">    <span class="keyword">default</span>:     </span><br><span class="line">   &#125; </span><br><span class="line">还可以<span class="keyword">switch</span>后面不放值 </span><br><span class="line">score := <span class="number">65</span> </span><br><span class="line"><span class="keyword">switch</span> &#123;    </span><br><span class="line">    <span class="keyword">case</span> score &gt; <span class="number">90</span>:        </span><br><span class="line">    fmt.Println(<span class="string">&quot;优秀&quot;</span>)    </span><br><span class="line">    <span class="keyword">case</span> score &lt; <span class="number">90</span>:        </span><br><span class="line">    fmt.Println(<span class="string">&quot;垃圾&quot;</span>)     </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h4 id="注意细节-1"><a href="#注意细节-1" class="headerlink" title="注意细节"></a>注意细节</h4><ol>
<li><p>case&#x2F;switch后是一个表达式（即：常量值，变量，一个有返回值的函数等都可以）</p>
</li>
<li><p>case后的各个表达式的值的数据类型，必须和switch的的表达式数据类型一致</p>
</li>
<li><p>case后面可以带多个表达式，使用逗号间隔。比如case 表达式1,表达式2</p>
</li>
<li><p>case后面的表达式如果是常量值(字面量)，则要求不能重复</p>
</li>
<li><p>case后面不需要带break，程序匹配到一个case后就会执行对应的代码块，然后退出switch，如果一个都匹配不到，则执行default</p>
</li>
<li><p>default不是必须的</p>
</li>
<li><p>switch后面也可以不带表达式，类似多个if-else分支来使用</p>
</li>
<li><p>switch后也可以直接声明&#x2F;定义一个变量，分号结束，不推荐</p>
</li>
<li><p>switch穿透fallthrough，如果在case语句块后增加fallthrough，则会执行下一个case，也叫switch穿透</p>
</li>
<li><p>Type Switch ：switch语句还可以被用于type-switch来判断某个interface变量中实际指向的变量类型</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x <span class="keyword">interface</span>&#123;&#125;   <span class="comment">// 空接口</span></span><br><span class="line"><span class="keyword">var</span> y = <span class="number">10.0</span></span><br><span class="line">x = y</span><br><span class="line"><span class="keyword">switch</span> i := x.(<span class="keyword">type</span>) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="literal">nil</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;x 的类型：%T&quot;</span>, i)</span><br><span class="line"><span class="keyword">case</span> <span class="type">int</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;x 是 int 型的&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="type">float64</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;x 是 float64 型的&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>)</span></span> <span class="type">float64</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;x 是 func(int) 型的&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="type">bool</span>, <span class="type">string</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;x 是 bool 或 string 型的&quot;</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;未知类型&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a><strong>循环语句</strong></h2><h3 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ &#123;      </span><br><span class="line">    i := <span class="number">1</span> 必须使用:=定义循环变量  </span><br><span class="line">    如果已经声明的变量就不用     </span><br><span class="line">    不可以使用<span class="keyword">var</span> 声明    </span><br><span class="line">    循环体 </span><br><span class="line">&#125; </span><br><span class="line">j := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> j &lt; <span class="number">10</span> &#123;  这样写也没错</span><br><span class="line">    循环体</span><br><span class="line">    j++</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="注意事项和细节说明"><a href="#注意事项和细节说明" class="headerlink" title="注意事项和细节说明"></a>注意事项和细节说明</h3><ol>
<li><p>循环条件是一个返回布尔值的表达式</p>
</li>
<li><p>Golang提供for-range的方式，可以字符串和数组</p>
 <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str <span class="type">string</span> = <span class="string">&quot;Hello, World&quot;</span></span><br><span class="line">遍历字符串的两种方式</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(str); i++ &#123;   <span class="comment">// 按照字节来遍历的，所以遍历不了中文，转成rune切片类型</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;%d, %c\n&quot;</span>, i, str[i])</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// for-range按照字符的形式遍历，而传统方式是按照字节来遍历</span></span><br><span class="line"><span class="keyword">for</span> index, value := <span class="keyword">range</span> str &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;index=%d, value=%c\n&quot;</span>, index, value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="循环控制语句"><a href="#循环控制语句" class="headerlink" title="循环控制语句"></a>循环控制语句</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">break</span> 结束循环 </span><br><span class="line"><span class="keyword">continue</span> 结束当前循环跳转下一次循环 </span><br><span class="line"><span class="keyword">goto</span> 将控制转移到标记的语句 </span><br><span class="line"><span class="keyword">package</span> main </span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;   </span><br><span class="line">    <span class="comment">/* 定义局部变量 */</span>   </span><br><span class="line">    <span class="keyword">var</span> a <span class="type">int</span> = <span class="number">10</span>   </span><br><span class="line">    str := <span class="string">&quot;ABC&quot;</span>   </span><br><span class="line">    <span class="comment">/* 循环 */</span>   </span><br><span class="line">    LOOP: <span class="keyword">for</span> a &lt; <span class="number">20</span> &#123;    </span><br><span class="line">        <span class="keyword">if</span> a == <span class="number">15</span> &#123;      </span><br><span class="line">            <span class="comment">/* 跳过迭代 */</span>      </span><br><span class="line">            a = a + <span class="number">1</span>         </span><br><span class="line">            <span class="keyword">goto</span> LOOP    </span><br><span class="line">            当执行到这里的时候会跳回循环开始   </span><br><span class="line">        &#125;    </span><br><span class="line">        fmt.Printf(<span class="string">&quot;a的值为 : %d\n&quot;</span>, a)    </span><br><span class="line">        a++     </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">range</span>循环</span><br><span class="line">    i 是元素的位置，data是元素本身 data第二个参数不写的时候只写i那么就是返回的索引   </span><br><span class="line">    循环打印str   </span><br><span class="line">    <span class="keyword">for</span> i, data := <span class="keyword">range</span> str &#123;       </span><br><span class="line">        fmt.Printf(<span class="string">&quot;str[%d] = %s&quot;</span>, i, data)   </span><br><span class="line">    &#125;  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h3 id="break"><a href="#break" class="headerlink" title="break"></a>break</h3><h4 id="注意事项和细节"><a href="#注意事项和细节" class="headerlink" title="注意事项和细节"></a>注意事项和细节</h4><ol>
<li><p>break语句出现在多层嵌套的语句块中时，可以通过标签指明终止的是哪一层语句块</p>
</li>
<li><p>标签的基本使用</p>
 <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">label1: &#123;</span><br><span class="line">	label2: &#123;</span><br><span class="line">		label3: &#123;</span><br><span class="line">			<span class="keyword">break</span> label2</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="continue"><a href="#continue" class="headerlink" title="continue"></a>continue</h3><ol>
<li>continue用于结束本次循环，继续执行下一次循环</li>
<li>continue出现在多层嵌套的循环语句中时，可以通过标签指明要跳过的是哪一层循环，这个和break的使用规则一样</li>
</ol>
<h3 id="goto"><a href="#goto" class="headerlink" title="goto"></a>goto</h3><ol>
<li>Go语言的goto语句可以无条件地转移到程序中指定的行</li>
<li>goto语句通常与条件语句配合使用，可用来实现条件转移，跳出循环体等功能，</li>
<li>在Go程序设计中<strong>一般不主张使用goto语句</strong>，以免造成程序流程的混乱，使理解和调试程序都产生困难</li>
</ol>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a><strong>函数</strong></h2><p>为完成某一功能的程序指令(语句)的集合，称为函数，在Go中，函数分为：自定义函数，系统函数</p>
<h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">func 函数名(形参列表) (返回值类型列表) &#123;</span><br><span class="line">	执行列表</span><br><span class="line">	return 返回值列表</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>形参列表：表示函数的输入</li>
<li>函数中的语句：表示为了实现某一功能代码块</li>
<li>函数可以有返回值，也可以没有</li>
</ol>
<h3 id="包的介绍"><a href="#包的介绍" class="headerlink" title="包的介绍"></a>包的介绍</h3><h4 id="包的基本概念"><a href="#包的基本概念" class="headerlink" title="包的基本概念"></a>包的基本概念</h4><ol>
<li>go的每一个文件都是属于一个包的，也就是说go是以包的形式来管理文件和项目目录结构的</li>
</ol>
<h4 id="包的三大作用"><a href="#包的三大作用" class="headerlink" title="包的三大作用"></a>包的三大作用</h4><ol>
<li><p>区分相同名字的函数，变量名的标识符</p>
</li>
<li><p>当程序文件很多时，可以很好的管理项目</p>
</li>
<li><p>控制函数，变量等访问范围，即作用域</p>
</li>
<li><p>打包基本语法</p>
<p> package 包名</p>
</li>
<li><p>引入包的基本语法</p>
<p> import &quot;包的路径&quot;</p>
</li>
</ol>
<h4 id="包的注意事项和细节"><a href="#包的注意事项和细节" class="headerlink" title="包的注意事项和细节"></a>包的注意事项和细节</h4><ol>
<li><p>在给一个文件打包时，该包对应一个文件夹，文件的包名通常和文件所在的文件夹名一致，通常为小写字母</p>
</li>
<li><p>当一个文件要使用其他包函数或变量时，需要先引入对应的包</p>
</li>
<li><p>package指令在文件第一行，然后是import指令</p>
</li>
<li><p>在import包时，路径从$GOPATH的src下开始，不用带src，编译器会自动从src下开始引入</p>
</li>
<li><p>为了让其它包的文件，可以访问到本包的函数，则该函数名的首字母需要大写，类似其它语言的public，这样才能跨包访问</p>
</li>
<li><p>在访问其它包函数或变量时，其语法是  包名.函数名</p>
</li>
<li><p>如果包名较长，Go支持给包取别名，注意细节：取别名后，原来的包名就不能使用了</p>
 <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	util <span class="string">&quot;Go_code/chapter05/demo01/utils&quot;</span> <span class="comment">// 这里就是给包取别名</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
</li>
<li><p>在同一个包下，不能有相同的函数名也不能有相同的全局变量名，否则会报错</p>
</li>
<li><p>如果你要编译成一个可执行程序文件，就需要将这个包声明为main，即package main，这个就是一个语法规范，如果你要写一个库，包名可以自定义</p>
</li>
</ol>
<h3 id="return语句"><a href="#return语句" class="headerlink" title="return语句"></a>return语句</h3><ol>
<li>Go函数支持返回多个返回值，这一点是其它编程语言没有的</li>
<li>如果返回多个值时，在接收时，希望忽略某个返回值，则使用 _ 符号表示占位忽略<ol>
<li>如果返回值只有一个，(返回值类型列表) 可以不写()</li>
</ol>
</li>
</ol>
<h3 id="函数递归调用"><a href="#函数递归调用" class="headerlink" title="函数递归调用"></a>函数递归调用</h3><ol>
<li>执行一个函数时，就创建一个新的保护的独立空间（新函数栈）</li>
<li>函数的局部变量是独立的，不会相互影响</li>
<li>函数必须向退出递归的条件逼近，否则就是无限递归了</li>
<li>当一个函数执行完毕，或者遇到return，就会返回，遵守谁调用，就将结果返回给谁，同时当函数执行完毕或者返回时，该函数本身也会被系统销毁</li>
</ol>
<h3 id="函数注意事项和细节讨论"><a href="#函数注意事项和细节讨论" class="headerlink" title="函数注意事项和细节讨论"></a>函数注意事项和细节讨论</h3><ol>
<li><p>函数的形参列表可以是多个，返回值列表也可以是多个，多个形参类型相同的话可以省略前面的，只写最后的</p>
 <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(n1, n2 <span class="type">int</span>)</span></span> <span class="type">int</span> &#123; <span class="comment">// n1, n2 都是int类型，可以省略n1后面的int</span></span><br><span class="line">	<span class="keyword">return</span> n1 + n2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>形参列表和返回值列表的数据类型可以是值类型和引用类型</p>
</li>
<li><p>函数的命名遵守标识符命名规则，首字母不能是数字，首字母大写该函数可以被本包文件和其他包文件使用，首字母小写，只能被本包文件使用，其他包文件不能使用</p>
</li>
<li><p>函数中的变量是局部的，函数外不生效</p>
</li>
<li><p>基本数据类型和数组默认是值传递的，即进行值拷贝，在函数内修改，不会影响原来的值</p>
</li>
<li><p>如果希望函数内的变量能修改函数外的变量（指的是默认以值传递方式的数据类型），可以传入变量的地址&amp;，函数内以指针的方式操作变量，从效果上看类似引用类型</p>
</li>
<li><p>Go函数不支持重载</p>
</li>
<li><p>在Go中，函数也是一种数据类型，可以赋值给一个变量。则该变量就是一个函数类型的变量了，通过该函数可以对函数调用</p>
</li>
<li><p>函数既然是一种数据类型，因此在Go中，函数可以作为形参并调用</p>
 <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getSum</span><span class="params">(n1 <span class="type">int</span>, n2 <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> n1 + n2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myFun</span><span class="params">(fn <span class="keyword">func</span>(<span class="type">int</span>, <span class="type">int</span>)</span></span> <span class="type">int</span>, num1 <span class="type">int</span>, num2 <span class="type">int</span>) <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> fn(num1, num2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    result := myFun(getSum, <span class="number">10</span>, <span class="number">20</span>)</span><br><span class="line">    fmt.Println(<span class="string">&quot;resutl =&quot;</span>, result) <span class="comment">// result = 30</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>为了简化数据类型定义，Go支持自定义数据类型</p>
<ol>
<li><p>基本语法：type 自定义数据类型别名 数据类型 &#x2F;&#x2F; 相当于一个别名</p>
</li>
<li><p>type long int64 &#x2F;&#x2F; 这时的long就等价于int64来用</p>
<p> 虽然这里 long 和 int64 都是int64类型的，但是Go还是认为 long 和 int64 是两个数据类型</p>
</li>
</ol>
</li>
<li><p>支持对函数返回值命名，一定要加括号</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getSumAndSub</span><span class="params">(num1 <span class="type">int</span>, num2 <span class="type">int</span>)</span></span> (sum <span class="type">int</span>, sub <span class="type">int</span>) &#123;</span><br><span class="line">	sum = num1 + num2</span><br><span class="line">	sub = num1 - num2</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 _ 标识符，忽略返回值</p>
</li>
<li><p>Go支持可变参数</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 支持0到多个参数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(args...<span class="type">int</span>)</span></span> sum <span class="type">int</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 支持1到多个参数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(n1, args...<span class="type">int</span>)</span></span> sum <span class="type">int</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>args是slice 切片，通过args[index] 可以访问到各个值</li>
<li>如果一个函数的形参列表中有可变参数，则可变参数需要放在形参列表最后</li>
</ol>
</li>
</ol>
<h3 id="init函数"><a href="#init函数" class="headerlink" title="init函数"></a>init函数</h3><ol>
<li>每一个源文件都可以包含一个init函数，该函数会在main函数执行前，被Go运行框架调用，也就是说init会在main函数之前调用</li>
<li>如果一个文件同时包含全局变量定义，init函数和main函数，则执行的流程全局变量定义—&gt;init函数—&gt;main函数</li>
<li>init函数最主要的作用，就是完成一些初始化的工作</li>
<li>面试题：如果main.go和utils.go都含有变量定义，init函数时，执行流程是执行utils.go里面的变量定义，init函数，然后执行main.go里面的</li>
</ol>
<h3 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h3><ol>
<li><p>Go支持匿名函数，匿名函数就是没有名字的函数，如果我们某个函数只是希望使用一次，可以考虑使用匿名函数，匿名函数也可以实现多次调用</p>
</li>
<li><p>使用方式</p>
<ol>
<li>在定义匿名函数时就直接调用</li>
</ol>
 <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n1 <span class="type">int</span>, n2 <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	fmt.Println(n1 + n2)</span><br><span class="line">&#125;(<span class="number">10</span>, <span class="number">20</span>)</span><br></pre></td></tr></table></figure>

<ol>
<li>将匿名函数赋给一个变量(函数变量)，再通过该函数来调用匿名函数</li>
</ol>
 <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fn := <span class="function"><span class="keyword">func</span> <span class="params">(n1 <span class="type">int</span>, n2 <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;  <span class="comment">// fn是一个函数类型的变量</span></span><br><span class="line">    <span class="keyword">return</span> n1 - n2</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(fn(<span class="number">10</span>, <span class="number">20</span>)) <span class="comment">// -10</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>全局匿名函数</p>
<ol>
<li>如果将匿名函数赋给一个全局变量，那么这个匿名函数，就成为一个全局匿名函数，可以在程序有效</li>
</ol>
</li>
</ol>
<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><ol>
<li>基本介绍：闭包就是一个函数与其相关的引用环境组合的一个整体(实体)</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addUpper</span><span class="params">()</span></span> <span class="function"><span class="keyword">func</span> <span class="params">(<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">var</span> n <span class="type">int</span> = <span class="number">10</span></span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span> <span class="params">(x <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">		n = n + x</span><br><span class="line">		<span class="keyword">return</span> n</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fn := addUpper()</span><br><span class="line">	fmt.Println(fn(<span class="number">1</span>)) <span class="comment">// 11</span></span><br><span class="line">	fmt.Println(fn(<span class="number">2</span>)) <span class="comment">// 13</span></span><br><span class="line">	fmt.Println(fn(<span class="number">3</span>)) <span class="comment">// 16</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>上面代码总结</p>
<ol>
<li><p>addUpper 是一个函数，返回的数据类型是 func (int) int</p>
</li>
<li><p>闭包的说明</p>
 <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> n <span class="type">int</span> = <span class="number">10</span></span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span> <span class="params">(x <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    n = n + x</span><br><span class="line">    <span class="keyword">return</span> n</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 返回的是一个匿名函数，但是这个匿名函数引用到函数外的 n ，因此这个匿名函数就和 n 形成一个整体，构成闭包</p>
</li>
<li><p>可以这样理解：闭包是类，函数是操作，n是字段，函数和它使用到的 n 构成闭包</p>
</li>
<li><p>当我们反复的调用 fn 函数时，因为 n 是初始化一次，因此每调用一次就进行累加</p>
</li>
<li><p>我们要搞清楚闭包的关键，就要分析出返回的函数它使用(引用)到哪些变量，因为函数和它引用到的变量共同构成闭包</p>
</li>
</ol>
</li>
</ol>
<h3 id="函数中的defer"><a href="#函数中的defer" class="headerlink" title="函数中的defer"></a>函数中的defer</h3><ol>
<li>为什么需要defer：在函数中，程序员需要创建资源(比如：数据库连接、文件句柄、锁等)，为了<strong>在函数执行完毕后，及时的释放资源</strong>，Go的设计者提供defer(延时机制)</li>
<li>入门案例</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(n1 <span class="type">int</span>, n2 <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">// 当执行到defer时，暂时不执行，会将defer后面的语句压入到独立的栈中(defer栈)</span></span><br><span class="line">    <span class="comment">// 当函数执行完毕后，再从defer栈中，按照先入后出的方式出栈，执行</span></span><br><span class="line">	<span class="keyword">defer</span> fmt.Println(<span class="string">&quot;ok1 n1 =&quot;</span>, n1)</span><br><span class="line">	<span class="keyword">defer</span> fmt.Println(<span class="string">&quot;ok2 n2 =&quot;</span>, n2)</span><br><span class="line">	res := n1 + n2</span><br><span class="line">	fmt.Println(<span class="string">&quot;ok3 res =&quot;</span>, res)</span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	sum(<span class="number">10</span>, <span class="number">20</span>)</span><br><span class="line">&#125;</span><br><span class="line">输出结果</span><br><span class="line">ok3 res = <span class="number">30</span></span><br><span class="line">ok2 n2 = <span class="number">20</span></span><br><span class="line">ok1 n1 = <span class="number">10</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>细节说明<ol>
<li>当执行到defer时，暂时不执行，会将defer后面的语句压入到一个栈中(自己取名叫defer栈)，然后继续执行函数下一个语句</li>
<li>当函数执行完毕后，再从defer栈中，依次从栈顶取出语句(先入后出)</li>
<li>在defer将语句放入栈时，也<strong>会将相关的值拷贝同时入栈</strong></li>
</ol>
</li>
</ol>
<h3 id="函数参数的传递方式"><a href="#函数参数的传递方式" class="headerlink" title="函数参数的传递方式"></a>函数参数的传递方式</h3><ol>
<li>值类型参数默认就是值传递，而引用类型参数默认就是引用传递</li>
<li>两种传递方式<ol>
<li>值传递</li>
<li>引用传递</li>
</ol>
</li>
<li>不管是值传递还是引用传递，传递给函数的都是变量的副本，不同的是，值传递是值的拷贝，引用传递是地址的拷贝，一般来说，地址拷贝效率高，因为数据量小，而值拷贝由拷贝数据的大小决定，数据越大，效率越低</li>
</ol>
<h3 id="变量的作用域"><a href="#变量的作用域" class="headerlink" title="变量的作用域"></a>变量的作用域</h3><ol>
<li>函数内部声明&#x2F;定义的变量叫局部变量，作用域仅限于函数内部</li>
<li>函数外部声明&#x2F;定义的变量叫全局变量，作用域在整个包都有效，如果首字母为大写，则作用域在整个程序有效</li>
<li>如果变量是在一个代码块，比如for &#x2F; if 中，那么这个变量的作用域就在改代码块</li>
</ol>
<h3 id="Go字符串常用函数"><a href="#Go字符串常用函数" class="headerlink" title="Go字符串常用函数"></a>Go字符串常用函数</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 统计字符串的长度，按字节：</span><br><span class="line">	<span class="built_in">len</span>(str)</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> 字符串遍历，同时处理有中文的问题：</span><br><span class="line">	r := []<span class="type">rune</span>(str)  将字符串转成<span class="type">rune</span>切片</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> 字符串转整数：</span><br><span class="line">	n, err := strconv.Atoi(<span class="string">&quot;12&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span> 整数转字符串：</span><br><span class="line">	str := strconv.Itoa(<span class="number">123456</span>)</span><br><span class="line"></span><br><span class="line"><span class="number">5.</span> 字符串转 []<span class="type">byte</span>切片：</span><br><span class="line">	<span class="keyword">var</span> bytes = []<span class="type">byte</span>(<span class="string">&quot;hello go&quot;</span>) <span class="comment">// [h e l l o   g o]</span></span><br><span class="line"></span><br><span class="line"><span class="number">6.</span> []<span class="type">byte</span> 转 字符串：</span><br><span class="line">	str := <span class="type">string</span>([]<span class="type">byte</span>&#123;<span class="number">97</span>, <span class="number">98</span>, <span class="number">99</span>&#125;) <span class="comment">// &quot;abc&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="number">7.</span> 十进制转八，二，十六进制：</span><br><span class="line">	str := strconv.FormatInt(<span class="number">123</span>, <span class="number">2</span>) <span class="comment">// </span></span><br><span class="line"></span><br><span class="line">下面的都是strings包中的</span><br><span class="line"><span class="number">8.</span> 判断字符串s是否包含子串substr：</span><br><span class="line">	<span class="function"><span class="keyword">func</span> <span class="title">Contains</span><span class="params">(s <span class="type">string</span>, substr <span class="type">string</span>)</span></span> <span class="type">bool</span></span><br><span class="line">	strings.Contains(<span class="string">&quot;hellooo&quot;</span>, <span class="string">&quot;o&quot;</span>) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="number">9.</span> 返回字符串s中有几个不重复的sep子串：</span><br><span class="line">	<span class="function"><span class="keyword">func</span> <span class="title">Count</span><span class="params">(s <span class="type">string</span>, sep <span class="type">string</span>)</span></span> <span class="type">int</span></span><br><span class="line">	fmt.Println(strings.Count(<span class="string">&quot;aeefas&quot;</span>, <span class="string">&quot;e&quot;</span>)) <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="number">10.</span> 判断两个utf<span class="number">-8</span>编码字符串（将unicode大写、小写、标题三种格式字符视为相同）是否相同：</span><br><span class="line">	<span class="function"><span class="keyword">func</span> <span class="title">EqualFold</span><span class="params">(s <span class="type">string</span>, t <span class="type">string</span>)</span></span> <span class="type">bool</span></span><br><span class="line">	fmt.Println(strings.EqualFold(<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;ABC&quot;</span>)) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="number">11.</span> 子串sep在字符串s中第一次出现的位置，不存在则返回<span class="number">-1</span>：</span><br><span class="line">	<span class="function"><span class="keyword">func</span> <span class="title">Index</span><span class="params">(s <span class="type">string</span>, sep <span class="type">string</span>)</span></span> <span class="type">int</span></span><br><span class="line">	fmt.Println(strings.Index(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;lo&quot;</span>)) <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="number">12.</span> 子串sep在字符串s中最后一次出现的位置，不存在则返回<span class="number">-1</span></span><br><span class="line">	<span class="function"><span class="keyword">func</span> <span class="title">LastIndex</span><span class="params">(s <span class="type">string</span>, sep <span class="type">string</span>)</span></span> <span class="type">int</span></span><br><span class="line">	fmt.Println(strings.LastIndex(<span class="string">&quot;olnkol&quot;</span>, <span class="string">&quot;ol&quot;</span>)) <span class="comment">// 4</span></span><br><span class="line"></span><br><span class="line"><span class="number">13.</span> 返回将s中前n个不重叠old子串都替换为<span class="built_in">new</span>的新字符串，如果n&lt;<span class="number">0</span>会替换所有old子串</span><br><span class="line">	<span class="function"><span class="keyword">func</span> <span class="title">Replace</span><span class="params">(s <span class="type">string</span>, old <span class="type">string</span>, <span class="built_in">new</span> <span class="type">string</span>, n <span class="type">int</span>)</span></span> <span class="type">string</span></span><br><span class="line">	fmt.Println(strings.Replace(<span class="string">&quot;oink oink oink&quot;</span>, <span class="string">&quot;k&quot;</span>, <span class="string">&quot;ky&quot;</span>, <span class="number">2</span>)) <span class="comment">// oinky oinky oink</span></span><br><span class="line"></span><br><span class="line"><span class="number">14.</span> 按照指定某个字符为分割标识，将一个字符串拆分成字符串切片</span><br><span class="line">	<span class="function"><span class="keyword">func</span> <span class="title">Split</span><span class="params">(s <span class="type">string</span>, sep <span class="type">string</span>)</span></span> []<span class="type">string</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;%q&quot;</span>, strings.Split(<span class="string">&quot;a,b,c&quot;</span>, <span class="string">&quot;,&quot;</span>)) <span class="comment">// [&quot;a&quot; &quot;b&quot; &quot;c&quot;]</span></span><br><span class="line"></span><br><span class="line"><span class="number">15.</span> 返回将所有字母都转为对应的小写版本的拷贝</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">ToLower</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">string</span></span><br><span class="line">	fmt.Println(strings.ToLower(<span class="string">&quot;HELLO&quot;</span>)) <span class="comment">// hello</span></span><br><span class="line"></span><br><span class="line"><span class="number">16.</span> 返回将所有字母都转为对应的大写版本的拷贝</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">ToUpper</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">string</span></span><br><span class="line">	fmt.Println(strings.ToLower(<span class="string">&quot;hello&quot;</span>)) <span class="comment">// HELLO</span></span><br><span class="line"></span><br><span class="line"><span class="number">17.</span> 返回将s前后端所有空白都去掉的字符串</span><br><span class="line">	<span class="function"><span class="keyword">func</span> <span class="title">TrimSpace</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">string</span></span><br><span class="line">	fmt.Println(strings.TrimSpace(<span class="string">&quot; abc &quot;</span>)) <span class="comment">// abc 没有前后的空格</span></span><br><span class="line"></span><br><span class="line"><span class="number">18.</span> 返回将s前后端指定字符的字符去掉</span><br><span class="line">	<span class="function"><span class="keyword">func</span> <span class="title">Trim</span><span class="params">(s <span class="type">string</span>, cutset <span class="type">string</span>)</span></span> <span class="type">string</span></span><br><span class="line">	fmt.Println(strings.Trim(<span class="string">&quot;!hello!&quot;</span>, <span class="string">&quot;!&quot;</span>)) <span class="comment">// 将前后端的!去掉，结果 hello</span></span><br><span class="line"></span><br><span class="line"><span class="number">19.</span> 将字符串左边指定的字符去掉</span><br><span class="line">	<span class="function"><span class="keyword">func</span> <span class="title">TrimLeft</span><span class="params">(s <span class="type">string</span>, cutset <span class="type">string</span>)</span></span> <span class="type">string</span></span><br><span class="line">	fmt.Println(strings.TrimLeft(<span class="string">&quot;!hello!&quot;</span>, <span class="string">&quot;!&quot;</span>)) <span class="comment">// 结果 hello!</span></span><br><span class="line"></span><br><span class="line"><span class="number">20.</span> 将字符串右边指定的字符去掉</span><br><span class="line">	<span class="function"><span class="keyword">func</span> <span class="title">TrimRight</span><span class="params">(s <span class="type">string</span>, cutset <span class="type">string</span>)</span></span> <span class="type">string</span></span><br><span class="line">	fmt.Println(strings.TrimRight(<span class="string">&quot;!hello!&quot;</span>, <span class="string">&quot;!&quot;</span>)) <span class="comment">// 结果 !hello</span></span><br><span class="line"></span><br><span class="line"><span class="number">21.</span> 判断字符串是否以指定的字符串开头</span><br><span class="line">	<span class="function"><span class="keyword">func</span> <span class="title">HasPrefix</span><span class="params">(s, prefix <span class="type">string</span>)</span></span> <span class="type">bool</span>  prefix前缀</span><br><span class="line">	fmt.Println(strings.HasPrefix(<span class="string">&quot;http://192.168.200.128&quot;</span>, <span class="string">&quot;http&quot;</span>)) <span class="comment">// 判断是否是http开头</span></span><br><span class="line"></span><br><span class="line"><span class="number">22.</span> 判断字符串是否以指定的字符串结束</span><br><span class="line">	<span class="function"><span class="keyword">func</span> <span class="title">HasSuffix</span><span class="params">(s, suffix <span class="type">string</span>)</span></span> <span class="type">bool</span></span><br><span class="line">	fmt.Println(strings.HasSuffix(<span class="string">&quot;a.jpg&quot;</span>, <span class="string">&quot;.jpg&quot;</span>)) <span class="comment">// 判断字符串是否以.jpg结尾</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Go时间和日期相关函数"><a href="#Go时间和日期相关函数" class="headerlink" title="Go时间和日期相关函数"></a>Go时间和日期相关函数</h3><p>时间和日期相关函数，需要导入time包</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">1. time.Time类型，用于表示时间</span><br><span class="line">2. 获取当前时间time.Now()</span><br><span class="line">	fmt.Println(time.Now()) // 2020-06-03 13:11:59.9278745 +0800 CST m=+0.002975501</span><br><span class="line">3. 获取年月日，时分秒</span><br><span class="line">now := time.Now()</span><br><span class="line">	fmt.Println(&quot;年&quot;, now.Year()) // 年</span><br><span class="line">	fmt.Println(&quot;月&quot;, int(now.Month())) // 月</span><br><span class="line">	fmt.Println(&quot;日&quot;, now.Day()) // 日</span><br><span class="line">	fmt.Println(&quot;weekday&quot;, now.Weekday()) // 周几</span><br><span class="line">	fmt.Println(&quot;时&quot;, now.Hour()) // 时</span><br><span class="line">	fmt.Println(&quot;分&quot;, now.Minute()) // 分</span><br><span class="line">	fmt.Println(&quot;秒&quot;, now.Second()) // 秒</span><br><span class="line">4. 格式化时间日期</span><br><span class="line">	Printf</span><br><span class="line">	fmt.Printf(&quot;当前时间是 %d/%d/%d %d:%d:%02d&quot;, now.Year(), now.Month(), now.Day(),</span><br><span class="line">	now.Hour(), now.Minute(), now.Second())</span><br><span class="line">	now.Format(&quot;2006/01/02 15:04:05&quot;)  // 里面的2006/01/02 15:04:05是固定写法</span><br><span class="line">	now.Format(&quot;2006/01/02&quot;) // 只得到年月日</span><br><span class="line">	now.Format(&quot;15:04:05&quot;) // 只得到时分秒</span><br><span class="line">5. 时间的常量</span><br><span class="line">	const (</span><br><span class="line">        Nanosecond  Duration = 1   // 纳秒</span><br><span class="line">        Microsecond          = 1000 * Nanosecond  // 微秒</span><br><span class="line">        Millisecond          = 1000 * Microsecond // 毫秒</span><br><span class="line">        Second               = 1000 * Millisecond // 秒</span><br><span class="line">        Minute               = 60 * Second // 分钟</span><br><span class="line">        Hour                 = 60 * Minute // 时</span><br><span class="line">	)</span><br><span class="line">	直接time.时间常量名，如：100*time.Millisecond  表示100毫秒</span><br><span class="line">6. 结合sleep使用时间常量</span><br><span class="line">	time.Sleep(time.Millisecond * 100) // 休眠0.1秒(100毫秒)</span><br><span class="line">7. 获取当前Unix时间戳和UnixNano时间戳(作用是可以获取随机数字)</span><br><span class="line">	Unix时间戳</span><br><span class="line">	UnixNano时间戳</span><br></pre></td></tr></table></figure>

<h3 id="内置函数"><a href="#内置函数" class="headerlink" title="内置函数"></a>内置函数</h3><p>Golang设计者为了编程方便，提供了一些函数，这些函数可以直接使用，我们称为Go的内置函数，builtin里面的</p>
<ol>
<li><p>len：用来求长度，比如string，array，slice，map，channel</p>
</li>
<li><p>new：用来分配内存，主要用来分配值类型，比如int，float32，struct……返回的是指针</p>
<p> <img src="https://i.loli.net/2021/01/16/I62uXoUZxvb3lh1.png" alt="image-20200603180754736"></p>
</li>
<li><p>make：用来分配内存，主要用来分配引用类型，比如chan，map，slice</p>
 <img src="https://i.loli.net/2021/01/16/CmwaxKJ59QbPiHo.png" alt="image-20200603180826691"  /></li>
</ol>
<h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><ol>
<li>Go语言不支持传统的try……catch……finally</li>
<li>Go中引入的处理方式为：defer, panic, recover</li>
<li>Go中可以抛出一个panic的异常，然后再defer中通过recover捕获这个异常，然后正常处理</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		err := <span class="built_in">recover</span>()</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;err =&quot;</span>, err)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	num1 := <span class="number">10</span></span><br><span class="line">	num2 := <span class="number">0</span></span><br><span class="line">	result := num1/num2</span><br><span class="line">	fmt.Println(<span class="string">&quot;res=&quot;</span>, result)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	test()</span><br><span class="line">	fmt.Println(<span class="string">&quot;test下面的……&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>自定义错误<ol>
<li>Go程序中，支持自定义错误，使用 errors.New 和 panic 内置函数</li>
<li>errors.New(“错误说明”)，会返回一个error类型的值，表示一个错误</li>
<li>panic内置函数，接收一个interface{}类型的值（也就是任何值了）作为参数，可以接收error类型的变量，<strong>输出错误信息，并退出程序</strong></li>
</ol>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;errors&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">readConf</span><span class="params">(name <span class="type">string</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> name == <span class="string">&quot;init.config&quot;</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> errors.New(<span class="string">&quot;读取文件发生错误&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test2</span><span class="params">()</span></span> &#123;</span><br><span class="line">	err := readConf(<span class="string">&quot;init.config&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;配置文件读取成功&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	test2()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>数组可以存放多个同一类型数据，数组也是一种数据类型，在Go中，<strong>数组是值类型</strong></p>
<ol>
<li>使用数组来解决问题，程序的可维护性增加</li>
<li>而且方法代码更加清晰，也容易扩展</li>
</ol>
<h3 id="数组的定义"><a href="#数组的定义" class="headerlink" title="数组的定义"></a>数组的定义</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var 数组名 [数组大小]数据类型</span><br></pre></td></tr></table></figure>

<p>四种初始化数组的方式</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr [<span class="number">3</span>]<span class="type">int</span> = [<span class="number">3</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">3</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"><span class="keyword">var</span> arr = [...]<span class="type">int</span>&#123;<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;  <span class="comment">// 系统自动判断大小</span></span><br><span class="line">指定元素值对应的下标</span><br><span class="line"><span class="keyword">var</span> name = [<span class="number">3</span>]<span class="type">string</span>&#123;<span class="number">1</span>:<span class="string">&quot;tome&quot;</span>, <span class="number">0</span>:<span class="string">&quot;jack&quot;</span>, <span class="number">2</span>:<span class="string">&quot;marry&quot;</span>&#125;</span><br><span class="line">name := [<span class="number">3</span>]<span class="type">string</span>&#123;<span class="number">1</span>:<span class="string">&quot;tome&quot;</span>, <span class="number">0</span>:<span class="string">&quot;jack&quot;</span>, <span class="number">2</span>:<span class="string">&quot;marry&quot;</span>&#125;</span><br></pre></td></tr></table></figure>

<h3 id="数组的内存地址分布"><a href="#数组的内存地址分布" class="headerlink" title="数组的内存地址分布"></a>数组的内存地址分布</h3><ol>
<li>数组的地址可以通过数组名来获取&amp;arr</li>
<li>数组的第一个元素的地址，就是数组的首地址</li>
<li>数组的各个元素的地址之间是依据数组的类型决定</li>
</ol>
<h3 id="访问数组元素"><a href="#访问数组元素" class="headerlink" title="访问数组元素"></a>访问数组元素</h3><ol>
<li>数组名[下标] 比如：要是用a数组的第三个元素 a[2]</li>
</ol>
<h3 id="for-range遍历数组"><a href="#for-range遍历数组" class="headerlink" title="for-range遍历数组"></a>for-range遍历数组</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> index, value := <span class="keyword">range</span> arr &#123;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>第一个返回值index是数组的下标</li>
<li>第二个value是在该下标位置的值</li>
<li>它们都是仅在 for 循环内部可见的局部变量</li>
<li>遍历数组元素的时候，如果不想使用index，可以直接用 _ 下划线忽略</li>
<li>index和value的名称不是固定的，可以自定义</li>
</ol>
<h3 id="注意事项和细节-1"><a href="#注意事项和细节-1" class="headerlink" title="注意事项和细节"></a>注意事项和细节</h3><ol>
<li><p>数组是多个相同类型数组的组合，一个数组一旦声明定义，其长度是固定的，不能动态变化</p>
</li>
<li><p>var arr []int 这时 arr 就是一个slice切片</p>
</li>
<li><p>数组中的元素可以是任何数据类型，包括值类型和引用类型，但是不能够混用</p>
</li>
<li><p>数组创建后，如果没有赋值，有默认值，</p>
<ol>
<li>数值类型数组，默认值是0</li>
<li>字符串数组，默认值是&quot;&quot;</li>
<li>bool数组，默认值是false</li>
</ol>
</li>
<li><p>使用数组的步骤</p>
<ol>
<li>声明数组并开辟空间</li>
<li>给数组各个元素元素赋值</li>
<li>使用数组</li>
</ol>
</li>
<li><p>数组的下标从0开始</p>
</li>
<li><p>数组下标必须在指定范围内使用，否则报panic：数组越界</p>
</li>
<li><p>Go的数组是值类型，在默认情况下是值传递，因此会进行值拷贝。数组间不会相互影响</p>
</li>
<li><p>如想在其他的函数中，去修改原来的数组，可以使用引用传递(指针传递)</p>
 <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(arr *[3]<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	(*arr)[<span class="number">0</span>] = <span class="number">88</span> <span class="comment">// (*arr)[0]取数组里面的值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> arr = [<span class="number">3</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">    test(&amp;arr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>长度是数组类型的一部分，在传递函数参数时，需要考虑数组的长度</p>
</li>
</ol>
<h3 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var arr [4][6]int</span><br><span class="line">arr[1][2] = 1</span><br><span class="line">arr[2][1] = 2</span><br><span class="line">arr[2][3] = 3</span><br><span class="line">for i := 0; i &lt; len(arr); i++ &#123;</span><br><span class="line">	for j := 0; j &lt; len(arr[i]); j++ &#123;</span><br><span class="line">		fmt.Print(arr[i][j], &quot; &quot;)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="二维数组的内存布局"><a href="#二维数组的内存布局" class="headerlink" title="二维数组的内存布局"></a>二维数组的内存布局</h4><p><img src="https://i.loli.net/2021/01/10/4X3VozykIDi8ZcE.png" alt="image-20200610094110286"></p>
<h4 id="初始化的方式"><a href="#初始化的方式" class="headerlink" title="初始化的方式"></a>初始化的方式</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr [<span class="number">2</span>][<span class="number">2</span>]<span class="type">int</span> = [<span class="number">2</span>][<span class="number">2</span>]<span class="type">int</span>&#123;&#123;<span class="number">1</span>, <span class="number">2</span>&#125;, &#123;<span class="number">1</span>, <span class="number">2</span>&#125;&#125;</span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">2</span>][<span class="number">2</span>]<span class="type">int</span>&#123;&#123;<span class="number">1</span>, <span class="number">2</span>&#125;, &#123;<span class="number">1</span>, <span class="number">2</span>&#125;&#125;</span><br><span class="line">arr := [<span class="number">2</span>][<span class="number">2</span>]<span class="type">int</span>&#123;&#123;<span class="number">1</span>, <span class="number">2</span>&#125;, &#123;<span class="number">1</span>, <span class="number">2</span>&#125;&#125;</span><br><span class="line"><span class="keyword">var</span> arr = [...][<span class="number">2</span>]<span class="type">int</span>&#123;&#123;<span class="number">1</span>, <span class="number">2</span>&#125;, &#123;<span class="number">1</span>, <span class="number">2</span>&#125;&#125;  <span class="comment">// 初始化第二个大小不能用...</span></span><br><span class="line"><span class="keyword">var</span> arr [<span class="number">2</span>][<span class="number">2</span>]<span class="type">int</span> = [...][<span class="number">2</span>]<span class="type">int</span>&#123;&#123;<span class="number">1</span>, <span class="number">2</span>&#125;, &#123;<span class="number">1</span>, <span class="number">2</span>&#125;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h2><h3 id="切片的基本介绍"><a href="#切片的基本介绍" class="headerlink" title="切片的基本介绍"></a>切片的基本介绍</h3><ol>
<li><p>切片是数组的引用，因此切片是引用类型，在进行传递时，遵守引用传递的机制</p>
</li>
<li><p>切片的使用和数组类似遍历切片、访问切片的元素和求切片长度 len(slice) 都一样</p>
</li>
<li><p>切片的长度是可以变化的，因此切片是一个可以动态变化的数组</p>
</li>
<li><p>切片定义的基本语法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var 切片变量名 []数据类型</span><br><span class="line">比如：var arr []int</span><br></pre></td></tr></table></figure>
</li>
<li><p><img src="https://i.loli.net/2021/01/10/WzkxapLtJHhTYfQ.png" alt="image-20200606075341381"></p>
</li>
</ol>
<h3 id="切片的使用"><a href="#切片的使用" class="headerlink" title="切片的使用"></a>切片的使用</h3><p>方式1：定义一个切片，让后让切片去引用一个已经创建好的数组</p>
<p>​	slice :&#x3D; arr[1:3]</p>
<p>方式2：通过make来创建切片</p>
<p>​	基本语法：var 切片名 []type &#x3D; make([]type, len, cap)</p>
<p>​	type：数据类型，len：大小，cap：指定切片容量 可选，cap的大小必须大于等于len</p>
<pre><code>	1. 通过make方式创建切片可以指定切片的大小和容量
	2. 如果没有给切片的各个元素赋值，就会使用默认值
	3. 通过make方式创建的切片对应的数组有make底层维护，对外不可见，只能通过slice去访问各个元素
</code></pre>
<p>方式3：定义一个切片，直接就指定具体数组，使用原理类似 make 的方式</p>
<p>​	var slice []int &#x3D; []int{1, 3, 5}</p>
<h3 id="注意事项和细节说明-1"><a href="#注意事项和细节说明-1" class="headerlink" title="注意事项和细节说明"></a>注意事项和细节说明</h3><ol>
<li>切片初始化是 var slice &#x3D; arr[startIndex:endIndex]  从arr数组下标为startIndex，取到下标为endIndex的元素(不包含arr[endIndex])</li>
<li>切片初始化时，仍然不能越界，范围在[0-len(arr)]之间，到时可以动态增长</li>
<li>var slice &#x3D; arr[0:end] 可以简写 var slice &#x3D; arr[:end]</li>
<li>var slice &#x3D; arr[start:len(arr)] 可以简写 var slice &#x3D; arr[start:]</li>
<li>var slice &#x3D; arr[0:len(arr)] 可以简写 var slice &#x3D; arr[:]</li>
<li>cap是一个内置函数，用于统计切片的容量，即最大可以存放多少个元素</li>
<li>切片定义完后，还不能使用，因为本身是一个空的，需要让其引用到一个数组，或者make一个空间供切片使用</li>
<li>切片可以继续切片</li>
<li>用append内置函数，可以对切片进行动态追加<ol>
<li>切片append操作的本质就是对数组扩容</li>
<li>go底层会创建一个新的数组newArr(安装扩容后大小)</li>
<li>将slice原来包含的元素拷贝到新的数组newArr</li>
<li>slice重新引用到newArr，原来的就被gc回收了</li>
<li>注意newArr是在底层来维护的，程序员不可见</li>
</ol>
</li>
<li>使用for-range 遍历切片时val 是值拷贝所以不能修改切片里面的值</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var slice []int = []int&#123;1, 2, 3&#125;</span><br><span class="line">追加元素，会返回一个新的切片，没有赋值的话本身slice内容没有变</span><br><span class="line">slice = append(slice, 4, 5)</span><br><span class="line">通过append将切片slice2追加给slice</span><br><span class="line">slice = append(slice, slice2...)</span><br><span class="line">var sli []int = []int&#123;1, 2, 3&#125;</span><br><span class="line">fmt.Printf(&quot;sli原来的地址是%v, 值是%v\n&quot;, &amp;sli[0], sli)</span><br><span class="line">sli = append(sli, 4, 5, 6)</span><br><span class="line">fmt.Printf(&quot;sli改变后的地址是%v, 值是%v&quot;, &amp;sli[0], sli)</span><br><span class="line">结果</span><br><span class="line">sli原来的地址是0xc00000c440, 值是[1 2 3]</span><br><span class="line">sli改变后的地址是0xc00000a300, 值是[1 2 3 4 5 6]</span><br></pre></td></tr></table></figure>

<h3 id="切片的拷贝操作"><a href="#切片的拷贝操作" class="headerlink" title="切片的拷贝操作"></a>切片的拷贝操作</h3><p>切片使用copy内置函数完成拷贝</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">func copy(dst, src []Type) int  都要是切片类型</span><br><span class="line">内建函数copy将元素从来源切片复制到目标切片中，也能将字节从字符串复制到字节切片中。copy返回被复制的元素数量，它会是 len(src) 和 len(dst) 中较小的那个。来源和目标的底层内存可以重叠。</span><br></pre></td></tr></table></figure>

<h3 id="切片删除操作"><a href="#切片删除操作" class="headerlink" title="切片删除操作"></a>切片删除操作</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">index := <span class="number">3</span> <span class="comment">// 指定删除元素位置</span></span><br><span class="line"><span class="keyword">if</span> index == <span class="number">-1</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">cs.Customers = <span class="built_in">append</span>(cs.Customers[:index], cs.Customers[index+<span class="number">1</span>:]...) </span><br><span class="line">将删除元素前后重新切片赋值</span><br></pre></td></tr></table></figure>

<h3 id="string和slice的关系"><a href="#string和slice的关系" class="headerlink" title="string和slice的关系"></a>string和slice的关系</h3><ol>
<li>string底层是一个byte数组，因此string也可以进行切片处理</li>
<li>string和切片在内存的形式</li>
<li>string是不可变的，也就是说不能通过 str[0] &#x3D; ‘z’ 方式来修改字符串</li>
<li>如果要修改字符串，可以先将string转成[]byte或[]rune修改重写然后再转成string</li>
</ol>
<h2 id="数组排序和查找"><a href="#数组排序和查找" class="headerlink" title="数组排序和查找"></a>数组排序和查找</h2><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><h4 id="排序基本介绍"><a href="#排序基本介绍" class="headerlink" title="排序基本介绍"></a>排序基本介绍</h4><p>排序是将一群数据，按指定的顺序进行排列的过程</p>
<p>排序的分类：</p>
<ol>
<li><p>内部排序</p>
<ol>
<li><p>指将需要处理的所有数据都加载到内部存储器中进行排序</p>
<p>包括(交换式排序，选择式排序和插入式排序)</p>
</li>
</ol>
</li>
<li><p>外部排序</p>
<pre><code> 1. 数据量过大，无法全部加载到内存中，需要借助外部存储进行排序，包括(合并排序法和直接合并排序法)
</code></pre>
</li>
</ol>
<h3 id="交换式排序"><a href="#交换式排序" class="headerlink" title="交换式排序"></a>交换式排序</h3><p>交换式排序属于内部排序法，是运用数据值比较后，依判断规则对数据位置进行交换，以达到排序的目的</p>
<p>交换式排序法又可分为两种</p>
<ol>
<li><p>冒泡排序法</p>
<p> 通过对待排序序列从后向前(从下标较大的元素开始)，依次比较相邻元素的排序码，若发现逆序则交换，使排序码较小的元素逐渐向后移向前部(从下标较大的单元移向下标较小的单元)，就像水底下的气泡一样逐渐向上冒，</p>
<p> 因为排序的过程中，各元素不断接近自己的位置，如果一趟比较下来没有进行过交换，说明序列有序，因此要在排序过程中设置一个标志flag判断元素是否进行过交换。从而减少不必要的比较</p>
<ol>
<li>一共会经过arr.length-1的轮数比较，每一轮会确定一个数的位置</li>
<li>每一轮的比较次数再逐渐的减少</li>
<li>当发现前面的一个数比后面的一个数大的时候，就进行了交换</li>
</ol>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> arr = [...]<span class="type">int</span>&#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">23</span>, <span class="number">34</span>, <span class="number">123</span>, <span class="number">2</span>, <span class="number">66</span>, <span class="number">90</span>, <span class="number">48</span>, <span class="number">29</span>, <span class="number">98</span>, <span class="number">903</span>&#125;</span><br><span class="line">	flag := <span class="literal">true</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(arr)<span class="number">-1</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="built_in">len</span>(arr)-i<span class="number">-1</span>; j++ &#123;</span><br><span class="line">			<span class="keyword">if</span> arr[j] &gt; arr[j+<span class="number">1</span>] &#123;</span><br><span class="line">				arr[j], arr[j+<span class="number">1</span>] = arr[j+<span class="number">1</span>], arr[j]</span><br><span class="line">				flag = <span class="literal">false</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> flag &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(arr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>快速排序法</li>
</ol>
<h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><p>在Golang中，我们常用的查找有两种：</p>
<ol>
<li>顺序查找</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">方式<span class="number">1</span></span><br><span class="line"><span class="keyword">var</span> arr = [...]<span class="type">string</span>&#123;<span class="string">&quot;白眉鹰王&quot;</span>, <span class="string">&quot;金毛狮王&quot;</span>, <span class="string">&quot;紫衫龙王&quot;</span>, <span class="string">&quot;青翼蝠王&quot;</span>&#125;</span><br><span class="line"><span class="keyword">var</span> heroName <span class="type">string</span></span><br><span class="line">fmt.Println(<span class="string">&quot;输入一个名称：&quot;</span>)</span><br><span class="line">fmt.Scanln(&amp;heroName)</span><br><span class="line"><span class="keyword">for</span> i, val := <span class="keyword">range</span> arr &#123;</span><br><span class="line">	<span class="keyword">if</span> val == heroName &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;找到了&quot;</span>, heroName, <span class="string">&quot;下标是&quot;</span>, i)</span><br><span class="line">		<span class="keyword">break</span></span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> i == <span class="built_in">len</span>(arr) - <span class="number">1</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;没有找到&quot;</span>, heroName)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">方式<span class="number">2</span> 推荐使用</span><br><span class="line"><span class="keyword">var</span> heroIndex <span class="type">int</span> = <span class="number">-1</span></span><br><span class="line"><span class="keyword">for</span> i, val := <span class="keyword">range</span> arr &#123;</span><br><span class="line">	<span class="keyword">if</span> val == heroName &#123;</span><br><span class="line">		heroIndex = i</span><br><span class="line">		<span class="keyword">break</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> heroIndex != <span class="number">-1</span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;找到了%s, 下标是%v&quot;</span>, heroName, heroIndex)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;没有找到&quot;</span>, heroName)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>二分查找(该数组是有序的)<br> <img src="https://i.loli.net/2021/01/10/nPiFGl2Lza39TsR.png" alt="image-20200609221715438"></li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">binaryFind</span><span class="params">(arr *[5]<span class="type">int</span>, leftIndex <span class="type">int</span>, rightIndex <span class="type">int</span>,findVal <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> leftIndex &gt; rightIndex &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;没有找到&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">var</span> middle <span class="type">int</span> = (rightIndex + leftIndex)/<span class="number">2</span></span><br><span class="line">	<span class="keyword">if</span> (*arr)[middle] &gt; findVal &#123;</span><br><span class="line">		rightIndex = middle - <span class="number">1</span></span><br><span class="line">		binaryFind(arr, leftIndex, rightIndex, findVal)</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (*arr)[middle] &lt; findVal &#123;</span><br><span class="line">		leftIndex = middle + <span class="number">1</span></span><br><span class="line">		binaryFind(arr, leftIndex, rightIndex, findVal)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;找到了下标&quot;</span>, middle)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	numArr := [...]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">8</span>, <span class="number">89</span>, <span class="number">1000</span>, <span class="number">1234</span>&#125;</span><br><span class="line">	binaryFind(&amp;numArr, <span class="number">0</span>, <span class="built_in">len</span>(numArr) - <span class="number">1</span>, <span class="number">1001</span>)</span><br><span class="line">	fmt.Println()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="map-映射"><a href="#map-映射" class="headerlink" title="map(映射)"></a>map(映射)</h2><p>map是key-value数据结构，又称为字段或关联数组，类似其他编程语言的集合</p>
<h3 id="基本语法-1"><a href="#基本语法-1" class="headerlink" title="基本语法"></a>基本语法</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="keyword">map</span>变量名 <span class="keyword">map</span>[keytype]valuetype</span><br></pre></td></tr></table></figure>

<p>key可以是什么类型</p>
<p>Golang中的map的key可以是很多种类型，比如 bool、数字、string、指针、channel，还可以是只包含前面几个类型的 接口、结构体、数组  <strong>通常为int、string</strong></p>
<p>注意：slice、map 还有 function 不可以，因为这几个没法用 &#x3D;&#x3D; 来判断</p>
<p>value可以是什么类型</p>
<p>value的类型和key基本一样，通常为：数字、string、map、struct</p>
<h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span></span><br><span class="line"><span class="keyword">var</span> a <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span></span><br><span class="line"><span class="keyword">var</span> a <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">string</span></span><br><span class="line"><span class="keyword">var</span> a <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span></span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：声明是不会分配内存的，初始化需要make，分配内存后才能赋值和使用</p>
<p>map的使用方式</p>
<ol>
<li><pre><code class="language-go"> // 声明，这是map=nil
 var cities map[string]string
 // make(map[string]string, 10) 分配一个map空间
 cities = make(map[string]string, 10)
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2. ```go</span><br><span class="line">    // 声明就直接make</span><br><span class="line">    var cities = make(map[string]string)</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><pre><code class="language-go"> // 声明，直接赋值，底层还是make了
 var cities map[string]string = map[string]string&#123;
     &quot;no4&quot; : &quot;成都&quot;,
 &#125;
 cities := map[string]string&#123;
     &quot;no4&quot; : &quot;成都&quot;,
 &#125;
 cities[&quot;no1&quot;] = &quot;北京&quot;
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### map的增删改查操作</span><br><span class="line"></span><br><span class="line">#### map的增加和更新</span><br><span class="line"></span><br></pre></td></tr></table></figure>
map[&quot;key&quot;] = value // 如果key还没有，就是增加，如果key存在就是修改
</code></pre>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### map删除</span><br><span class="line"></span><br><span class="line">1. delete(map, &quot;key&quot;)，delete是一个内置函数，如果key存在，就删除该key-value，如果key不存在，不操作，但是不会报错</span><br><span class="line">2. 如果我们要删除map的所有key，没有一个专门的方法一次删除，可以遍历一下key，逐个删除</span><br><span class="line">3. 或者 map = make(...)，make一个新的，让原来的成为垃圾，被GC回收</span><br><span class="line"></span><br><span class="line">#### map查找</span><br><span class="line"></span><br><span class="line">```go</span><br><span class="line">val, findRes = heroes[&quot;no1&quot;]</span><br><span class="line">if findRes &#123;</span><br><span class="line">	fmt.Println(&quot;找到了val =&quot;, val)</span><br><span class="line">&#125; else &#123;</span><br><span class="line">	fmt.Println(&quot;没有找到&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果heroes这个map中存在 &quot;no1&quot; ，那么 findRes 就会返回 true 否则返回 false</p>
<h3 id="map遍历"><a href="#map遍历" class="headerlink" title="map遍历"></a>map遍历</h3><p>map只能用for-range的形式遍历</p>
<h3 id="map切片"><a href="#map切片" class="headerlink" title="map切片"></a>map切片</h3><p>切片的数据类型如果是map，则我们称为 slice of map，map切片，这样使用则map的个数就可以动态变化了</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> monster = <span class="built_in">make</span>([]<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>, <span class="number">2</span>)</span><br><span class="line">monster[<span class="number">0</span>] = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>)</span><br><span class="line">monster[<span class="number">0</span>][<span class="string">&quot;name&quot;</span>] = <span class="string">&quot;狐狸精&quot;</span></span><br><span class="line">monster[<span class="number">0</span>][<span class="string">&quot;age&quot;</span>] = <span class="string">&quot;20&quot;</span></span><br><span class="line">monster[<span class="number">1</span>] = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>)</span><br><span class="line">monster[<span class="number">1</span>][<span class="string">&quot;name&quot;</span>] = <span class="string">&quot;猪精&quot;</span></span><br><span class="line">monster[<span class="number">1</span>][<span class="string">&quot;age&quot;</span>] = <span class="string">&quot;100&quot;</span></span><br><span class="line">newMonster := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>&#123;</span><br><span class="line">    <span class="string">&quot;name&quot;</span> : <span class="string">&quot;火云邪神&quot;</span>,</span><br><span class="line">    <span class="string">&quot;age&quot;</span> : <span class="string">&quot;20&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line">monster = <span class="built_in">append</span>(monster, newMonster)</span><br><span class="line">fmt.Println(monster)</span><br><span class="line">fmt.Println()</span><br></pre></td></tr></table></figure>

<h3 id="map排序"><a href="#map排序" class="headerlink" title="map排序"></a>map排序</h3><h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><ol>
<li>Golang中没有一个专门的方法map的key进行排序</li>
<li>Golang中的map默认是无序的，注意也不是按照添加的顺序存放的，你每次遍历，得到的输出可能不一样</li>
<li>Golang中map的排序，是先将 key 进行排序，然后根据 key 值遍历输出即可</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sort&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	map1 := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>, <span class="number">10</span>)</span><br><span class="line">	map1[<span class="number">10</span>] = <span class="number">3</span></span><br><span class="line">	map1[<span class="number">2</span>] = <span class="number">10</span></span><br><span class="line">	map1[<span class="number">4</span>] = <span class="number">20</span></span><br><span class="line">	map1[<span class="number">6</span>] = <span class="number">20</span></span><br><span class="line">	fmt.Println(map1)</span><br><span class="line">	<span class="keyword">var</span> keys []<span class="type">int</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> map1 &#123;</span><br><span class="line">		keys = <span class="built_in">append</span>(keys, i)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(keys)</span><br><span class="line">	sort.Ints(keys)</span><br><span class="line">	fmt.Println(keys)</span><br><span class="line">	<span class="keyword">for</span> _, val := <span class="keyword">range</span> keys &#123;</span><br><span class="line">		fmt.Println(map1[val])</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="map使用细节"><a href="#map使用细节" class="headerlink" title="map使用细节"></a>map使用细节</h3><ol>
<li>map 是引用类型，遵守引用类型传递的机制，在一个函数接收 map，修改后，会直接修改原来的map</li>
<li>map 的容量达到后，再想 map 增加元素，会自动扩容，并不会发生 panic，也就是说 map，能动态的增长键值对(key-value)</li>
<li>map 的 value 也经常使用 struct 类型，更适合管理复杂的数据(比前面 value 是一个 map 更好)，比如 value 为 Student 结构体</li>
</ol>
<h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><p>面向对象编程（OOP），Golang仍然有面向对象编程的继承，封装和多态的特性</p>
<h3 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Cat <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name <span class="type">string</span></span><br><span class="line">	Age <span class="type">int</span></span><br><span class="line">	Color <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> cat1 Cat</span><br><span class="line">cat1.Name = <span class="string">&quot;tom&quot;</span></span><br><span class="line">cat1.Age = <span class="number">20</span></span><br><span class="line">cat1.Color = <span class="string">&quot;red&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="结构体声明和使用陷阱"><a href="#结构体声明和使用陷阱" class="headerlink" title="结构体声明和使用陷阱"></a>结构体声明和使用陷阱</h4><ol>
<li>如何声明结构体</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> 结构体名 <span class="keyword">struct</span> &#123;</span><br><span class="line">	field <span class="keyword">type</span></span><br><span class="line">	field <span class="keyword">type</span></span><br><span class="line">&#125;</span><br><span class="line">举例</span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="type">string</span></span><br><span class="line">    Age <span class="type">int</span></span><br><span class="line">    Score <span class="type">float32</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="字段属性"><a href="#字段属性" class="headerlink" title="字段属性"></a>字段属性</h4><ol>
<li>从概念或叫法上看：结构体字段 &#x3D; 属性 &#x3D; field	</li>
<li>字段是结构体组成的一个部分，一般是基本数据类型、数组，也可以是引用类型</li>
<li>字段声明语法同变量</li>
<li>字段的类型可以为，基本类型，数组或引用类型</li>
<li>在创建一个结构体变量后，如果没有给字段赋值，都对应一个零值(默认值)，指针，slice和map的零值都是nil，既没有分配空间</li>
<li>不同结构体变量的字段是独立的，互不影响，一个结构体变量字段的更改，不影响另外一个</li>
</ol>
<p>创建结构体变量和访问结构体字段</p>
<ol>
<li><p>直接声明</p>
<p> var person Person</p>
</li>
<li><p>{}</p>
<p> var person Person &#x3D; Person{}</p>
</li>
<li><p>&amp;</p>
<p> var person *Person &#x3D; new(Person)</p>
 <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name <span class="type">string</span></span><br><span class="line">	Age <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> person = <span class="built_in">new</span>(Person)</span><br><span class="line">	(*person).Name = <span class="string">&quot;tom&quot;</span> <span class="comment">// 括号可以省略，写成person.Name</span></span><br><span class="line">	(*person).Age = <span class="number">20</span></span><br><span class="line">	fmt.Println(*person)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>{}</p>
<p> var person *Person &#x3D; &amp;Person{}</p>
 <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name <span class="type">string</span></span><br><span class="line">	Age <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> person = &amp;Person&#123;&#125;</span><br><span class="line">	(*person).Name = <span class="string">&quot;tom&quot;</span> <span class="comment">// 括号可以省略，写成person.Name</span></span><br><span class="line">	(*person).Age = <span class="number">20</span></span><br><span class="line">	fmt.Println(*person)</span><br><span class="line">    <span class="keyword">var</span> person *Person = &amp;Person&#123;</span><br><span class="line">        Name: <span class="string">&quot;a&quot;</span>,</span><br><span class="line">        Age: <span class="number">20</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">不能写*person.Name 会报错，因为.的优先级比*高，所以*一个具体的值会报错，除非person.Name是一个地址</span><br></pre></td></tr></table></figure>
</li>
<li><p>第3种和第4种方式返回的是 结构体指针</p>
</li>
<li><p>结构体指针访问字段的标准方式应该是：(*结构体指针).字段名，比如：(*person).Name &#x3D; &quot;tome&quot;</p>
</li>
<li><p>但go做了一个简化，也支持 结构体指针.字段名，比如 person.Name &#x3D; &quot;tome&quot;。更加符合程序员使用的习惯，go编译器底层对 person.Name 做了转换 (*person).Name</p>
</li>
</ol>
<h4 id="结构体使用细节和注意事项"><a href="#结构体使用细节和注意事项" class="headerlink" title="结构体使用细节和注意事项"></a>结构体使用细节和注意事项</h4><ol>
<li><p>结构体的所有字段在内存中是连续的</p>
</li>
<li><p>结构体是用户单独定义的类型，和其他类型进行装换时需要有完全相同的字段（名字、个数和类型）</p>
</li>
<li><p>结构体进行 type 重新定义(相当于起别名)，Golang认为是新的数据类型，但是相互间可以强转。</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">type Student struct &#123;</span><br><span class="line">	Name string</span><br><span class="line">	Age int</span><br><span class="line">&#125;</span><br><span class="line">type Stu Student</span><br><span class="line">func main() &#123;</span><br><span class="line">	var stu1 Student</span><br><span class="line">	var stu2 Stu</span><br><span class="line">	stu2 = stu1</span><br><span class="line">	fmt.Println(stu1, stu2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>struct 的每个字段上，可以写上以 tag ，该 tag 可以通过反射机制获取，常见的使用场景就是序列化和反序列化 json</p>
 <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;encoding/json&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">// Monster monster</span></span><br><span class="line"><span class="keyword">type</span> Monster <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name <span class="type">string</span> <span class="string">`json:&quot;name&quot;`</span> <span class="comment">// `json:&quot;name&quot;` 就是struct tag</span></span><br><span class="line">	Age <span class="type">int</span>	<span class="string">`json:&quot;age&quot;`</span></span><br><span class="line">	Skill <span class="type">string</span> <span class="string">`json:&quot;skill&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> monster Monster</span><br><span class="line">	monster.Name = <span class="string">&quot;红孩儿&quot;</span>	</span><br><span class="line">	monster.Age = <span class="number">10</span></span><br><span class="line">	monster.Skill = <span class="string">&quot;吐火&quot;</span></span><br><span class="line">	<span class="comment">// json.Marshal 函数中使用了反射</span></span><br><span class="line">	val, _ := json.Marshal(monster)</span><br><span class="line">	fmt.Printf(<span class="type">string</span>(val))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>基本介绍</p>
<p>​	Golang中的方法是作用在指定的数据类型上的（即和指定数据类型绑定），因此自定义类型都可以有方法，而不仅仅是结构体</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="comment">// Person person</span></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a Person)</span></span> test() &#123;</span><br><span class="line">	fmt.Println(a.Name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> b = Person&#123;<span class="string">&quot;zhangsan&quot;</span>&#125;</span><br><span class="line">	b.test()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>test 方法和 Person 类型绑定</li>
<li>test 方法只能通过 Person类型的变量来调用，而不能直接调用，也不能使用其他类型的变量来调用</li>
</ol>
<h4 id="方法的声明"><a href="#方法的声明" class="headerlink" title="方法的声明"></a>方法的声明</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(recevier <span class="keyword">type</span>)</span></span> mothedName(参数列表) (返回值列表)&#123;</span><br><span class="line">	方法体</span><br><span class="line">	<span class="keyword">return</span> 返回值</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>参数列表：表示方法输入</li>
<li>recevier type：表示这个方法和type这个类型绑定，或者说该方法作用域type类型</li>
<li>recevier type：type可以是结构体，也可以是其它自定义类型</li>
<li>recevier：就是一个type类型的一个变量(实例)</li>
</ol>
<h4 id="注意事项和细节-2"><a href="#注意事项和细节-2" class="headerlink" title="注意事项和细节"></a>注意事项和细节</h4><ol>
<li><p>结构体类型是值类型，在方法调用中，遵守值类型的传递机制，是值拷贝传递方式</p>
</li>
<li><p>如程序员希望在方法中，修改结构体变量的值，可以通过结构体指针的方式来处理</p>
<p> 调用的时候应该是 (&amp;c).area() 但是 go 底层优化可以写成 c.area()</p>
</li>
<li><p>Golang中方法作用在指定的数据类型上的(即：和指定的数据类型进行绑定)，因此自定义类型，都可以有方法，而不仅仅是struct，比如int，float32等都可以有方法</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">type integer int</span><br><span class="line">func (i *integer) change() &#123;</span><br><span class="line">	*i = *i + 1</span><br><span class="line">&#125;</span><br><span class="line">func main() &#123;</span><br><span class="line">	var i integer = 10</span><br><span class="line">	i.change()</span><br><span class="line">	fmt.Println(i) // 11</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>方法的访问范围控制的规则，和函数一样，方法名首字母小写，只能在本包访问，大写可以在其他包访问</p>
</li>
<li><p>如果一个类型实现了String()这个方法，fmt.Println默认会调用这个变量的String()进行输出</p>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	1 2 3		1 4 7</span></span><br><span class="line"><span class="comment">	4 5 6	=&gt;	2 5 8</span></span><br><span class="line"><span class="comment">	7 8 9  		3 6 9</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	arr[0][0]   &lt;=&gt;   arr[0][0]</span></span><br><span class="line"><span class="comment">	arr[0][1] 	&lt;=&gt;	  arr[1][0]</span></span><br><span class="line"><span class="comment">	arr[0][2] 	&lt;=&gt;	  arr[2][0]</span></span><br><span class="line"><span class="comment">	arr[1][1] 	&lt;=&gt;	  arr[1][1]</span></span><br><span class="line"><span class="comment">	arr[1][2] 	&lt;=&gt;	  arr[2][1]</span></span><br><span class="line"><span class="comment">	arr[2][2] 	&lt;=&gt;	  arr[2][2]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(methodutils MethodUtils)</span></span> reversl(arr *[<span class="number">3</span>][<span class="number">3</span>]<span class="type">int</span>) &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(arr); i++ &#123;</span><br><span class="line">		<span class="keyword">for</span> j := i; j &lt; <span class="built_in">len</span>(arr[i]); j++ &#123;</span><br><span class="line">			(*arr)[i][j], (*arr)[j][i] = (*arr)[j][i], (*arr)[i][j]</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="方法和函数的区别"><a href="#方法和函数的区别" class="headerlink" title="方法和函数的区别"></a>方法和函数的区别</h3><ol>
<li><p>调用方式不一样</p>
<p> 函数的调用方式：             函数名(实参列表)</p>
<p> 方法的调用方式：             变量.方法名(实参列表)</p>
</li>
<li><p>对于普通函数，接收者为值类型时，不能将指针类型的数据直接传递，反之亦然</p>
</li>
<li><p>对于方法（如struct方法），接收者为值类型时，可以直接用指针类型的变量调用方法，反过来也可以，真正决定值拷贝还是地址拷贝，主要是看这个方法是跟哪种类型绑定的</p>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> person <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p person)</span></span> test01() &#123;</span><br><span class="line">	fmt.Println(p.Name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *person)</span></span> test02() &#123;</span><br><span class="line">	p.Name = <span class="string">&quot;jack&quot;</span></span><br><span class="line">	fmt.Println(p.Name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> p = person&#123;<span class="string">&quot;张三&quot;</span>&#125;</span><br><span class="line">	p.test01()</span><br><span class="line">	(&amp;p).test01() <span class="comment">// 从形式上看是传入地址，但是本质是值拷贝</span></span><br><span class="line">	(&amp;p).test02() <span class="comment">// 等价于 p.test02</span></span><br><span class="line">	fmt.Println(p.Name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><p>Golang的结构体没有构造函数，通常可以使用工厂模式来解决这个问题</p>
<p>main.go</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import (</span><br><span class="line">	&quot;Go_code/chapter08/factory/model&quot;</span><br><span class="line">	&quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line">func main() &#123;</span><br><span class="line">	var stu1 = model.NewStudent(&quot;张三&quot;, 95.5)</span><br><span class="line">	fmt.Println(stu1.GetScore())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>student.go</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">package model</span><br><span class="line">// Student student</span><br><span class="line">type student struct &#123;</span><br><span class="line">	Name  string</span><br><span class="line">	score float64</span><br><span class="line">&#125;</span><br><span class="line">// NewStudent 用来创建student类型，</span><br><span class="line">func NewStudent(n string, s float64) *student &#123;</span><br><span class="line">	return &amp;student&#123;</span><br><span class="line">		Name:  n,</span><br><span class="line">		score: s,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">func (stu *student) GetScore() float64 &#123;</span><br><span class="line">	return stu.score</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="面向对象编程三大特性"><a href="#面向对象编程三大特性" class="headerlink" title="面向对象编程三大特性"></a>面向对象编程三大特性</h2><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>封装就是把抽象出来的字段和对字段的操作封装在一起，数据被保护在内部，程序的其他包只有通过被授权的操作(方法)，才能对字段进行操作</p>
<h4 id="封装的实现步骤"><a href="#封装的实现步骤" class="headerlink" title="封装的实现步骤"></a>封装的实现步骤</h4><ol>
<li>将结构体、字段(属性)的首字母小写(不能导出，其他包不能使用)</li>
<li>将结构体所在包提供一个工厂模式的函数，首字母大写。类似一个构造函数</li>
<li>写一对 Getter 和 Setter 方法</li>
</ol>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>在Golang中，如果一个struct嵌套了另一个匿名结构体，那么这个结构体就可以直接访问匿名结构体的字段和方法，从而实现了继承特性</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="keyword">type</span> student <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name  <span class="type">string</span></span><br><span class="line">	Age   <span class="type">int</span></span><br><span class="line">	Score <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> pupil <span class="keyword">struct</span> &#123;</span><br><span class="line">	student</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> graduate <span class="keyword">struct</span> &#123;</span><br><span class="line">	student</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(stu *student)</span></span> showInfo() &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;学生名 = %v 年龄 = %v 成绩 = %v\n&quot;</span>, stu.Name, stu.Age, stu.Score)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(stu *student)</span></span> setScore(score <span class="type">int</span>) &#123;</span><br><span class="line">	stu.Score = score</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p pupil)</span></span> testing() &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;小学生考试中......&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *graduate)</span></span> testing() &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;大学生考试中......&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 下面的 *.student. 都可以简写成 *. 省略student</span></span><br><span class="line">	<span class="keyword">var</span> p1 = &amp;pupil&#123;&#125;</span><br><span class="line">	p1.student.Name = <span class="string">&quot;张三&quot;</span></span><br><span class="line">	p1.student.Age = <span class="number">12</span></span><br><span class="line">	p1.testing()</span><br><span class="line">	p1.student.setScore(<span class="number">70</span>)</span><br><span class="line">	p1.student.showInfo()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> g1 = &amp;graduate&#123;&#125;</span><br><span class="line">	g1.student.Name = <span class="string">&quot;marry~&quot;</span></span><br><span class="line">	g1.student.Age = <span class="number">24</span></span><br><span class="line">	g1.testing()</span><br><span class="line">	g1.student.setScore(<span class="number">90</span>)</span><br><span class="line">	g1.student.showInfo()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>结构体可以使用嵌套匿名结构体所有的字段和方法，即：首字母大小写的字段、方法都可以使用</p>
</li>
<li><p>匿名结构体字段方法可以简化，向上查找</p>
 <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = &amp;pupil&#123;&#125;</span><br><span class="line">p1.student.Name = <span class="string">&quot;张三&quot;</span>   ==&gt; 	p1.Name = <span class="string">&quot;张三&quot;</span></span><br><span class="line">p1.student.Age = <span class="number">12</span>  	  ==&gt; 	 p1.Age = <span class="number">12</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>当结构体和匿名结构体有相同的字段或方法时，编译器采用<strong>就近访问原则</strong>，如希望访问匿名结构体的字段和方法，可以通过匿名结构体名来区分</p>
</li>
<li><p>结构体嵌入两个(或多个)匿名结构体，如果两个匿名结构体有相同的字段和方法(同时结构体本身没有同名的字段和方法)，在访问时，就必须要明确指定匿名结构体名字，否则编译报错</p>
</li>
<li><p>如果一个struct嵌套了一个有名结构体，这种模式就是组合，如果是组合关系，那么在访问组合的结构体的字段和方法时，必须带上结构体的名字</p>
 <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> A <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name <span class="type">string</span></span><br><span class="line">	age <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> D <span class="keyword">struct</span> &#123;</span><br><span class="line">	a A</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> d D</span><br><span class="line">	d.a.Name = <span class="string">&quot;张三&quot;</span> <span class="comment">// 不能通过d.Name访问</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>嵌套匿名结构体后，也可以在创建结构体变量时，直接指定各个匿名结构体字段的值</p>
 <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Goods <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name <span class="type">string</span></span><br><span class="line">	Price <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Brand <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name <span class="type">string</span></span><br><span class="line">	Address <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> TV <span class="keyword">struct</span> &#123;</span><br><span class="line">	Goods</span><br><span class="line">	Brand</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> TV2 <span class="keyword">struct</span> &#123;</span><br><span class="line">	*Goods</span><br><span class="line">	*Brand</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	vat tv1 = TV&#123; Goods&#123;<span class="string">&quot;电视机001&quot;</span>, <span class="number">5000</span>&#125;, Brand&#123;<span class="string">&quot;海尔&quot;</span>, <span class="string">&quot;山东&quot;</span>&#125;, &#125;</span><br><span class="line">	<span class="keyword">var</span> tv2 = TV&#123;</span><br><span class="line">		Goods&#123;</span><br><span class="line">			Name: <span class="string">&quot;电视机002&quot;</span>,</span><br><span class="line">			Price: <span class="number">2000.1</span>,</span><br><span class="line">		&#125;,</span><br><span class="line">		Brand&#123;</span><br><span class="line">			Name: <span class="string">&quot;海信&quot;</span>,</span><br><span class="line">			Address: <span class="string">&quot;成都&quot;</span>,</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	vat tv3 = TV2&#123; &amp;Goods&#123;<span class="string">&quot;电视机001&quot;</span>, <span class="number">5000</span>&#125;, &amp;Brand&#123;<span class="string">&quot;海尔&quot;</span>, <span class="string">&quot;山东&quot;</span>&#125;, &#125;</span><br><span class="line">	<span class="keyword">var</span> tv4 = TV2&#123;</span><br><span class="line">		&amp;Goods&#123;</span><br><span class="line">			Name: <span class="string">&quot;电视机002&quot;</span>,</span><br><span class="line">			Price: <span class="number">2000.1</span>,</span><br><span class="line">		&#125;,</span><br><span class="line">		&amp;Brand&#123;</span><br><span class="line">			Name: <span class="string">&quot;海信&quot;</span>,</span><br><span class="line">			Address: <span class="string">&quot;成都&quot;</span>,</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>当结构体的匿名字段是基本数据类型</p>
 <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> A <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name <span class="type">string</span></span><br><span class="line">	Age <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Stu <span class="keyword">struct</span> &#123;</span><br><span class="line">	A</span><br><span class="line">	<span class="type">int</span> <span class="comment">// 不能有多个同名的匿名字段</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	stu := Stu&#123;&#125;</span><br><span class="line">	stu.Name = <span class="string">&quot;tom&quot;</span></span><br><span class="line">	stu.Age = <span class="number">20</span></span><br><span class="line">	stu.<span class="type">int</span> = <span class="number">80</span></span><br><span class="line">	fmt.Println(stu) <span class="comment">// &#123;&#123;&quot;tome&quot; 20&#125; 80&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>一个struct嵌套了多个匿名结构体，那么该结构体可以直接访问嵌套的匿名结构体的字段和方法，从而实现了多重继承</p>
 <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Goods <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name <span class="type">string</span></span><br><span class="line">	Price <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Brand <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name <span class="type">string</span></span><br><span class="line">	Address <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> TV <span class="keyword">struct</span> &#123; <span class="comment">// TV同时继承了Goods和Brand</span></span><br><span class="line">	Goods</span><br><span class="line">	Brand</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>interface 类型可以定义一组方法，但是这些不需要实现。并且interface不能包含任何变量。到定义某个自定义类型要使用的时候，在根据具体情况把这些方法写出来</p>
<h3 id="基本语法-2"><a href="#基本语法-2" class="headerlink" title="基本语法"></a>基本语法</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> 接口名 <span class="keyword">interface</span> &#123;</span><br><span class="line">	method1(参数列表) 返回值类型</span><br><span class="line">	method2(参数列表) 返回值类型</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>接口里的所有方法都没有方法体，即接口的方法都是没有实现的方法，接口体现了程序设计的多态和高内聚低耦合的思想</li>
<li>Golang中的接口，不需要显式的实现。只需要一个变量，含有接口类型的所有方法，那么这个变量就实现这个接口</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="keyword">type</span> usb <span class="keyword">interface</span> &#123;</span><br><span class="line">	start()</span><br><span class="line">	stop()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> phone <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"><span class="keyword">type</span> camera <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p phone)</span></span> start() &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;手机插入USB了。。。&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p phone)</span></span> stop() &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;手机USB拔出来了。。。&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cam camera)</span></span> start() &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;手机插入USB了。。。&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cam camera)</span></span> stop() &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;手机USB拔出来了。。。&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> computer <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c computer)</span></span> working(u usb) &#123;</span><br><span class="line">	u.start()</span><br><span class="line">	u.stop()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> computer1 computer</span><br><span class="line">	<span class="keyword">var</span> p1 phone</span><br><span class="line">	<span class="keyword">var</span> c1 camera</span><br><span class="line">	computer1.working(p1)</span><br><span class="line">	computer1.working(c1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="注意事项和细节-3"><a href="#注意事项和细节-3" class="headerlink" title="注意事项和细节"></a>注意事项和细节</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> A <span class="keyword">interface</span> &#123;</span><br><span class="line">	say()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> B intergace &#123;</span><br><span class="line">    hello()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>接口本身不能创建实例，但是可以指向一个实现了该接口的自定义类型的变量</p>
 <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Stu <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(stu Stu)</span></span> say() &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;hello, stu&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> b Stu</span><br><span class="line">	<span class="keyword">var</span> a A = b</span><br><span class="line">	a.say()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>接口中所有的方法都没有方法体，即都是没有实现的方法</p>
</li>
<li><p>在Golang中 ，一个自定义类型需要将接口的所有方法都实现我们说这个自定义类型实现了该接口</p>
</li>
<li><p>只要是自定义数据类型，就可以实现接口，不仅仅是结构体类型</p>
 <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> integer <span class="type">int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(i integer)</span></span> say() &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>一个自定义类型可以实现多个接口</p>
 <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> monster <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m monster)</span></span> say() &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;monster say()&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m monster)</span></span> hello() &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;monster hello()&quot;</span>)</span><br><span class="line">&#125; 这样就实现了两个接口</span><br></pre></td></tr></table></figure>
</li>
<li><p>Golang接口中不能有任何变量</p>
</li>
<li><p>一个接口(A 接口)可以继承多个别的接口(B，C接口)，这时如果要实现A接口，也必须将B，C接口的方法也全部实现</p>
 <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> C <span class="keyword">interface</span> &#123;</span><br><span class="line">	A</span><br><span class="line">	B   <span class="comment">// A B接口中不能有相同的方法，否则报错，报重复定义的错误</span></span><br><span class="line">	test()</span><br><span class="line">&#125; <span class="comment">// 如果要实现C接口那么就要将test和A B接口里面的全部方法都实现</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>interface类型默认是一个指针(引用类型)，如果没有对interface初始化，那么会输出nil</p>
</li>
<li><p>空接口interface没有任何方法，所以所有类型都实现了空接口，即我们可以把任何类型的变量赋给空接口</p>
 <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> T <span class="keyword">interface</span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> t1 T = stu</span><br><span class="line">    fmt.Pritnln(t) <span class="comment">// &#123;&#125;</span></span><br><span class="line">    <span class="keyword">var</span> t2 <span class="keyword">interface</span>&#123;&#125; = stu</span><br><span class="line">    <span class="keyword">var</span> num1 <span class="type">float64</span> = <span class="number">8.8</span></span><br><span class="line">    t1 = num1 <span class="comment">// t1 = 8.8</span></span><br><span class="line">    t2 = num1 <span class="comment">// t2 = 8.8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="接口最佳实践"><a href="#接口最佳实践" class="headerlink" title="接口最佳实践"></a>接口最佳实践</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sort&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">type</span> hero <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name <span class="type">string</span></span><br><span class="line">	Age  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> heroSlice []hero</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(hs heroSlice)</span></span> Len() <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">len</span>(hs)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// less 方法就是决定你使用什么标准进行排序</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(hs heroSlice)</span></span> Less(i, j <span class="type">int</span>) <span class="type">bool</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> hs[i].Age &lt; hs[j].Age <span class="comment">// 大于是降序 小于是升序</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 进行换值的方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(hs heroSlice)</span></span> Swap(i, j <span class="type">int</span>) &#123;</span><br><span class="line">	hs[i], hs[j] = hs[j], hs[i]</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> heros = heroSlice&#123;</span><br><span class="line">		&#123;<span class="string">&quot;zhangsan&quot;</span>, <span class="number">20</span>&#125;,</span><br><span class="line">		&#123;<span class="string">&quot;lisi&quot;</span>, <span class="number">17</span>&#125;,</span><br><span class="line">		&#123;<span class="string">&quot;zhaowu&quot;</span>, <span class="number">4</span>&#125;,</span><br><span class="line">		&#123;<span class="string">&quot;liliu&quot;</span>, <span class="number">47</span>&#125;,</span><br><span class="line">		&#123;<span class="string">&quot;qiqi&quot;</span>, <span class="number">23</span>&#125;,</span><br><span class="line">		&#123;<span class="string">&quot;luba&quot;</span>, <span class="number">45</span>&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(heros)</span><br><span class="line">	sort.Sort(heros)</span><br><span class="line">	fmt.Println(heros)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="实现接口和继承比较"><a href="#实现接口和继承比较" class="headerlink" title="实现接口和继承比较"></a>实现接口和继承比较</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">type</span> monkey <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *monkey)</span></span> eat() &#123;</span><br><span class="line">	fmt.Println(m.Name, <span class="string">&quot;吃香蕉&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> bird <span class="keyword">interface</span> &#123;</span><br><span class="line">	fly()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> fish <span class="keyword">interface</span> &#123;</span><br><span class="line">	swmming()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> monkeyChild <span class="keyword">struct</span> &#123;</span><br><span class="line">	monkey</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *monkeyChild)</span></span> fly() &#123;</span><br><span class="line">	fmt.Println(m.Name, <span class="string">&quot;通过学习，会飞了&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *monkeyChild)</span></span> swmming() &#123;</span><br><span class="line">	fmt.Println(m.Name, <span class="string">&quot;通过学习，会游泳了&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> m  = monkeyChild&#123; monkey&#123;Name: <span class="string">&quot;悟空&quot;</span>&#125; &#125;</span><br><span class="line">	m.eat()</span><br><span class="line">	m.fly()</span><br><span class="line">	m.swmming()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>当A结构体继承了B结构体，那么A结构体就自动继承了B结构体的方法，并且可以直接使用</li>
<li>当A结构体需要扩展功能，同时不希望去破坏继承关系，则可以去实现某个接口即可，因此我们可以认为：实现接口是对继承机制的补充</li>
</ol>
<p><img src="https://i.loli.net/2021/01/10/m8W49axkneizZcH.png" alt="image-20200627111515845"></p>
<ol start="3">
<li><p>接口和继承解决的问题不同</p>
<ol>
<li><strong>继承的价值</strong>主要在于：解决代码的复用性和可维护性</li>
<li><strong>接口的价值</strong>主要在于：设计，设计好各种规范，让其他自定义类型去实现这些方法</li>
</ol>
</li>
<li><p>接口比继承更加灵活</p>
<p> 接口比继承更加灵活，继承是满足 is  -  a 的关系，而接口只需满足 like  -  a的关系</p>
</li>
<li><p>接口在一定程度上实现解耦</p>
</li>
</ol>
<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>变量具有多种形态。面向对象的第三大特征，在Golang中，多态特征是通过接口实现的，可以安装统一的接口来调用不同的实现，这是接口变量就呈现不同的形态</p>
<h4 id="接口体现多态特征"><a href="#接口体现多态特征" class="headerlink" title="接口体现多态特征"></a>接口体现多态特征</h4><ol>
<li><p><strong>多态参数</strong></p>
<p> 在前面 Usb 接口案例， Usb usb，既可以接收手机变量，又可以接收相机变量，Usb 接口多态</p>
</li>
<li><p><strong>多态数组</strong></p>
 <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="keyword">type</span> usb <span class="keyword">interface</span> &#123;</span><br><span class="line">	start()</span><br><span class="line">	stop()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> phone <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"><span class="keyword">type</span> camera <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p phone)</span></span> start() &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;手机插入USB了。。。&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p phone)</span></span> stop() &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;手机USB拔出来了。。。&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cam camera)</span></span> start() &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;相机插入USB了。。。&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cam camera)</span></span> stop() &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;相机USB拔出来了。。。&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> computer <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c computer)</span></span> working(u usb) &#123;</span><br><span class="line">	u.start()</span><br><span class="line">	u.stop()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> usbArr [<span class="number">3</span>]usb</span><br><span class="line">	usbArr[<span class="number">0</span>] = camera&#123;&#125;</span><br><span class="line">	usbArr[<span class="number">1</span>] = phone&#123;&#125;</span><br><span class="line">	usbArr[<span class="number">2</span>] = phone&#123;&#125;</span><br><span class="line">	fmt.Println(usbArr)</span><br><span class="line">	<span class="keyword">for</span> _, val := <span class="keyword">range</span> usbArr &#123;</span><br><span class="line">		val.start()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">type</span> point <span class="keyword">struct</span> &#123;</span><br><span class="line">	x <span class="type">int</span></span><br><span class="line">	y <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> a <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	<span class="keyword">var</span> p point</span><br><span class="line">	a = p</span><br><span class="line">	<span class="keyword">var</span> b point</span><br><span class="line">	<span class="comment">// 直接 b = a 会报错  </span></span><br><span class="line">    b = a.(point)</span><br><span class="line">    <span class="comment">// b = a.(point) 就是类型断言，表示判断a是否指向point类型的变量，如果是就转成point类型并赋值给b变 	// 量,否则报错</span></span><br><span class="line">	fmt.Println(b)</span><br><span class="line">    <span class="keyword">var</span> x <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	<span class="keyword">var</span> b2 <span class="type">float32</span> = <span class="number">1.1</span></span><br><span class="line">	x = b2 </span><br><span class="line">	y, isOk := x.(<span class="type">float64</span>) <span class="comment">// 带检测的</span></span><br><span class="line">	<span class="keyword">if</span> isOk &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;成功&quot;</span>)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;失败&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(y)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类型断言，由于接口是一般类型，不知道具体类型，如果要转成具体类型，就需要使用类型断言</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="keyword">type</span> student <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">typeJudge</span><span class="params">(item ...<span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i, v := <span class="keyword">range</span> item &#123;</span><br><span class="line">		<span class="keyword">switch</span> v.(<span class="keyword">type</span>) &#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="type">bool</span> :</span><br><span class="line">			fmt.Printf(<span class="string">&quot;第%v个参数是 bool 类型，值是%v\n&quot;</span>, i + <span class="number">1</span>, v)</span><br><span class="line">		<span class="keyword">case</span> <span class="type">int</span>, <span class="type">int32</span>, <span class="type">int64</span> :</span><br><span class="line">			fmt.Printf(<span class="string">&quot;第%v个参数是 int 类型，值是%v\n&quot;</span>, i + <span class="number">1</span>, v)</span><br><span class="line">		<span class="keyword">case</span> <span class="type">string</span> :</span><br><span class="line">			fmt.Printf(<span class="string">&quot;第%v个参数是 string 类型，值是%v\n&quot;</span>, i + <span class="number">1</span>, v)</span><br><span class="line">		<span class="keyword">case</span> <span class="type">float64</span>, <span class="type">float32</span> :</span><br><span class="line">			fmt.Printf(<span class="string">&quot;第%v个参数是 float 类型，值是%v\n&quot;</span>, i + <span class="number">1</span>, v)</span><br><span class="line">		<span class="keyword">case</span> <span class="type">byte</span> :</span><br><span class="line">			fmt.Printf(<span class="string">&quot;第%v个参数是 字符 类型，值是%c\n&quot;</span>, i + <span class="number">1</span>, v)</span><br><span class="line">		<span class="keyword">case</span> student :</span><br><span class="line">			fmt.Printf(<span class="string">&quot;第%v个参数是 student 类型，值是%c\n&quot;</span>, i + <span class="number">1</span>, v)</span><br><span class="line">		<span class="keyword">case</span> *student :</span><br><span class="line">			fmt.Printf(<span class="string">&quot;第%v个参数是 *student 类型，值是%c\n&quot;</span>, i + <span class="number">1</span>, v)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">default</span> :</span><br><span class="line">			fmt.Println(<span class="string">&quot;其他类型&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> a = <span class="number">10</span></span><br><span class="line">	<span class="keyword">var</span> f = <span class="number">1.1</span></span><br><span class="line">	<span class="keyword">var</span> c <span class="type">byte</span> = <span class="string">&#x27;a&#x27;</span></span><br><span class="line">	<span class="keyword">var</span> s = <span class="string">&quot;asjdlf&quot;</span></span><br><span class="line">	<span class="keyword">var</span> stu student</span><br><span class="line">	typeJudge(a, f, c, s, stu, &amp;stu)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h2><p>项目1-家庭收支记账系统</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="keyword">type</span> homeMoney <span class="keyword">struct</span> &#123;</span><br><span class="line">	Mold       <span class="type">string</span>  <span class="comment">// 收支 支出 或 收入</span></span><br><span class="line">	TotalMoney <span class="type">float64</span> <span class="comment">// 账户总额</span></span><br><span class="line">	UseMoney   <span class="type">float64</span> <span class="comment">// 收支金额</span></span><br><span class="line">	Declare    <span class="type">string</span>  <span class="comment">// 说明</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *homeMoney)</span></span> detail(sli *[]homeMoney) &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;\t\t\t--------------------当前收支明细记录-----------------------&quot;</span>)</span><br><span class="line">	fmt.Println(<span class="string">&quot;\t\t\t收支\t\t账户金额\t收支金额\t说明&quot;</span>)</span><br><span class="line">	<span class="keyword">for</span> _, val := <span class="keyword">range</span> *sli &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;\t\t\t%s\t\t%v\t\t%v\t\t%s\n&quot;</span>, val.Mold, val.TotalMoney, val.UseMoney, val.Declare)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *homeMoney)</span></span> income(sli *[]homeMoney) &#123;</span><br><span class="line">	<span class="keyword">var</span> money <span class="type">float64</span></span><br><span class="line">	<span class="keyword">var</span> str <span class="type">string</span></span><br><span class="line">	fmt.Print(<span class="string">&quot;\t\t\t\t\t\t本次收入金额: &quot;</span>)</span><br><span class="line">	fmt.Scanln(&amp;money)</span><br><span class="line">	fmt.Print(<span class="string">&quot;\t\t\t\t\t\t本次收入说明: &quot;</span>)</span><br><span class="line">	fmt.Scanln(&amp;str)</span><br><span class="line">	h.Mold = <span class="string">&quot;收入&quot;</span></span><br><span class="line">	h.TotalMoney += money</span><br><span class="line">	h.UseMoney = money</span><br><span class="line">	h.Declare = str</span><br><span class="line">	*sli = <span class="built_in">append</span>(*sli, *h)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *homeMoney)</span></span> expend(sli *[]homeMoney) &#123;</span><br><span class="line">	<span class="keyword">var</span> money <span class="type">float64</span></span><br><span class="line">	<span class="keyword">var</span> str <span class="type">string</span></span><br><span class="line">	fmt.Print(<span class="string">&quot;\t\t\t\t\t\t本次支出金额: &quot;</span>)</span><br><span class="line">	fmt.Scanln(&amp;money)</span><br><span class="line">	fmt.Print(<span class="string">&quot;\t\t\t\t\t\t本次支出说明: &quot;</span>)</span><br><span class="line">	fmt.Scanln(&amp;str)</span><br><span class="line">	<span class="keyword">if</span> money &gt; h.TotalMoney &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;\t\t\t\t\t\t你的余额不够这么多，只有&quot;</span>, h.TotalMoney)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	h.Mold = <span class="string">&quot;支出&quot;</span></span><br><span class="line">	h.TotalMoney -= money</span><br><span class="line">	h.UseMoney = money</span><br><span class="line">	h.Declare = str</span><br><span class="line">	*sli = <span class="built_in">append</span>(*sli, *h)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mainPage</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;\n\t\t\t-----------------------------------------------------------&quot;</span>)</span><br><span class="line">	fmt.Println(<span class="string">&quot;\t\t\t---------------------家庭收支记账软件----------------------&quot;</span>)</span><br><span class="line">	fmt.Println()</span><br><span class="line">	fmt.Println(<span class="string">&quot;\t\t\t\t\t\t1 收支明细&quot;</span>)</span><br><span class="line">	fmt.Println(<span class="string">&quot;\t\t\t\t\t\t2 登记收入&quot;</span>)</span><br><span class="line">	fmt.Println(<span class="string">&quot;\t\t\t\t\t\t3 登记支出&quot;</span>)</span><br><span class="line">	fmt.Println(<span class="string">&quot;\t\t\t\t\t\t4 退    出&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> sli []homeMoney</span><br><span class="line">	<span class="keyword">var</span> myHome = homeMoney&#123;&#125;</span><br><span class="line">label1:</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		mainPage()</span><br><span class="line">		fmt.Print(<span class="string">&quot;\t\t\t\t\t\t请选择(1-4): &quot;</span>)</span><br><span class="line">		<span class="keyword">var</span> num <span class="type">int</span></span><br><span class="line">		fmt.Scanln(&amp;num)</span><br><span class="line">		<span class="keyword">switch</span> num &#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">			myHome.detail(&amp;sli)</span><br><span class="line">		<span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">			myHome.income(&amp;sli)</span><br><span class="line">		<span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">			myHome.expend(&amp;sli)</span><br><span class="line">		<span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">			fmt.Println(<span class="string">&quot;\t\t\t\t\t你退出了家庭记账软件的使用&quot;</span>)</span><br><span class="line">			<span class="keyword">break</span> label1</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			fmt.Println(<span class="string">&quot;\t\t\t\t\t\t输入错误&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>项目2-客户信息管理系统</p>
<p>project02</p>
<h2 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h2><p>文件在程序中是以流的形式来操作的</p>
<p>流：数据在数据源(文件)和程序(内存)之间经历的路径</p>
<p>输入流：数据从数据源(文件)到程序(内存)的路径  （读文件）</p>
<p>输出流：数据从程序(内存)到数据源(文件)的路径（写文件）</p>
<p>Go中有os.File结构体操作文件</p>
<h3 id="读取文件内容方式1"><a href="#读取文件内容方式1" class="headerlink" title="读取文件内容方式1"></a>读取文件内容方式1</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读取文件并显示在终端</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">	<span class="string">&quot;io&quot;</span></span><br><span class="line">	<span class="string">&quot;bufio&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 打开文件</span></span><br><span class="line">	file是一个指针</span><br><span class="line">	file, _ := os.Open(<span class="string">&quot;E:/学习/Go/src/Go_code/practise/bubbleSort/main.go&quot;</span>)</span><br><span class="line">	<span class="keyword">defer</span> file.Close() <span class="comment">// 及时关闭文件，防止内存泄露</span></span><br><span class="line">	reader:= bufio.NewReader(file)</span><br><span class="line">	<span class="comment">// 循环读取文件的内容</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		str, err := reader.ReadString(<span class="string">&#x27;\n&#x27;</span>) <span class="comment">// 读到一个换行就结束</span></span><br><span class="line">		<span class="keyword">if</span> err == io.EOF &#123; <span class="comment">// io.EOF 表示文件的末尾</span></span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Print(str)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="读取文件内容方式2不带缓冲的"><a href="#读取文件内容方式2不带缓冲的" class="headerlink" title="读取文件内容方式2不带缓冲的"></a>读取文件内容方式2不带缓冲的</h3><p>读取文件的内容并显示在终端(使用ioutil一次将整个文件读入到内存中)，这种方式适用于文件不大的情况。相关方法和函数(ioutil.ReadFile)</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;io/ioutil&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	file := <span class="string">&quot;E:/学习/Go/src/Go_code/chapter09/demo01/main.go&quot;</span></span><br><span class="line">	content, _ := ioutil.ReadFile(file)</span><br><span class="line">    <span class="comment">// 把文件的打开和关闭操作写在了函数内部</span></span><br><span class="line">	fmt.Println(<span class="type">string</span>(content))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="写文件操作"><a href="#写文件操作" class="headerlink" title="写文件操作"></a>写文件操作</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;bufio&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	filePath := <span class="string">&quot;E:\\学习\\Go\\src\\Go_code\\public\\abc.txt&quot;</span></span><br><span class="line">	file, err := os.OpenFile(filePath, os.O_WRONLY|os.O_CREATE, <span class="number">0666</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;open file err = %v&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 及时关闭文件</span></span><br><span class="line">	<span class="keyword">defer</span> file.Close()</span><br><span class="line">	str := <span class="string">&quot;Hello,Gardon\n&quot;</span></span><br><span class="line">	<span class="comment">// 写入时，使用带缓存的*writer</span></span><br><span class="line">	writer := bufio.NewWriter(file)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">		writer.WriteString(str)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 因为writer是带缓存的，因此在调用writeString方法时，内容是先写入缓存的，所以需要调用Flush方法</span></span><br><span class="line">	<span class="comment">// 将带缓存的数据真正写入到文件中，否则文件会没有数据</span></span><br><span class="line">	writer.Flush()</span><br><span class="line">	fmt.Println()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将一个文件的内容读出来写入另外一个文件，两个文件都已存在</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;io/ioutil&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	filePath1 := <span class="string">&quot;E:\\学习\\Go\\src\\Go_code\\public\\abc.txt&quot;</span></span><br><span class="line">	filePath2 := <span class="string">&quot;E:\\学习\\Go\\src\\Go_code\\public\\kkk.txt&quot;</span></span><br><span class="line">	content, err := ioutil.ReadFile(filePath1)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;read file err =&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span> </span><br><span class="line">	&#125;</span><br><span class="line">	ioutil.WriteFile(filePath2, content, <span class="number">0777</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>判断文件是否存在 os.Stat() 如果存在返回文件信息</p>
<h3 id="拷贝文件"><a href="#拷贝文件" class="headerlink" title="拷贝文件"></a>拷贝文件</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;bufio&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;io&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	filePath1 := <span class="string">&quot;E:\\学习\\Go\\src\\Go_code\\public\\2.jpg&quot;</span></span><br><span class="line">	filePath2 := <span class="string">&quot;E:\\学习\\Go\\src\\Go_code\\public\\abc.jpg&quot;</span></span><br><span class="line">	file1, _ := os.OpenFile(filePath1, os.O_RDWR, <span class="number">0666</span>)</span><br><span class="line">	file2, _ := os.OpenFile(filePath2, os.O_RDWR|os.O_CREATE, <span class="number">0666</span>)</span><br><span class="line">	<span class="keyword">defer</span> file1.Close()</span><br><span class="line">	<span class="keyword">defer</span> file2.Close()</span><br><span class="line">	reader := bufio.NewReader(file1)</span><br><span class="line">	writer := bufio.NewWriter(file2)</span><br><span class="line">	written, err := io.Copy(writer, reader)</span><br><span class="line">	writer.Flush()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;file copy err =&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(written)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="命令行参数的基本使用"><a href="#命令行参数的基本使用" class="headerlink" title="命令行参数的基本使用"></a>命令行参数的基本使用</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(<span class="string">&quot;命令行的参数有&quot;</span>, <span class="built_in">len</span>(os.Args))</span><br><span class="line"><span class="comment">// 遍历就可以获得命令行的所有输入参数</span></span><br><span class="line"><span class="keyword">for</span> _, val := <span class="keyword">range</span> os.Args &#123;</span><br><span class="line">	fmt.Println(val)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="flag包解析命令行参数"><a href="#flag包解析命令行参数" class="headerlink" title="flag包解析命令行参数"></a>flag包解析命令行参数</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;flag&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> user <span class="type">string</span></span><br><span class="line">	<span class="keyword">var</span> pwd <span class="type">string</span></span><br><span class="line">	<span class="keyword">var</span> host <span class="type">string</span></span><br><span class="line">	<span class="keyword">var</span> port <span class="type">string</span></span><br><span class="line">    &amp;user 就是接受用户命令行中输入的-u后面的参数值</span><br><span class="line">    <span class="string">&quot;u&quot;</span> 就是 -u 指定参数</span><br><span class="line">    <span class="string">&quot;&quot;</span> 默认值</span><br><span class="line">    <span class="string">&quot;用户名默认为空&quot;</span> 说明</span><br><span class="line">	flag.StringVar(&amp;user, <span class="string">&quot;u&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;用户名默认为空&quot;</span>)</span><br><span class="line">	flag.StringVar(&amp;pwd, <span class="string">&quot;p&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;密码默认为空&quot;</span>)</span><br><span class="line">	flag.StringVar(&amp;host, <span class="string">&quot;h&quot;</span>, <span class="string">&quot;localhost&quot;</span>, <span class="string">&quot;主机名，默认是localhost&quot;</span>)</span><br><span class="line">	flag.StringVar(&amp;port, <span class="string">&quot;port&quot;</span>, <span class="string">&quot;3306&quot;</span>, <span class="string">&quot;默认端口号为3306&quot;</span>)</span><br><span class="line">	flag.Parse()</span><br><span class="line">	fmt.Printf(<span class="string">&quot;user=%v, pwd=%v, host=%v, port=%v&quot;</span>, user, pwd, host, port)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="json序列化和反序列化操作"><a href="#json序列化和反序列化操作" class="headerlink" title="json序列化和反序列化操作"></a>json序列化和反序列化操作</h3><h4 id="序列化操作Marshal"><a href="#序列化操作Marshal" class="headerlink" title="序列化操作Marshal"></a>序列化操作Marshal</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;encoding/json&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">type</span> monster <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name     <span class="type">string</span> <span class="string">`json:&quot;name&quot;`</span></span><br><span class="line">	Age      <span class="type">int</span>    <span class="string">`json:&quot;age&quot;`</span></span><br><span class="line">	Birthday <span class="type">string</span> <span class="string">`json:&quot;birthday&quot;`</span></span><br><span class="line">	Sal      <span class="type">int</span>    <span class="string">`json:&quot;sal&quot;`</span></span><br><span class="line">	Skill    <span class="type">string</span> <span class="string">`json:&quot;skill&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> sli = []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">	jsonSli, err := json.Marshal(sli)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;filed err =&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(jsonSli)</span><br><span class="line">	<span class="keyword">var</span> person = <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;红孩儿&quot;</span>, <span class="string">&quot;age&quot;</span> : <span class="number">20</span>, <span class="string">&quot;address&quot;</span>: <span class="string">&quot;洪崖洞&quot;</span>&#125;</span><br><span class="line">	jsonPer, err := json.Marshal(person)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;err =&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%s\n&quot;</span>, jsonPer)</span><br><span class="line">	<span class="keyword">var</span> cow = monster&#123;<span class="string">&quot;牛魔王&quot;</span>, <span class="number">2000</span>, <span class="string">&quot;100-100&quot;</span>, <span class="number">8000</span>, <span class="string">&quot;牛魔拳&quot;</span>&#125;</span><br><span class="line">	jsonCow, err := json.Marshal(cow)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;err =&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%s&quot;</span>, jsonCow)</span><br><span class="line">	fmt.Println()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结构体和map都是转换成JavaScript对象格式，map切片转换成对象数组，普通数据格式就还是转换成普通数据格式，转换普通数据格式没有意义，结构体字段必须大写</p>
<h4 id="反序列化操作Unmarshal"><a href="#反序列化操作Unmarshal" class="headerlink" title="反序列化操作Unmarshal"></a>反序列化操作Unmarshal</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;encoding/json&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">type</span> monster <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name     <span class="type">string</span> <span class="string">`json:&quot;monster_name&quot;`</span></span><br><span class="line">	Age      <span class="type">int</span>    <span class="string">`json:&quot;monster_age&quot;`</span></span><br><span class="line">	Birthday <span class="type">string</span> <span class="string">`json:&quot;monster_birthday&quot;`</span></span><br><span class="line">	Sal      <span class="type">int</span>    <span class="string">`json:&quot;monster_sal&quot;`</span></span><br><span class="line">	Skill    <span class="type">string</span> <span class="string">`json:&quot;monster_skill&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	str := <span class="string">`&#123;&quot;monster_name&quot;:&quot;牛魔王&quot;,&quot;monster_age&quot;:2000,</span></span><br><span class="line"><span class="string">	&quot;monster_birthday&quot;:&quot;100-100&quot;,&quot;monster_sal&quot;:8000,&quot;monster_skill&quot;:&quot;牛魔拳&quot;&#125;`</span></span><br><span class="line">	<span class="keyword">var</span> monster1 monster</span><br><span class="line">	err := json.Unmarshal([]<span class="type">byte</span>(str), &amp;monster1)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;err =&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(monster1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在反序列化一个json字符串时，要确保反序列化后的数据类型和原来的序列化前后的数据类型一致</p>
<h2 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h2><p>Go语言自带有一个轻量级的测试框架testing和自带的go test命令来实现单元测试和性能测试，testing测试框架和其他语言中的测试框架类型，可以基于这个框架写针对相应函数的测试用例，也可以基于该框架写相应的压力测试用例。通过单元测试可以解决如下问题：</p>
<ol>
<li>确保每个函数是可运行的，并且运行结果是正确的</li>
<li>确保写出来的代码性能是好的</li>
<li>单元测试能及时的发现程序设计或实现的逻辑错误，使问题及早暴露，便于问题的定位解决，而性能测试的重点在于发现程序设计上的一些问题，让程序能够在高并发的情况下还能保持稳定</li>
</ol>
<p>原理是testing框架，会把xxx_test.go的文件引入，main里面调用TestXxx函数，必须是Test开头</p>
<h3 id="入门总结"><a href="#入门总结" class="headerlink" title="入门总结"></a>入门总结</h3><ol>
<li><p>测试用例文件名必须以 _test.go 结尾，比如cal_test.go，不是固定的</p>
</li>
<li><p>测试用例的函数必须以Test开头，一般来说就是Test+被测试的函数名，比如TestAddUpper</p>
</li>
<li><p>TestAddUpper(t *testing.T) 的形参类型必须是 *testing.T</p>
</li>
<li><p>一个测试用例文件中可以有多个测试用例函数，比如TestAddUpper, TestSub</p>
</li>
<li><p>运行测试用例指令</p>
<ol>
<li>cmd &gt; go test 如果运行正确，无日志，错误时，会输出日志。</li>
<li>cmd &gt; go test -v 运行正确或是错误时，都会输出日志</li>
</ol>
</li>
<li><p>当出现错误时，可以使用t.Fatalf来格式化输出错误信息，并退出程序</p>
</li>
<li><p>t.Logf 方法可以输出相应的日志</p>
</li>
<li><p>测试用例函数，并没有放在main函数中，也执行了，这就是测试用例的方便之处</p>
</li>
<li><p>PASS 表示测试用例运行成功，FALL 表示测试用例运行失败</p>
</li>
<li><p>测试单个文件，一定要带上被测试的原文件</p>
<p>go test -v cal_test.go</p>
</li>
<li><p>测试单个方法</p>
<p>go test -v -run TestAddUpper</p>
</li>
</ol>
<h2 id="goroutine和channel"><a href="#goroutine和channel" class="headerlink" title="goroutine和channel"></a>goroutine和channel</h2><h3 id="进程和线程的说明"><a href="#进程和线程的说明" class="headerlink" title="进程和线程的说明"></a>进程和线程的说明</h3><ol>
<li>进程就是程序在操作系统中的一次执行过程，是系统进行资源分配和调度的基本单位</li>
<li>线程是进程的一个执行实例，是程序执行的最小单元，它是比进程更小的能独立运行的基本单位</li>
<li>一个进程可以创建和销毁多个线程，同一个进程中的多个线程可以并发执行</li>
<li>一个程序至少有一个进程，一个进程至少有一个线程</li>
</ol>
<h3 id="并发和并行"><a href="#并发和并行" class="headerlink" title="并发和并行"></a>并发和并行</h3><ol>
<li>多线程程序在单核上运行，就是并发</li>
<li>多线程程序在多核上运行，就是并行</li>
</ol>
<h4 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h4><p>​	并发：因为是一个在一个CPU上，比如有10个线程，每个线程执行10毫秒(进行轮询操作)，从人的角度来看，好像这10个线程都在运行，但是从微观上看，在某一个时间点看，其实只有一个线程在执行，这就是并发</p>
<h4 id="并行"><a href="#并行" class="headerlink" title="并行"></a>并行</h4><p>​	并行：因为是在多个CPU上(比如有10个CPU)，比如有10个线程，每个线程执行10毫秒(各自在不同CPU上执行)，从人的角度来看，这10个线程都在执行，但是从微观上看，在某一个时间点上，也<strong>同时</strong>有10个线程在执行，这就是并行</p>
<h3 id="Go协程和Go主线程"><a href="#Go协程和Go主线程" class="headerlink" title="Go协程和Go主线程"></a>Go协程和Go主线程</h3><ol>
<li>Go主线程(有程序员直接称为线程&#x2F;也可以理解成进程)，一个Go线程上，可以有多个协程，可以这样理解，协程就是轻量级的线程</li>
<li><strong>Go协程的特点</strong><ol>
<li>有独立的栈空间</li>
<li>共享程序堆空间</li>
<li>调度由用户控制</li>
<li>协程是轻量级的线程</li>
</ol>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;Hello, World&quot;</span>, i)</span><br><span class="line">		time.Sleep(time.Second)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">go</span> test() <span class="comment">// 开启协程</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;Hello, Golang&quot;</span>, i)</span><br><span class="line">		time.Sleep(time.Second)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="快速入门小结"><a href="#快速入门小结" class="headerlink" title="快速入门小结"></a>快速入门小结</h3><ol>
<li>主线程是一个物理线程，直接作用在CPU上的。是重量级的，非常耗费CPU资源。</li>
<li>协程从主线程开启的，是轻量级的线程，是逻辑态。对资源消耗相对小</li>
<li>Golang的协程机制是重要的特点，可以轻松的开启上万个协程。其他编程语言的并发机制是一般基于线程，开启过多的线程，资源耗费大，这里就突显Golang在并发上的优势了</li>
</ol>
<h3 id="MPG模式"><a href="#MPG模式" class="headerlink" title="MPG模式"></a>MPG模式</h3><ol>
<li>M：操作系统的主线程(是物理线程)</li>
<li>P：协程执行需要的上下文</li>
<li>G：协程</li>
</ol>
<h3 id="设置Golang运行的CPU数"><a href="#设置Golang运行的CPU数" class="headerlink" title="设置Golang运行的CPU数"></a>设置Golang运行的CPU数</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;runtime&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	cpuNum := runtime.NumCPU()</span><br><span class="line">	fmt.Println(<span class="string">&quot;cpuNum =&quot;</span>, cpuNum)</span><br><span class="line">	runtime.GOMAXPROCS()  <span class="comment">// 1.8以后的版本都用不上</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="channel管道"><a href="#channel管道" class="headerlink" title="channel管道"></a>channel管道</h2><h3 id="解决不同goroutine之间的通信"><a href="#解决不同goroutine之间的通信" class="headerlink" title="解决不同goroutine之间的通信"></a>解决不同goroutine之间的通信</h3><ol>
<li><p>全部变量的互斥锁</p>
 <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	myMap = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">uint64</span>)</span><br><span class="line">	<span class="comment">// 声明一个全局的互斥锁</span></span><br><span class="line">	lock sync.Mutex</span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(n <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	lock.Lock()</span><br><span class="line">	<span class="keyword">var</span> sum <span class="type">uint64</span> = <span class="number">1</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= n; i++ &#123;</span><br><span class="line">		sum *= <span class="type">uint64</span>(i)</span><br><span class="line">	&#125;</span><br><span class="line">	myMap[n] = sum</span><br><span class="line">	lock.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">30</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> test(i)</span><br><span class="line">	&#125;</span><br><span class="line">	time.Sleep(time.Second * <span class="number">5</span>)</span><br><span class="line">	lock.Lock()</span><br><span class="line">	<span class="keyword">for</span> i, v := <span class="keyword">range</span> myMap &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;myMap[%d] = %d\n&quot;</span>, i, v)</span><br><span class="line">	&#125;</span><br><span class="line">	lock.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用管道channel</p>
</li>
</ol>
<h3 id="channel介绍"><a href="#channel介绍" class="headerlink" title="channel介绍"></a>channel介绍</h3><ol>
<li>channel本质就是一个数据结构-队列</li>
<li>数据是先进先出[FIFO： first in first out]</li>
<li>线程安全，多goroutine访问时，不需要加锁，就是说channel本身就是线程安全的</li>
<li>channel是有类型的，一个string的channel只能存放string类型数据</li>
</ol>
<h3 id="定义-声明channel"><a href="#定义-声明channel" class="headerlink" title="定义&#x2F;声明channel"></a>定义&#x2F;声明channel</h3><p>var 变量名 chan 数据类型</p>
<ol>
<li>channel是引用类型</li>
<li>channel必须初始化才能写入数据，即make后才能使用</li>
<li>管道是有类型的，intChan只能写入 int类型</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> intChan <span class="keyword">chan</span> <span class="type">int</span></span><br><span class="line">	intChan = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">3</span>)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;intChan 的值 = %v, intChan 本身的地址 = %v\n&quot;</span>, intChan, &amp;intChan)</span><br><span class="line">	<span class="comment">// 向管道写入数据</span></span><br><span class="line">	intChan &lt;- <span class="number">10</span></span><br><span class="line">	num := <span class="number">211</span></span><br><span class="line">	intChan &lt;- num</span><br><span class="line">	intChan &lt;- <span class="number">20</span></span><br><span class="line">	<span class="comment">// 读数据</span></span><br><span class="line">	<span class="keyword">var</span> n2 <span class="type">int</span></span><br><span class="line">	n2 = &lt;- intChan </span><br><span class="line">    &lt;- intChan  <span class="comment">// 可以不使用变量接收 直接丢了</span></span><br><span class="line">	fmt.Println(n2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="channel使用注意细节"><a href="#channel使用注意细节" class="headerlink" title="channel使用注意细节"></a>channel使用注意细节</h3><ol>
<li>channel中只能存放指定的数据类型</li>
<li>channel的数据放满后，就不能再放入了</li>
<li>如果从channel取出数据后，可以继续放入</li>
<li>在没有使用协程情况下，如果channel数据取完了，再取，就会报deadlock</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="keyword">type</span> cat <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name <span class="type">string</span></span><br><span class="line">	Age <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> allChan <span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	allChan = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;, <span class="number">10</span>)</span><br><span class="line">	cat1 := cat&#123;<span class="string">&quot;tom&quot;</span>, <span class="number">18</span>&#125;	</span><br><span class="line">	cat2 := cat&#123;<span class="string">&quot;tom~&quot;</span>, <span class="number">18</span>&#125;</span><br><span class="line">	allChan &lt;- cat1</span><br><span class="line">	allChan &lt;- cat2</span><br><span class="line">	allChan &lt;- <span class="number">10</span></span><br><span class="line">	allChan &lt;- <span class="string">&quot;jack&quot;</span></span><br><span class="line">	cat11 := (&lt;- allChan).(cat) <span class="comment">// 这里需要使用类型断言</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;cat11 的类型是 %T, cat11.Name = %v&quot;</span>, cat11, cat11.Name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="channel的关闭"><a href="#channel的关闭" class="headerlink" title="channel的关闭"></a>channel的关闭</h3><p>使用内置函数close可以关闭channel，当channel关闭后，就不能再向channel写数据了，但是仍然可以从该channel取数据</p>
<h3 id="channel的遍历"><a href="#channel的遍历" class="headerlink" title="channel的遍历"></a>channel的遍历</h3><p>channel支持for-range的方式进行遍历，注意这两个细节</p>
<ol>
<li>在遍历时，如果channel没有关闭，则会出现deadlock的错误</li>
<li>在遍历时，如果channel已经关闭，则会正常遍历数据，遍历完后就会退出遍历</li>
</ol>
<h3 id="goroutine和channel结合"><a href="#goroutine和channel结合" class="headerlink" title="goroutine和channel结合"></a>goroutine和channel结合</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">putNum</span><span class="params">(intChan <span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">20000</span>; i++ &#123;</span><br><span class="line">		intChan &lt;- i</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">close</span>(intChan)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">primeNum</span><span class="params">(intChan <span class="keyword">chan</span> <span class="type">int</span>, resChan <span class="keyword">chan</span> <span class="type">int</span>, exitChan <span class="keyword">chan</span> <span class="type">bool</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		v, ok := &lt;-intChan</span><br><span class="line">		<span class="keyword">if</span> !ok &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		flag := <span class="literal">true</span></span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">2</span>; i &lt;= v/<span class="number">2</span>; i++ &#123;</span><br><span class="line">			<span class="keyword">if</span> v%i == <span class="number">0</span> &#123;</span><br><span class="line">				flag = <span class="literal">false</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> flag &#123;</span><br><span class="line">			resChan &lt;- v</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	exitChan &lt;- <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	intChan := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">2000</span>)</span><br><span class="line">	resChan := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">10000</span>)</span><br><span class="line">	exitChan := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>, <span class="number">4</span>)</span><br><span class="line">	<span class="keyword">go</span> putNum(intChan)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">4</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> primeNum(intChan, resChan, exitChan)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">4</span>; i++ &#123;</span><br><span class="line">			&lt;-exitChan</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">close</span>(resChan)</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">for</span> v := <span class="keyword">range</span> resChan &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;%d\t&quot;</span>, v)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="channel使用细节和注意事项"><a href="#channel使用细节和注意事项" class="headerlink" title="channel使用细节和注意事项"></a>channel使用细节和注意事项</h3><ol>
<li>channel可以声明为只读或者只写性质<ol>
<li>在开启协程传递管道参数的时候可以设置，保护数据</li>
</ol>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 声明可读可写的管道</span></span><br><span class="line">	<span class="keyword">var</span> chan1 <span class="keyword">chan</span> <span class="type">int</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 声明只写的管道</span></span><br><span class="line">	<span class="keyword">var</span> chan2 <span class="keyword">chan</span>&lt;- <span class="type">int</span></span><br><span class="line">	chan2 = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">2</span>)</span><br><span class="line">	chan2 &lt;- <span class="number">2</span></span><br><span class="line">	<span class="comment">// num := &lt;-chan2 只写不能读会报错</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 声明只读的管道</span></span><br><span class="line">	<span class="keyword">var</span> chan3 &lt;-<span class="keyword">chan</span> <span class="type">int</span></span><br><span class="line">	chan3 = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">2</span>)</span><br><span class="line">	<span class="comment">// chan3 &lt;- 2 只读不能写</span></span><br><span class="line">	fmt.Println(chan1, chan2, chan3)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>使用select可以解决从管道取数据的阻塞问题<ol>
<li>select中有一个case成功就会退出，如果没有一个case能读取就一直堵塞。</li>
</ol>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	intChan := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">10</span>)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		intChan &lt;- i</span><br><span class="line">	&#125;</span><br><span class="line">	strChan := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>, <span class="number">5</span>)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">		strChan &lt;- <span class="string">&quot;hello&quot;</span> + fmt.Sprintf(<span class="string">&quot;%d&quot;</span>, i)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> v := &lt;-intChan:</span><br><span class="line">			fmt.Printf(<span class="string">&quot;从intChan取到的数据%d\n&quot;</span>, v)</span><br><span class="line">		<span class="keyword">case</span> v := &lt;-strChan:</span><br><span class="line">			fmt.Printf(<span class="string">&quot;从strChan取到数据%s\n&quot;</span>, v)</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			fmt.Printf(<span class="string">&quot;取不到数据了，不玩了\n&quot;</span>)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>goroutine中使用recover，解决协程中出现panic，导致程序崩溃</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sayHello</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		time.Sleep(time.Second)</span><br><span class="line">		fmt.Println(<span class="string">&quot;hello&quot;</span>, i)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 这里的map没有make所以会报错，没有加错误处理的话整个程序都会因为这个协程错误退出，</span></span><br><span class="line">    <span class="comment">// 加了之后其他协程不会有影响</span></span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> err := <span class="built_in">recover</span>(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;test() 发生错误&quot;</span>, err) </span><br><span class="line">            <span class="comment">// test() 发生错误 assignment to entry in nil map</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">var</span> myMap <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">string</span></span><br><span class="line">	myMap[<span class="number">0</span>] = <span class="string">&quot;hello&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">go</span> sayHello()</span><br><span class="line">	<span class="keyword">go</span> test()</span><br><span class="line">	time.Sleep(time.Second * <span class="number">11</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><h3 id="基本介绍-1"><a href="#基本介绍-1" class="headerlink" title="基本介绍"></a>基本介绍</h3><ol>
<li>反射可以在运行时动态获取变量的各种信息，比如变量的类型(type)，类别(kind)</li>
<li>如果是结构体变量，还可以获取到结构体本身的信息（包括结构体的字段，方法）</li>
<li>通过反射，可以修改变量的值，可以调用关联的方法</li>
<li>使用反射，需要import(“reflect”)</li>
</ol>
<h3 id="反射重要的函数和概念"><a href="#反射重要的函数和概念" class="headerlink" title="反射重要的函数和概念"></a>反射重要的函数和概念</h3><ol>
<li>reflect.TypeOf(变量名)，获取变量的类型，返回reflect.Type类型</li>
<li>reflect.ValueOf(变量名)，获取变量的值，返回reflect.Value类型，reflect.Value是一个结构体类型</li>
<li>变量、interface{} 和 reflect.Value是可以相互转换的，这点在实际开发中，会经常使用到</li>
</ol>
<h3 id="反射注意事项和细节说明"><a href="#反射注意事项和细节说明" class="headerlink" title="反射注意事项和细节说明"></a>反射注意事项和细节说明</h3><ol>
<li>reflect.Value.Kind获取变量的类别，返回的是一个常量</li>
<li>Type是类型，Kind的类别，Type和Kind可能是相同的，也可能是不同的</li>
<li>使用反射的方式获取变量的值(并返回对应的类型)，要求数据类型匹配，比如x是int，那么就应该使用reflect.Value(x).Int()，而不能使用其他的，否则报panic</li>
<li>通过反射来修改变量，注意当使用SetXxx方法来设置需要通过对应的指针类型来完成，这样才能改变传入的变量的值，同时需要使用到reflect.Value.Elem()方法</li>
</ol>
<h3 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;reflect&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">type</span> monster <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name  <span class="type">string</span> <span class="string">`json:&quot;name&quot;`</span></span><br><span class="line">	Age   <span class="type">int</span>    <span class="string">`json:&quot;age&quot;`</span></span><br><span class="line">	Score <span class="type">float32</span></span><br><span class="line">	Sex   <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m monster)</span></span> Print() &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;------- start -------&quot;</span>)</span><br><span class="line">	fmt.Println(m)</span><br><span class="line">	fmt.Println(<span class="string">&quot;-------- end --------&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m monster)</span></span> GetSum(n1, n2 <span class="type">int</span>) <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> n1 + n2</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m monster)</span></span> Set(name <span class="type">string</span>, age <span class="type">int</span>, score <span class="type">float32</span>, sex <span class="type">string</span>) &#123;</span><br><span class="line">	m.Name = name</span><br><span class="line">	m.Age = age</span><br><span class="line">	m.Score = score</span><br><span class="line">	m.Sex = sex</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testStruc</span><span class="params">(a <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	typ := reflect.TypeOf(a)</span><br><span class="line">	rVal := reflect.ValueOf(a)</span><br><span class="line">	kd := rVal.Kind()</span><br><span class="line">	<span class="keyword">if</span> kd != reflect.Struct &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;expect struct&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 获取字段总数，用于遍历字段</span></span><br><span class="line">	num := rVal.NumField()</span><br><span class="line">	fmt.Printf(<span class="string">&quot;this struct has %d fields\n&quot;</span>, num)</span><br><span class="line">	<span class="comment">// 遍历字段</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; num; i++ &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;field %d: 值为=%v\n&quot;</span>, i, rVal.Field(i))</span><br><span class="line">		<span class="comment">// 获取struct标签，需要通过reflect.Type来获取标签的值</span></span><br><span class="line">		tagVal := typ.Field(i).Tag.Get(<span class="string">&quot;json&quot;</span>)</span><br><span class="line">		<span class="keyword">if</span> tagVal != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;field %d: tag为=%v\n&quot;</span>, i, tagVal)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	numOfMethod := rVal.NumMethod()</span><br><span class="line">	fmt.Printf(<span class="string">&quot;struct has %d method\n&quot;</span>, numOfMethod)</span><br><span class="line">	<span class="comment">// 方法的排序默认是按照函数名的排序(ASCII)</span></span><br><span class="line">	rVal.Method(<span class="number">1</span>).Call(<span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> params []reflect.Value</span><br><span class="line">	params = <span class="built_in">append</span>(params, reflect.ValueOf(<span class="number">10</span>))</span><br><span class="line">	params = <span class="built_in">append</span>(params, reflect.ValueOf(<span class="number">20</span>))</span><br><span class="line">	res := rVal.Method(<span class="number">0</span>).Call(params)</span><br><span class="line">	fmt.Println(res[<span class="number">0</span>].Int())</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> a = monster&#123;</span><br><span class="line">		Name:  <span class="string">&quot;黄鼠狼&quot;</span>,</span><br><span class="line">		Age:   <span class="number">20</span>,</span><br><span class="line">		Score: <span class="number">30.8</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	testStruc(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="TCP网络编程"><a href="#TCP网络编程" class="headerlink" title="TCP网络编程"></a>TCP网络编程</h2><h3 id="网络编程的基本介绍"><a href="#网络编程的基本介绍" class="headerlink" title="网络编程的基本介绍"></a>网络编程的基本介绍</h3><p>Golang的主要设计目标之一就是面向大规模后端服务程序，网络通信这块是服务端程序必不可少也是至关重要的</p>
<p>网络编程有两种</p>
<ol>
<li>TCP socket编程：是网路编程的主流。之所以叫TCP socket编程，是因为底层是基于tcp&#x2F;ip协议的</li>
<li>b&#x2F;s结构的http编程：我们使用浏览器去访问服务器时，使用的就是http协议，而http底层依旧是用tcp socket实现的</li>
</ol>
<p><img src="https://i.loli.net/2021/01/10/2nHKrzPTN7Sfo3s.png" alt="image-20200811150133360"></p>
<p>qq相互通信案例</p>
<p><img src="https://i.loli.net/2021/01/10/78UdTRIN9qlfb5x.png" alt="image-20200811152310216"></p>
<h4 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h4><p>我们这里指的端口不是物理意义上的端口，而是特指tcp&#x2F;ip协议中的端口，是逻辑意义上的端口。端口就是通过端口号来标记的，端口号只有整数，范围是从0-65535</p>
<ol>
<li><p>0号是保留端口</p>
</li>
<li><p>1-1024是固定端口，又叫有名端口，即被某些程序固定使用，一般程序员不使用</p>
<p> 22：SSH远程登录协议    23：telnet使用    21：ftp使用</p>
<p> 25：smtp服务使用    80：iis使用    7：echo服务</p>
</li>
<li><p>1025 - 65535是动态端口，这些端口程序员可以使用</p>
</li>
</ol>
<h3 id="tcp-socket编程的快速入门"><a href="#tcp-socket编程的快速入门" class="headerlink" title="tcp socket编程的快速入门"></a>tcp socket编程的快速入门</h3><h4 id="服务端处理流程"><a href="#服务端处理流程" class="headerlink" title="服务端处理流程"></a>服务端处理流程</h4><ol>
<li>监听端口</li>
<li>接受客户端的tcp连接，建立客户端和服务端的链接</li>
<li>创建goroutine，处理该链接的请求（通常客户端通过链接发送请求包）</li>
</ol>
<h4 id="客户端处理流程"><a href="#客户端处理流程" class="headerlink" title="客户端处理流程"></a>客户端处理流程</h4><ol>
<li>建立与服务端的链接</li>
<li>发送请求数据[终端]，接收服务器返回的结果数据</li>
<li>关闭链接</li>
</ol>
<h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><h3 id="基本介绍-2"><a href="#基本介绍-2" class="headerlink" title="基本介绍"></a>基本介绍</h3><ol>
<li><p>Redis 是 NoSQL 数据库，不是传统的关系型数据库</p>
</li>
<li><p>Redis：REmote Dictionary Server(远程字典服务器)，Redis性能非常高，单机能够达到15w qbs，通常适合做缓存，也可以持久化</p>
</li>
<li><p>是完全开源免费的，高性能的(key&#x2F;value)分布式内存数据库，基于内存运行并支持持久化的NoSQL数据库，是最热门的NoSQL数据库之一，也称为数据结构服务器</p>
</li>
<li><p>下载地址<a target="_blank" rel="noopener" href="https://github.com/tporadowski/redis/releases">https://github.com/tporadowski/redis/releases</a></p>
</li>
<li><p>占用6379端口</p>
</li>
<li><p>Redis的启动：双击redis-server.exe</p>
</li>
<li><p>命令文档<a href="">redisdoc.com</a></p>
</li>
</ol>
<h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p>说明：Redis安装好后，默认有16个数据库，初始默认使用0号库，编号是0…15</p>
<ol>
<li><p>添加key-val [set]</p>
<p> set key value [expiration EX seconds|PX milliseconds] [NX|XX]</p>
</li>
<li><p>查看当前Redis的 所有key [key *]</p>
</li>
<li><p>获取key对应的值 [get key]</p>
<p> get key</p>
</li>
<li><p>切换Redis数据库 [select index]</p>
</li>
<li><p>查看当前数据库的key-val数量 [dbsize]</p>
</li>
<li><p>清空当前数据库的key-val和清空所有数据库的key-val [flushdb flushall]</p>
</li>
</ol>
<h3 id="redis的五大数据类型和crud"><a href="#redis的五大数据类型和crud" class="headerlink" title="redis的五大数据类型和crud"></a>redis的五大数据类型和crud</h3><p>redis的五大数据类型是：String(字符串)、Hash(哈希)、List(列表)、Set(集合)、zset(sorted set: 有序集合)</p>
<h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><p>string是redis最基本的类型，一个key对应一个value</p>
<p>string类型是二进制安全的。除普通的字符串外，也可以存放图片等数据</p>
<p>redis中字符串value最大是512M</p>
<h5 id="字符串-crud"><a href="#字符串-crud" class="headerlink" title="字符串-crud"></a>字符串-crud</h5><p><strong>set</strong> set key value 如果存在就相当于修改，不存在则是添加</p>
<p><strong>get</strong> get key 查找</p>
<p><strong>del</strong> 删除</p>
<p><strong>setex</strong> key seconds value 设置key超时，就是在seconds之后消失</p>
<p><strong>mset</strong> 一次设置一个或多个key-value</p>
<p><strong>mget</strong> 一次查找一个或多个key</p>
<h4 id="Hash-哈希表"><a href="#Hash-哈希表" class="headerlink" title="Hash(哈希表)"></a>Hash(哈希表)</h4><p>redis Hash 是一个键值对集合，</p>
<p>redis Hash 是一个string类型的field和value的映射表，Hash特别适合用于存储对象</p>
<p><strong>hset</strong>  hset key field value 如果存在修改，不存在则添加</p>
<p>​	hset user name zhangsan</p>
<p>​	hset user age 30</p>
<p><strong>hget</strong>  hget key field 查找</p>
<p><strong>hgetall</strong> hgetall key 查找key的所有字段信息</p>
<p><strong>hdel</strong> hdel key field 删除key的指定field</p>
<p><strong>hmset&#x2F;hmget</strong> 一次设置或获取多个字段</p>
<p>​	hmset key field1 value1 field2 value2 </p>
<p>​	hmget key field1 field2</p>
<p><strong>hlen</strong> hlen key 返回存储在key中的哈希中包含的字段数</p>
<p><strong>hexists</strong> hexists key field  查看哈希表key中，给定field是否存在</p>
<h4 id="List-列表"><a href="#List-列表" class="headerlink" title="List(列表)"></a>List(列表)</h4><p>列表是简单的字符串列表，按照插入顺序排序。可以添加一个元素到列表的头部(左边)或尾部(右边)</p>
<p>List本质是个链表，List的元素是有序的，元素的值可以重复</p>
<p><strong>lpush</strong> lpush key value1 value2 … 从列表的头部插入数据</p>
<p><strong>rpush</strong> rpush key value1 value2 … 从列表的尾部插入数据</p>
<p><strong>lrange</strong> lrange key start end 0 是第一个， -1 是最后一个 遍历</p>
<p><strong>lpop</strong> lpop key 从列表头部取走一个元素</p>
<p><strong>rpop</strong> rpop key 从列表尾部取走一个元素</p>
<p><strong>lindex</strong> lindex key index 按照索引下标获得元素(从左到右，索引号从0开始)</p>
<p><strong>llen</strong> llen key 返回列表key的长度，如果key不存在，则key被解释为一个空列表，返回0</p>
<p>如果值全部移除，对应的键也就消失了</p>
<h4 id="Set-集合"><a href="#Set-集合" class="headerlink" title="Set(集合)"></a>Set(集合)</h4><p>redis的Set是string类型的无序集合</p>
<p>底层是HashTable数据结构，Set也是存放很多字符串元素，字符串元素是无序的，而且元素的值不能重复</p>
<p><strong>sadd</strong> sadd key member1 member2 … 向集合 key 中添加成员member，如果集合不存在则创建</p>
<p><strong>smembers</strong> smembers key 取出集合 key 中的所有成员</p>
<p><strong>sismember</strong> smember key member 判断值是否是集合 key 中的成员 存在返回1 不存在返回0</p>
<p><strong>srem</strong> srem key member … 删除集合 key 中的指定成员</p>
<h3 id="redis连接池"><a href="#redis连接池" class="headerlink" title="redis连接池"></a>redis连接池</h3><p>说明：通过Golang 对 redis 操作，还可以通过Redis连接池，流程如下：</p>
<ol>
<li><p>实现初始化一定的连接，放入到连接池</p>
</li>
<li><p>当Go需要操作redis时，直接从redis连接池取出连接即可</p>
</li>
<li><p>这样可以节省临时获取redis连接的时间，从而提升效率</p>
</li>
<li><p>核心代码</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var pool *redis.Pool</span><br><span class="line">pool = &amp;redis.Pool&#123;</span><br><span class="line">	MaxIdle: 8, // 最大空闲连接数</span><br><span class="line">	MaxActive: 0, // 表示和数据库的最大连接数，0表示没有限制</span><br><span class="line">	IdleTimeout:100, // 最大空闲时间</span><br><span class="line">	Dial: func() (redis.Conn, error) &#123; // 初始化连接的代码，连接哪个ip的redis</span><br><span class="line">		return redis.Dial(&quot;tcp&quot;, &quot;localhost:6379&quot;)</span><br><span class="line">	&#125;,</span><br><span class="line">&#125;</span><br><span class="line">conn := pool.Get() // 从连接池中取出一个连接</span><br><span class="line">conn.Close() // 关闭连接池，一旦关闭连接池，就不能从连接池再取出连接</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h2><h3 id="数据结构的介绍"><a href="#数据结构的介绍" class="headerlink" title="数据结构的介绍"></a>数据结构的介绍</h3><ol>
<li>数据结构是一门研究算法的学科，自从有了编程语言也就有了数据结构，学好数据结构可以编写出更加漂亮，更加有效率的代码</li>
<li>要学好数据结构就要多多考虑如何将生活中遇到的问题，用程序去实现解决</li>
<li>程序 &#x3D; 数据结构 + 算法</li>
</ol>
<h3 id="稀疏数组sparsearray"><a href="#稀疏数组sparsearray" class="headerlink" title="稀疏数组sparsearray"></a>稀疏数组sparsearray</h3><h4 id="五子棋问题"><a href="#五子棋问题" class="headerlink" title="五子棋问题"></a>五子棋问题</h4><p>当一个数组中大部分元素为0，或者为同一个值的数组中，可以使用稀疏数组来保存该数组。</p>
<p>稀疏数组的处理方法是：</p>
<ol>
<li>记录数组一共有几行几列，有多少个不同的值</li>
<li>把具有不同值的元素的行列及值记录在一个小规模的数组中，从而缩小程序的规模</li>
</ol>
<p><img src="https://i.loli.net/2021/01/10/JakAWTjSwhnqcIz.png" alt="image-20200905204259393"></p>
<p>（加总行和总列是多少，默认值是多少）</p>
<h4 id="应用实例"><a href="#应用实例" class="headerlink" title="应用实例"></a>应用实例</h4><ol>
<li>使用稀疏数组，来保存类似前面二位数组（棋盘、地图等等）</li>
<li>把稀疏数组存盘，并且可以重新恢复原来的二位数组</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://cy77cc.github.io/2025/03/19/Golang/" data-id="cm8fj4ni30000c8lz6tp35ghm" data-title="golang学习笔记" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archiv</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/03/">March 2025</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">letzter Beitrag</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2025/03/20/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/">(no title)</a>
          </li>
        
          <li>
            <a href="/2025/03/19/Golang/">golang学习笔记</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2025 Mr. Zhang<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>